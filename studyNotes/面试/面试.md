## 面试真题 + 解析

```

  var str1 = new RegExp("e")
  document.write(str1.exec("hello"))
  以上代码输出结果为 (e)

  解析:
    exec()方法用于检索字符串中的正则表达式的匹配.
    返回值:返回一个数组,其中存放匹配的结果;如果没有找到匹配值,则返回 null
    "e".exec("hello") 中, "e" 是正则表达式, "hello" 是检索的字符串,因为 "hello" 字符串中可以匹配到 "e",所以返回结果为 e


```

```

  js 原生属性中,可以使用 element.parentNode 获取父对象.

```

```

  var A = {n: 4399}
  var B = function(){
    this.n = 9999
  }
  var C = function(){
    var n = 8888
  }
  B.prototype = A
  C.prototype = A
  var b = new B()
  var c = new C()
  A.n++
  console.log(b.n)
  console.log(c.n)
  以上代码,在浏览器中执行的结果是 (9999 4400)

  解析:
    1.首先改写 B 和 C 的原型,使它们的原型对象都指向 A,因此,B 和 C 的原型都拥有属性 n:4399
    2.通过 new 创建 B 和 C 的实例,用这个方式调用构造函数需要四步:
      a> 创建一个新的实例对象 a 和 b
      b> 将构造函数的作用域赋值给新对象(this 指向新对象 b, c);此时 B 中的 this 指向实例对象 b,即 b.n=9999
      c> 执行构造函数中的代码;给实例添加属性,此时执行 b.n=9999,为 b 添加实例属性;执行 var n=8888,对实例 c 没有影响
      d> 返回新对象;返回实例对象 b,拥有实例属性 n=9999,通过原型链,具有原型属性 n=4399;返回实例对象 c,只有原型属性 n=4399
    3.然后改写原型的属性 A.n,因为原型上的属性是公用的,所以 b 和 c 中原型上的 n 属性都为 4400,吧 还有实例属性 n=9999.由于查找属性的时候现在实例上找,再去原型中找,只要找到了就不往后面找.于是 b.n=9999(在实例中找到),c.n=4400(在原型中找到)

```

```

  x={x: 1}
  y={y: 1}
  z=1
  n="1"
  只有 z==n 的结果为 true

  解析:
    x 和 y是不同的对象，地址不同，z 和 n值同，类型不同

```

```

  页面有一个按钮 button 标签, id 为 button1,通过原生 js 禁用.
  document.getElementById(“button1”).setAttribute(“disabled”,”true”)
  document.getElementById(“button1”).disabled=true;

  解析:
    setAttribute() 方法添加指定的属性,并未其赋指定的值;如果这个指定的属性已存在,则仅设置/更改值.
    readonly 属性规定输入字段为只读,只读字段是不可修改的,但是仍然可以使用 tab 键切换到该字段,还可以选中或拷贝其文本.readonly 属性可以防止用户对值进行修改.该属性只针对 input 和 textarea 有效.
    disabled 属性用于指明按钮禁用.

```

```

  js 数组的方法中,concat() 不能改变自身数组

  解析:
    concat() 连接数组但是不改变原数组
    splice() 删除数据会改变数组
    sort() 排序会改变数组
    pop() 出栈返回最后一个最后一个元素，改变数组

```

```

  在 jquery 中想要找到所有元素的同辈元素,可以用 siblings([expr]) 进行实现

  解析:
    jquery 中的方法:
      siblings() 方法返回被选元素的所有同胞元素。
      next() 方法返回被选元素的下一个同胞元素。
      find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。

```

```

  2.toString() => Uncaught SyntaxError: Invalid or unexpected token     解析:数字后面.会被解析为小数点,变为 (2.)toString 就会报错
  2..toString() => 2    解析:因为连续的两个小数点不符合number的格式规则，第二个小数点才会被解析为调用方法
  2 .toString() => 2    解析:因为空格,所以小数点会被解析为调用方法
  (2).toString() => 2   解析:正常调用

```

```

  ul:无序列表
  dl:定义列表
  ol:有序列表
  li:定义列表项目

```

```

  css 中 clear 的作用是指明该元素周围不可出现浮动元素
  
  解析:
    清除浮动方法:
      1.给父级元素添加 class="clearflex"
      2.在 css 中给父级添加属性: overflow:hidden
      3.伪元素清除法
      4.建立空的 div,命名 clear,在 css 中添加 clear:both
    clear 属性(这个规则只能影响使用清除的元素本身,不能影响其他元素)
      1.left:在左侧不允许浮动元素
      2.right:在右侧不允许浮动元素
      3.both:在左右两侧均不允许浮动元素
      4.none:默认值,允许浮动元素出现在两侧
      5.inherit:规定应该从父元素继承 clear 属性的值

```

```

  html 注释为 <!-- -->
  css 注释为 /* */
  js 注释为:
    1> 单行注释 //
    2> 多行注释 /* */

```

```

  <head>
    <style>
      #bg{
        background-image:url("/img/bg.png")
      }
      #test{
        background-image:url("/img/test.png")
      }
    </style>
  </head>
  <body>
    <div id="test"></div>
    <img src="/img/thumbnail.png">
    <img src="/img/arrow.png" style="visibility: hidden">
  </body>
  基于以上 html 结构,浏览器共会发送 3 个图片请求

  解析:
    css 控制前端图片 http 请求的各种情况:
      1. 隐藏图片
        <img src="haorooms.jpg" style="display: none" />
        结论:只有 Opera 不产生请求
        注意:使用 visibility:hidden 隐藏图片时,在 Opera 下也会产生请求
      2. 重复图片
        <img src="haorooms.jpg" />  
        <img src="haorooms.jpg" />  
        结论:所有浏览器都只产生一次请求
      3.重复背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg) 
          }   
          .test2 { 
            background: url(haorooms.jpg) 
          }   
        </style>   
        <div class="test1">test1</div>   
        <div class="test2">test2</div>  
        结论:所有浏览器都只产生一次请求
      4.不存在的元素的背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg) 
          }   
          .test2 { 
            background: url(http2.jpg) 
          } /* 页面中没有class为test2的元素 */  
        </style>   
        <div class="test1">test1</div>  
        结论:背景仅在应用的元素在页面中存在时,才会产生请求.这对 css 框架来说,很有意义
      5.隐藏元素的背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg); 
            display: none; 
          }   
          .test2 { 
            background: url(http2.jpg); 
            visibility: hidden; 
          }   
        </style>   
        <div class="test1">test1</div>  
        结论:Opera 和 Firefox对于用 display: none 隐藏的元素背景，不会产生 HTTP 请求。仅当这些元素非 display: none 时，才会请求背景图片。
      6.多重背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg); 
          }   
          .test1 { 
            background: url(http2.jpg); 
          }   
        </style>   
        <div class="test1">test1</div>  
        上面这段代码的 http 请求，只会请求 http2.jpg 这一张图片，原因是 test1 的 class 把上面的给覆盖掉了，所有只请求后面的一张图片
        如果使用 css3 多张背景图片:
        <style type="text/css">   
          .test1 { 
            background-image:url("haorooms.jpg"),url("http2.jpg"); 
          }   
        </style>   
        <div class="test1">test1</div>  
        webkit引擎浏览器对背景图都请求，是因为支持CSS3中的多背景图。
      7.hover 的背景加载
        <style type="text/css">   
          a.test1 { 
            background: url(haorooms.jpg); 
          }   
          a.test1:hover { 
            background: url(http2.jpg); 
          }   
        </style>   
        <a href="#" class="test1">test1</a>
        结论:触发 hover 时,才会请求 hover 状态下的背景;不触发的话,只请求默认的背景图片
      8.JS 里 innerHTML 中的图片
        <script type="text/javascript">   
          var el = document.createElement('div');   
          el.innerHTML = '<img src="haorooms.jpg" />';   
          //document.body.appendChild(el);   
        </script> 
        结论:只有 Opera 不会马上请求图片
        注意:当添加到 DOM 树上时,Opera 才会发送请求
      9.图片预加载
        js 方法:
          <script type="text/javascript">   
            new Image().src = 'haorooms.jpg';   
            new Image().src = 'http2.jpg';   
          </script> 
        无 js 支持的环境下,可以采用隐藏元素来预加载:
          <img src="haoroomscom.jpg" style="visibility: hidden; height: 0; width: 0" /> 
    总结:
      1.对于隐藏图片和隐藏元素的背景,Opera 不会产生请求
      2.对于隐藏元素的背景,Firefox 也不会产生请求
      3.对于尚未插入 DOM 树的 img 元素,Opera 不会产生请求
      4.基于 webkit 引擎的 Safari 和 Chrome 支持多背景图
      5.其他情况,所有主流浏览器保持一致
      
```

```

  <form name="a">
    <select name="a" size="1" id="obj">
      <option value="a">1</option>
      <option value="b">2</option>
      <option value="c">3</option>
    </select>
  </form>
  基于以上 html 结构,可以使用 obj.options[obj.selectedIndex].text 获取表单 select 域的选择部分的文本,使用 obj.options[obj.selectIndex].value 或 obj.value 获取表单 select 域的选择部分 value

  解析:
    window.onload = function(){
      // 首先获得下拉框的节点对象
      var obj = document.getElementById("obj")
      // 获得当前选中的值
      var value = obj.value
      // 获得该下拉框所有的 option 的节点对象
      var options = obj.options   // 注意:得到的 options 是一个对象数组
      // 获得某个 option 的 value 值,比如获取第一个 option 的 value
      var value1 = options[0].value
      // 获得某个 option 的文本内容,比如获取第一个 option 的文本
      var text1 = options[0].text
      // 获得当前选中的 option 的索引
      var index = obj.selectedIndex
      // 获得当前选中的 option 的文本内容
      var selectedText = options[index].text
    }

```

```

  Number() => 0
  Number(0) => 0
  Number("") => 0
  Number("0") => 0
  Number(false) => 0
  Number(null) => 0
  Number([]) => 0
  Number([0]) => 0
  Number(undefined) => NaN
  parseInt("")  => NaN
  parseInt(null)  => NaN
  parseInt(undefined)  => NaN
  null==0 => false
  undefined==0 => false

```

```

  Canvas 对象支持所有的 JavaScript 的鼠标事件,但绘制在其中的图形并不作为其子元素存在,所以需要通过获取 Canvas 对象上的鼠标坐标来绑定事件.因此,并不能直接给 Canvas 里面的图形绑定事件
  Canvas 和 SVG 都可以使用 JavaScript 来进行绘制
  WebGL(Web 图形库)是一种 JavaScript API,用于在任何兼容的 Web 浏览器中呈现交互式 3D 和 2D 图形,而无需使用插件;WebGL 通过引入一个与 OpenGL ES 2.0 紧密相符合的 API,可以在 HTML5 的 canvas 元素中使用
  SVG 功能更完善,适合静态图片展示,高保真文档查看和打印的应用场景;Canvas 提供的功能更原始,适合像素处理,动态渲染和大数据量绘制

```

```

  (function() {
    var a = b = 5;
  })();   
  console.log(b);
  console.log(a);
  上面输出的结果: 5, Uncaught ReferenceError: a is not defined

  解析:
    a> 使用 var 操作符,定义的变量将成为该作用域中的局部变量
    b> 省略 var 操作符,会创建一个全局变量，但在局部作用域中定义的全局变量很难维护，也会由于相应变量不会马上就有定义而导致不必要的混乱，给未经声明的变量赋值在严格模式下会导致抛出 Reference 错误，所以不推荐使用。
    c> 赋值运算是把左边的值给右边，所以这个连续的赋值运算符表达式，是从右往左
    综上所述,a 为局部变量,b 为全局变量,在函数运行结束后,a 变量即被销毁.

```

```

  <html>
    <body>
      <div id="ele" class="div">
        <span id="s1" class="sp" lang="zh-cn">
        </span>
      </div>
    </body>
    <script type="text/javascript">  
      function exct() {
        var oEle = document.getElementById("ele");
        var child = oEle.children;
        console.log("ele.children的执行结果是:");
        for(i = 0; i < child.length; i++){
          console.log(child[i].tagName);
        }  
        child = oEle.childNodes;
        console.log("ele.childNodes的执行结果是:");
        for(i = 0; i < child.length; i++){
          console.log(child[i].tagName);
        }
      }  
    exct (); 
    </script>
  </html>
  上面代码的运行结果是:
    ele.children的执行结果是:
    SPAN
    ele.childNodes的执行结果是:
    undefined
    SPAN
    undefined

  解析:
    1> children 属性返回子元素的元素节点
    2> childNodes 属性返回所有的子节点,包括文本节点、注释节点、元素节点
    3> tagName 属性用来获取元素的标签名
    由此可以知道:
      oEle.children 获取的是子元素的元素节点 <span id="s1" class="sp" lang="zh-cn"></span>,在通过 tagName 获取元素的标签名,所以得到 SPAN
      oEle.childNodes 获取的是所有子节点,得到了一个 span 元素节点,还有两个文本节点:空格和换行,因此得到了三个子节点,而 tagName 用来获取的是元素的标签名,文本节点是没有标签名的,所以就为 undefined

```

## 补充知识点

### 静态语言（强类型语言）

静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 例如：C++、Java、Delphi、C#等。

### 动态语言（弱类型语言）

动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

### HTML5 语义化标签

#### 优点

1. 为了在没有 css 的情况下,页面也能呈现出很好的内容结构、代码结构
2. 比 <div> 标签有更加丰富的含义,方便开发和维护
3. 方便搜索引擎能识别页面结构,有利于 SEO
4. 方便其他设备解析(如移动设备、盲人阅读器等)
5. 有利于合作，遵守 W3C 标准

#### 注意

1. 尽可能少的使用无语义的标签 div 和 span
2. 在语义不明显时,既可以使用 div 或者 p 时,尽量用 p,因为 p 在默认情况下有上下间距,对兼容特殊终端有利
3. 不要使用纯样式标签，如：b、font、u等，改用css设置
4. 需要强调的文本，可以包含在strong或者em标签中
5. 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td
6. 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
7. 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性

#### 1.header 与 hgroup

- 放在页面或布局的顶部,一般放置导航栏或标题
- 一个文档可以包含一对或者一对以上的 <header> 标签
- 如果有连续多个 h1-h6 标签就用 hgroup
- 如果有连续多个标题和其他文章数据,h1-h6 标签就用 hgroup 包住,和其他文章元数据一起放入 header 标签

#### 2.nav

- 表示页面的导航,可以在 header 标签中使用,也可以显示在侧边栏中.一个页面之中可以有多个 nav 标签
- 为了方便搜索引擎解析,最好将主要的链接放在 nav 中

#### 3.aside

- 所包含的内容不合适页面的主要内容、具有独立性,是对页面的补充
- 一般使用在页面、文章的侧边栏、广告、友情链接等区域

#### 4.footer

- 一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。一个页面也可以有多个 footer

#### 5.article

- 应该使用在相对比较独立、完整的的内容区块，所以可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用article 元素。article 可以互相嵌套。

#### 6.section

- 一组或者一节内容。
- div、section、article 三者的比较
  - div:应用广泛,任意一个区域
  - section:包含的内容时一个明确的主题,通常有标题区域
  - article:如果页面中需要一个单独的模块来实现一个单独的功能,就用 article,其他时候都用 section

#### 7.time

- 可以带格式的时间标签

#### 8.mark

- 高亮

#### 9.address

- address 代表区块容器,必须是作为联系信息出现,邮编地址、邮件地址等,一般出现在 footer 标签中

### HTML DOM 事件

HTML DOM 事件允许 Javascript 在 HTML 文档元素中注册不同事件处理程序。

事件通常与函数结合使用，函数不会在事件发生前被执行

#### 鼠标事件

```

  onclick:当用户点击某个对象时调用的事件句柄
  oncontextmenu:在用户点击鼠标右键打开上下文菜单时触发
  ondblclick	当用户双击某个对象时调用的事件句柄
  onmousedown:鼠标按钮被按下
  onmouseenter:当鼠标指针移动到元素上时触发
  onmouseleave:当鼠标指针移出元素时触发	
  onmousemove:鼠标被移动
  onmouseover:鼠标移到某元素之上
  onmouseout:鼠标从某元素移开
  onmouseup:鼠标按键被松开

```

#### 键盘事件

```

  onkeydown:某个键盘按键被按下
  onkeypress:某个键盘按键被按下并松开
  onkeyup:某个键盘按键被松开

```

#### 表单事件

```

  onblur:元素失去焦点时触发
  onchange:该事件在表单元素的内容改变时触发( <input>, <keygen>, <select>, 和 <textarea>)
  onfocus:元素获取焦点时触发
  onfocusin:元素即将获取焦点时触发
  onfocusout:元素即将失去焦点时触发
  oninput:元素获取用户输入时触发
  onreset:表单重置时触发
  onsearch:用户向搜索域输入文本时触发 (<input="search">)
  onselect:用户选取文本时触发 ( <input> 和 <textarea>)
  onsubmit:表单提交时触发

```

### Number()

#### Number() 可以用于任何数据类型的转换,转换规则如下:

- 如果是 Boolean 值,true 和 false 将分别被转换为 1 或 0
- 如果是 null 值,则返回 0
- 如果是 undefined,返回 NaN
- 如果是字符串则遵循以下规则:
  - 字符串只把含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,前导零会被忽略
  - 如果字符串中包含有效的浮点格式,则将其转换为相应的浮点数值,前导零会被忽略
  - 如果字符串是空的,则将其转换为 0
  - 如果字符串中包含除以上格式之外的字符,则将其转换为 NaN
- 如果是数值,传啥值就返回啥值
- 如果是对象,则调用对象的 valueOf() 方法,然后依照前面的规则转换返回的值;如果转换的结果是 NaN,则调用对象的 toString() 方法,然后再次按照前面的规则转换返回的字符串值

### Canvas 和 SVG

> Canvas 和 SVG 是 HTML5 中主要的 2D 图形技术，前者提供画布标签和绘制 API，后者是一整套独立的矢量图形语言，成为 W3C 标准已经有十多年(2003.1至今)，总的来说，Canvas 技术较新，从很小众发展到广泛接受，注重栅格图像处理，SVG 则历史悠久，很早就成为国际标准，复杂，发展缓慢（Adobe SVG Viewer近十年没有大的更新）

#### 适用场景

- Canvas 提供的功能更原始,适合像素处理,动态渲染和大数据量绘制
- SVG 功能更完善,适合静态图片展示,高保真文档查看和打印的应用场景

|  | Canvas | SVG |
| --- | --- | --- |
| 历史 | 较新,由 Apple 私有的技术发展而来 | 历史悠久,2003年成为 W3C 标准 |
| 功能 | 功能简单,2D 绘图 API | 功能丰富,各种图形、滤镜、动画等 |
| 特点 | 像素，只能脚本驱动 | 矢量，XML、CSS，元素操作 |
| 支持 | 主流浏览器，IE9+ | 主流浏览器，IE9+,其他 SVG 阅读器 |
| 操作对象 | 基于像素(动态点阵图) | 基于图形元素 |
| 元素 | 单个 HTML 元素 | 多种图形元素(Rect, Path, Line ...) |
| 驱动 | 只能脚本驱动 | 支持脚本和 CSS |
| 事件交互 | 用户交互到像素点(x, y) | 用户交互到图形元素(rect, path) |
| 性能 | 适合小面积,大数量应用场景 | 适合大面积,小数量应用场景 |

### BFC(块级格式化上下文)

- BFC 就是页面上的一个隔离的独立容器,容器里面的子元素不会影响到外面的元素;反之也如此.包括浮动和外边距合并等等
- display 属性为 block, list-item, table 的元素,会产生 BFC
- 给这些元素添加如下属性就可以触发 BFC:
  - float 属性不为 none
  - position 为 absolute 或 fixed
  - display 为 inline-block, table-cell, table-caption, flex, inline-flex
  - overflow 不为 visible

#### BFC 布局规则特性

- 在 BFC 中,盒子从顶端开始垂直地一个接一个地排列
- 盒子垂直方向的距离由 margin 决定,属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠
- 在 BFC 中,每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘
  - BFC 的区域不会与浮动盒子产生交集,而是紧贴浮动边缘
  - 计算 BFC 的高度时,自然也会检测浮动或者定位的盒子高度
- 它是一个独立的渲染区域,只有 Block-level box 参与,它规定了内部 Block-level Box 如何布局,并且与这个区域外部毫不相干

#### BFC 的主要用途

- 清除元素内部浮动
  - 只要把父元素设为 BFC 就可以清除元素的浮动,最常见的用法就是在父元素上设置 overflow:hidden 样式,对于 IE6 加上 zoom:1 就可以了
- 解决外边距合并问题
  - 盒子垂直方向的距离由 margin 决定;属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠,那么创建不属于同一个 BFC,就不会发生 margin 重叠了
- 制作右侧自适应的盒子问题
  - 普通流体元素 BFC 后,为了和浮动元素不产生任何交集,顺着浮动边缘形成自己的封闭上下文

### display 和 visibility 之间的区别

#### 空间占据

- display:none 是彻底消失,不在文档中占位,浏览器也不会解析该元素(回流+重绘)
- visibility:hidden 是视觉上消失了,可以理解为透明度变为0的效果,在文档流中占位,浏览器会解析该元素(重绘)
- 使用 visibility:hidden 比 display:none 性能上要好,display:none 切换显示时,页面产生回流(当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等,页面重新构建,此时就是回流;所有页面第一次加载时需要产生一次回流),而 visibility 切换是否显示时则不会引起回流

#### 子元素继承

- display:none 不会被子元素继承,但是父元素都不在了,子元素自然也就不会显示了
- visibility:hidden 会被子元素继承,可以通过设置子元素 visibility:visible 使子元素显示出来
- opacity:0 也会被子元素继承,但是不能通过设置元素 opacity:0 使其重新显示

#### 事件绑定

- display:none 的元素都已经不再页面存在了,因此肯定也无法触发它上面的绑定的事件
- visibility:hidden 元素上绑定的事件也无法触发
- opacity:0 元素上面绑定的事件是可以触发的

#### 过渡动画

- transition 对于 display 是无效的
- transition 对于 visibility 是无效的
- transition 对于 opacity 是有效的