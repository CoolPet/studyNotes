## 面试真题 + 解析

```

  var str1 = new RegExp("e")
  document.write(str1.exec("hello"))
  以上代码输出结果为 (e)

  解析:
    exec()方法用于检索字符串中的正则表达式的匹配.
    返回值:返回一个数组,其中存放匹配的结果;如果没有找到匹配值,则返回 null
    "e".exec("hello") 中, "e" 是正则表达式, "hello" 是检索的字符串,因为 "hello" 字符串中可以匹配到 "e",所以返回结果为 e


```

```

  js 原生属性中,可以使用 element.parentNode 获取父对象.

```

```

  var A = {n: 4399}
  var B = function(){
    this.n = 9999
  }
  var C = function(){
    var n = 8888
  }
  B.prototype = A
  C.prototype = A
  var b = new B()
  var c = new C()
  A.n++
  console.log(b.n)
  console.log(c.n)
  以上代码,在浏览器中执行的结果是 (9999 4400)

  解析:
    1.首先改写 B 和 C 的原型,使它们的原型对象都指向 A,因此,B 和 C 的原型都拥有属性 n:4399
    2.通过 new 创建 B 和 C 的实例,用这个方式调用构造函数需要四步:
      a> 创建一个新的实例对象 a 和 b
      b> 将构造函数的作用域赋值给新对象(this 指向新对象 b, c);此时 B 中的 this 指向实例对象 b,即 b.n=9999
      c> 执行构造函数中的代码;给实例添加属性,此时执行 b.n=9999,为 b 添加实例属性;执行 var n=8888,对实例 c 没有影响
      d> 返回新对象;返回实例对象 b,拥有实例属性 n=9999,通过原型链,具有原型属性 n=4399;返回实例对象 c,只有原型属性 n=4399
    3.然后改写原型的属性 A.n,因为原型上的属性是公用的,所以 b 和 c 中原型上的 n 属性都为 4400,吧 还有实例属性 n=9999.由于查找属性的时候现在实例上找,再去原型中找,只要找到了就不往后面找.于是 b.n=9999(在实例中找到),c.n=4400(在原型中找到)

```

```

  x={x: 1}
  y={y: 1}
  z=1
  n="1"
  只有 z==n 的结果为 true

  解析:
    x 和 y是不同的对象，地址不同，z 和 n值同，类型不同

```

```

  页面有一个按钮 button 标签, id 为 button1,通过原生 js 禁用.
  document.getElementById(“button1”).setAttribute(“disabled”,”true”)
  document.getElementById(“button1”).disabled=true;

  解析:
    setAttribute() 方法添加指定的属性,并未其赋指定的值;如果这个指定的属性已存在,则仅设置/更改值.
    readonly 属性规定输入字段为只读,只读字段是不可修改的,但是仍然可以使用 tab 键切换到该字段,还可以选中或拷贝其文本.readonly 属性可以防止用户对值进行修改.该属性只针对 input 和 textarea 有效.
    disabled 属性用于指明按钮禁用.

```

```

  js 数组的方法中,concat() 不能改变自身数组

  解析:
    concat() 连接数组但是不改变原数组
    splice() 删除数据会改变数组
    sort() 排序会改变数组
    pop() 出栈返回最后一个最后一个元素，改变数组

```

```

  在 jquery 中想要找到所有元素的同辈元素,可以用 siblings([expr]) 进行实现

  解析:
    jquery 中的方法:
      siblings() 方法返回被选元素的所有同胞元素。
      next() 方法返回被选元素的下一个同胞元素。
      find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。

```

```

  2.toString() => Uncaught SyntaxError: Invalid or unexpected token     解析:数字后面.会被解析为小数点,变为 (2.)toString 就会报错
  2..toString() => 2    解析:因为连续的两个小数点不符合number的格式规则，第二个小数点才会被解析为调用方法
  2 .toString() => 2    解析:因为空格,所以小数点会被解析为调用方法
  (2).toString() => 2   解析:正常调用

```

```

  ul:无序列表
  dl:定义列表
  ol:有序列表
  li:定义列表项目

```

```

  css 中 clear 的作用是指明该元素周围不可出现浮动元素
  
  解析:
    清除浮动方法:
      1.给父级元素添加 class="clearflex"
      2.在 css 中给父级添加属性: overflow:hidden
      3.伪元素清除法
      4.建立空的 div,命名 clear,在 css 中添加 clear:both
    clear 属性(这个规则只能影响使用清除的元素本身,不能影响其他元素)
      1.left:在左侧不允许浮动元素
      2.right:在右侧不允许浮动元素
      3.both:在左右两侧均不允许浮动元素
      4.none:默认值,允许浮动元素出现在两侧
      5.inherit:规定应该从父元素继承 clear 属性的值

```

```

  html 注释为 <!-- -->
  css 注释为 /* */
  js 注释为:
    1> 单行注释 //
    2> 多行注释 /* */

```

```

  <head>
    <style>
      #bg{
        background-image:url("/img/bg.png")
      }
      #test{
        background-image:url("/img/test.png")
      }
    </style>
  </head>
  <body>
    <div id="test"></div>
    <img src="/img/thumbnail.png">
    <img src="/img/arrow.png" style="visibility: hidden">
  </body>
  基于以上 html 结构,浏览器共会发送 3 个图片请求

  解析:
    css 控制前端图片 http 请求的各种情况:
      1. 隐藏图片
        <img src="haorooms.jpg" style="display: none" />
        结论:只有 Opera 不产生请求
        注意:使用 visibility:hidden 隐藏图片时,在 Opera 下也会产生请求
      2. 重复图片
        <img src="haorooms.jpg" />  
        <img src="haorooms.jpg" />  
        结论:所有浏览器都只产生一次请求
      3.重复背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg) 
          }   
          .test2 { 
            background: url(haorooms.jpg) 
          }   
        </style>   
        <div class="test1">test1</div>   
        <div class="test2">test2</div>  
        结论:所有浏览器都只产生一次请求
      4.不存在的元素的背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg) 
          }   
          .test2 { 
            background: url(http2.jpg) 
          } /* 页面中没有class为test2的元素 */  
        </style>   
        <div class="test1">test1</div>  
        结论:背景仅在应用的元素在页面中存在时,才会产生请求.这对 css 框架来说,很有意义
      5.隐藏元素的背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg); 
            display: none; 
          }   
          .test2 { 
            background: url(http2.jpg); 
            visibility: hidden; 
          }   
        </style>   
        <div class="test1">test1</div>  
        结论:Opera 和 Firefox对于用 display: none 隐藏的元素背景，不会产生 HTTP 请求。仅当这些元素非 display: none 时，才会请求背景图片。
      6.多重背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg); 
          }   
          .test1 { 
            background: url(http2.jpg); 
          }   
        </style>   
        <div class="test1">test1</div>  
        上面这段代码的 http 请求，只会请求 http2.jpg 这一张图片，原因是 test1 的 class 把上面的给覆盖掉了，所有只请求后面的一张图片
        如果使用 css3 多张背景图片:
        <style type="text/css">   
          .test1 { 
            background-image:url("haorooms.jpg"),url("http2.jpg"); 
          }   
        </style>   
        <div class="test1">test1</div>  
        webkit引擎浏览器对背景图都请求，是因为支持CSS3中的多背景图。
      7.hover 的背景加载
        <style type="text/css">   
          a.test1 { 
            background: url(haorooms.jpg); 
          }   
          a.test1:hover { 
            background: url(http2.jpg); 
          }   
        </style>   
        <a href="#" class="test1">test1</a>
        结论:触发 hover 时,才会请求 hover 状态下的背景;不触发的话,只请求默认的背景图片
      8.JS 里 innerHTML 中的图片
        <script type="text/javascript">   
          var el = document.createElement('div');   
          el.innerHTML = '<img src="haorooms.jpg" />';   
          //document.body.appendChild(el);   
        </script> 
        结论:只有 Opera 不会马上请求图片
        注意:当添加到 DOM 树上时,Opera 才会发送请求
      9.图片预加载
        js 方法:
          <script type="text/javascript">   
            new Image().src = 'haorooms.jpg';   
            new Image().src = 'http2.jpg';   
          </script> 
        无 js 支持的环境下,可以采用隐藏元素来预加载:
          <img src="haoroomscom.jpg" style="visibility: hidden; height: 0; width: 0" /> 
    总结:
      1.对于隐藏图片和隐藏元素的背景,Opera 不会产生请求
      2.对于隐藏元素的背景,Firefox 也不会产生请求
      3.对于尚未插入 DOM 树的 img 元素,Opera 不会产生请求
      4.基于 webkit 引擎的 Safari 和 Chrome 支持多背景图
      5.其他情况,所有主流浏览器保持一致
      
```

```

  <form name="a">
    <select name="a" size="1" id="obj">
      <option value="a">1</option>
      <option value="b">2</option>
      <option value="c">3</option>
    </select>
  </form>
  基于以上 html 结构,可以使用 obj.options[obj.selectedIndex].text 获取表单 select 域的选择部分的文本,使用 obj.options[obj.selectIndex].value 或 obj.value 获取表单 select 域的选择部分 value

  解析:
    window.onload = function(){
      // 首先获得下拉框的节点对象
      var obj = document.getElementById("obj")
      // 获得当前选中的值
      var value = obj.value
      // 获得该下拉框所有的 option 的节点对象
      var options = obj.options   // 注意:得到的 options 是一个对象数组
      // 获得某个 option 的 value 值,比如获取第一个 option 的 value
      var value1 = options[0].value
      // 获得某个 option 的文本内容,比如获取第一个 option 的文本
      var text1 = options[0].text
      // 获得当前选中的 option 的索引
      var index = obj.selectedIndex
      // 获得当前选中的 option 的文本内容
      var selectedText = options[index].text
    }

```

```

  Number() => 0
  Number(0) => 0
  Number("") => 0
  Number("0") => 0
  Number(false) => 0
  Number(null) => 0
  Number([]) => 0
  Number([0]) => 0
  Number(undefined) => NaN
  parseInt("")  => NaN
  parseInt(null)  => NaN
  parseInt(undefined)  => NaN
  null==0 => false
  undefined==0 => false

```

```

  Canvas 对象支持所有的 JavaScript 的鼠标事件,但绘制在其中的图形并不作为其子元素存在,所以需要通过获取 Canvas 对象上的鼠标坐标来绑定事件.因此,并不能直接给 Canvas 里面的图形绑定事件
  Canvas 和 SVG 都可以使用 JavaScript 来进行绘制
  WebGL(Web 图形库)是一种 JavaScript API,用于在任何兼容的 Web 浏览器中呈现交互式 3D 和 2D 图形,而无需使用插件;WebGL 通过引入一个与 OpenGL ES 2.0 紧密相符合的 API,可以在 HTML5 的 canvas 元素中使用
  SVG 功能更完善,适合静态图片展示,高保真文档查看和打印的应用场景;Canvas 提供的功能更原始,适合像素处理,动态渲染和大数据量绘制

```

```

  (function() {
    var a = b = 5;
  })();   
  console.log(b);
  console.log(a);
  上面输出的结果: 5, Uncaught ReferenceError: a is not defined

  解析:
    a> 使用 var 操作符,定义的变量将成为该作用域中的局部变量
    b> 省略 var 操作符,会创建一个全局变量，但在局部作用域中定义的全局变量很难维护，也会由于相应变量不会马上就有定义而导致不必要的混乱，给未经声明的变量赋值在严格模式下会导致抛出 Reference 错误，所以不推荐使用。
    c> 赋值运算是把左边的值给右边，所以这个连续的赋值运算符表达式，是从右往左
    综上所述,a 为局部变量,b 为全局变量,在函数运行结束后,a 变量即被销毁.

```

```

  <html>
    <body>
      <div id="ele" class="div">
        <span id="s1" class="sp" lang="zh-cn">
        </span>
      </div>
    </body>
    <script type="text/javascript">  
      function exct() {
        var oEle = document.getElementById("ele");
        var child = oEle.children;
        console.log("ele.children的执行结果是:");
        for(i = 0; i < child.length; i++){
          console.log(child[i].tagName);
        }  
        child = oEle.childNodes;
        console.log("ele.childNodes的执行结果是:");
        for(i = 0; i < child.length; i++){
          console.log(child[i].tagName);
        }
      }  
    exct (); 
    </script>
  </html>
  上面代码的运行结果是:
    ele.children的执行结果是:
    SPAN
    ele.childNodes的执行结果是:
    undefined
    SPAN
    undefined

  解析:
    1> children 属性返回子元素的元素节点
    2> childNodes 属性返回所有的子节点,包括文本节点、注释节点、元素节点
    3> tagName 属性用来获取元素的标签名
    由此可以知道:
      oEle.children 获取的是子元素的元素节点 <span id="s1" class="sp" lang="zh-cn"></span>,在通过 tagName 获取元素的标签名,所以得到 SPAN
      oEle.childNodes 获取的是所有子节点,得到了一个 span 元素节点,还有两个文本节点:空格和换行,因此得到了三个子节点,而 tagName 用来获取的是元素的标签名,文本节点是没有标签名的,所以就为 undefined

```

```

  一个 HTML 文档内含有阿拉伯文,则应该使用 utf-8 编码

  解析:
    1> utf-8(8-bit Unicode Transformation Format, 万国码):用在网页上可以同一页面显示中文简体繁体及其它语言(如英文,日文,韩文)
    2> GBK 是汉字编码,是双字节码,可以表示繁体字和简体字
    3> ISO8859-2 字符集,也称为 Latin-2,收集了东欧字符
    4> Unicode 是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案;目前的 Unicode 字符分为17组编排,0x0000 至 0x10FFFF,每组称为平面(Plane),而每平面拥有65536个码位,共1114112个;然而目前只用了少数平面,UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案

```

```

  var datas = [10, 20, 30]
  datas.unshift(40, 50)
  datas.pop()
  datas.push(60, 70)
  datas.shift()
  console.log(datas.toString())
  上面代码执行的结果是: 50, 10, 20, 60, 70

  解析:
    var datas = [10, 20, 30]
    datas.unshift(40, 50)   // 首部添加(40, 50),得到 [40, 50, 10, 20, 30]
    datas.pop()   // 尾部删除,得到 [40, 50, 10, 20]
    datas.push(60, 70)    // 尾部添加,得到 [40, 50, 10, 20, 60, 70]
    datas.shift()   // 首部删除,得到 [50, 10, 20, 60, 70]
    console.log(datas.toString())
    a> shift() 删除数组的第一个元素,返回被删除的元素, arr.shift()
    b> unshift() 向数组开头添加一个或多个元素,返回新的长度, arr.unshift(e1, e2, ...)
    c> pop() 删除数组最后一个元素,返回被删除的元素, arr.pop()
    d> push() 向数组尾部添加一个或多个元素,返回新的长度, arr.push(e1, e2, ...)

```

```

  var foo = function(x, y){
    return x-y
  }
  function foo(x, y){
    return x+y
  }
  var num = foo(1, 2)
  以上代码运行后, num 的值是 -1

  解析:
    var foo = function(x, y){
      return x-y
    }
    function foo(x, y){
      return x+y
    }
    var num = foo(1, 2)
    会被 JavaScript 编译器解析处理为:
    // 1.变量提升
    var foo
    var num
    // 2.函数声明提升
    function foo(x, y){
      return x+y
    }
    // 3.函数表达式不会被提升
    foo = function(x, y){
      return x-y
    }
    num = foo(1, 2)
    规则:
      1> 变量声明,函数声明都会被提升到作用域顶处
      2> 当出现相同名称时,优先级为:变量声明(1) => 函数声明(2) => 变量赋值(3)
    所以 num 计算事使用的是变量赋值(3),num 的值是 -1

```

```

  在一个表单中,如果想要给输入框添加一个输入验证,可以使用 change() 事件实现.

  解析:
    a> keypress():按键事件,抬起按键时验证
    b> change():属性值改变事件,输入完后验证
    c> blur():失去焦点事件,输入框失去焦点验证
    d> focus():聚焦事件,再次进入输入框验证

```

```

  W3C 标准定义的阻止事件向父容器传递使用的是 e.stopPropagation()

  解析:
    1> DOM 中的事件对象
      a> preventDefault():取消事件默认行为
      b> stopImmediatePropagation():取消事件冒泡同时阻止当前节点上的事件处理程序被调用(会影响当前的事件侦听器)
      c> stopPropagation():取消事件冒泡对当前节点无影响(不影响当前时间侦听器)
    2> IE 中的事件对象
      a> cancelBubble():取消事件冒泡
      b> returnValue():取消事件默认行为

```

```

  将某一对象的背景色透明度改为 80% 的声明是 filter: alpha(opacity=80)

```

```

  calc()使用通用的数学运算规则,但是也提供更智能的功能:
    1> 使用 "+", "-", "*", "/" 四则运算
    2> 可以使用百分比, px, em, rem 等单位
    3> 可以混合使用各种单位进行计算
    4> 表达式中有 "+" 和 "-" 时,其前后必须要有空格
    5> 表达式中有 "*" 和 "/" 时,其前后可以没有空格
  在 CSS3 中扩展了颜色值包含 currentColor 关键字,并用于所有接受颜色的属性上.
  currentColor 是 color 属性的值: currentColor 关键字的使用值是 color 属性值的计算值.如果 currentColor 关键字被应用在 color 属性自身,则相当于是 color: inherit

```

```

  script 写在头部会导致页面加载堵塞等情况

```

```

  JavaScript 定义 var a="40",var b=7,则执行 a%b=5

  解析:
    JavaScript 是弱类型语言,但是明显字符串 "40" 不能用于 % 运算符,所以会根据后面的类型进行转化,结果为5.
    在进行算术运算中,只有 "+" 号会将数字隐式转换为字符串,其他运算符号是字符串隐式转换成数字

```

```

  var a = 4399 < 0 || typeof("4399+")
  console.log(a)
  以上 javascript 代码,在浏览器运行的结果是 string

  解析:
    运算符 "||":
      1> 只要 "||" 前面为 false,不管 "||" 后面是 true 还是 false,都返回 "||" 后面的值
      2> 只要 "||" 前面为 true,不管 "||" 后面是 true 还是 false,都返回 "||" 前面的值
    所以 4399 < 0 为false,所以返回的是后面的值为 string
    另外:在 js 逻辑运算中, 0, "", null, false, undefined, NaN 都会判断为 false,其他都为 true

```

```

  JavaScript RegExp 对象有 3 个方法:
    1> test():用来检测一个字符串是否匹配某个正则表达式,如果匹配成功,返回 true,否则返回 false
    2> exrc():用来检索字符串中与正则表达式匹配的值;exec() 返回一个数组,其中存放匹配的结果,如果未找到匹配的值,则返回 null
    3> compile():可以在脚本执行过程中编译正则表达式,也可以改变已有表达式(但是已从 Web 标准中删除)
    注:match()方法是支持正则表达式的 String 对象的方法

```

```

  函数声明:
    function sum(a, b){
      return a+b
    }
  函数表达式:
    var sum = function(a, b){
      return a+b
    }
  Function 构造函数(从技术角度讲,这是一个函数表达式):
    var sum = new Function("a", "b", "return a+b")    // 不推荐使用,影响函数解析性能

```

```

  使用 CSS 来格式化网页,共有三种方式:在 HEAD 中引用,作为标记来引用,作为文件来引用

  解析:
    样式表允许以多种方式规定样式信息,样式可以规定在单个的 HTML 元素中,在 HTML 页的头元素中,或在一个外部的 CSS 文件中;甚至可以在同一个 HTML 文档内部引用多个外部样式表:
      a> 外链样式,如:<link></link>
      b> 行内样式,如:<div style=""></div>
      c> 内联样式,如:<style></style>

```

```

  img 标签的属性:
    a> title,描述图片信息
    b> alt,规定图片的替代文本
    c> crossorigin,设置图像的跨域属性
    d> ismap,将图片规定为服务器端图像映射
    e> usemap,将图片定义为客户端图像映射

```

```

  white-space 属性(设置如何处理元素的空白):
    a> normal:默认,空白会被浏览器忽略
    b> pre:空白会被浏览器保留,其行为方式类似于 HTML 中的 pre 标签
    c> nowrap:文本不会换行,文本会在同一行上继续,直到遇到 br 标签为止
    d> pre-wrap:保留空白符序列，但是正常地进行换行
    e> pre-line:合并空白符序列，但是保留换行符
    f> inherit:规定应该从父元素继承 white-space 属性的值
  text-overflow 属性(规定当文本溢出包含元素时发生的事):
    a> clip:修剪文本
    b> elipsis:显示省略符号来代表修剪的文本
    c> string:使用给定的字符串来代表被修剪的文本
  overflow 属性(规定当内容溢出元素框时发生的事情):
    a> visible:默认值。内容不会被修剪，会呈现在元素框之外
    b> hidden:内容会被修剪，并且其余内容是不可见的
    c> scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容
    d> auto:如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容
    e> inherit:规定应该从父元素继承 overflow 属性的值

```

```

  <form class="file" name="upload">
    <input id="file" name="file" class="file" />
  </form>
  以上代码可以使用 document.getElementsByClassName("file")[1] 获取 input 节点

```

```

  当在手机中需要保存移动手机号码,通过正则表达式判断: /^1[0-9]{10}$/

  解析:
    a> ^ 匹配输入字符串的开始位置,这里也就是要求 1 开始
    b> [0-9] 匹配 0~9 之间的数字
    c> {10} 重复10次
    d> $ 匹配输入字符串的结尾位置

```

```

  <script>
    var m = 1, j = k = 0
    function add(n){
      return n = n+1
    }
    y = add(n)
    function add(n){
      return n = n+3
    }
    z = add(m)
    console.log(y, z)
  </script>
  上面代码的运行结果为 4, 4

  解析:
    js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。在js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。结合这道题来说，由于函数声明提升，所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数，所以两次调用add()返回的值是相同的。也就是y,z都为4.

```

```

  在 HTML5 中,可以使用 getCurrentPosition() 获得用户的当前位置

  解析:
    a> getCurrentPositon() 获取用户当前位置放入一个值中保存,使用 watchPosition() 函数注册监听器,在设备地理位置发生改变时自动被调用
    b> getLocation() 地图定位

```

```

  js 里的 function 能访问它们的参数,局部变量或函数,全局变量,外部函数的变量或函数

```

```

  var a = 10
  function a(){  }
  console.log(typeof a)
  上面代码运行后,控制台的输出是 number

  解析:
    函数提升优先级高于变量提升,所以代码等价于:
      function a(){  }
      var a
      a = 10
      console.log(typeof a)

```

```

  for(var i=0; i<5; i++){
    requestAnimationFrame(() => {
      console.log(i)
    })
  }
  上面代码运行后, console 输出的信息是 5 5 5 5 5(5 个 5)

  解析:
    requestAnimationFrame 并非同步执行的,所以 for 循环中的 requestAnimationFrame 会在循环退出的时候才执行其中的回调,注意循环退出的时候 i 值为 5

```

```

  for(let i=0; i<5; i++){
    requestAnimationFrame(() => {
      console.log(i)
    })
  }
  上面代码运行后, console 输出的信息是 0 1 2 3 4

```

```

  let array = [, 1, , 2, , 3]
  array = array.map((i) => {
    ++1
  })
  console.log(array)
  上面代码运行后,控制台输出的结果是 [, 2, , 3, , 4]

  解析:
    map() 会跳过空位,但是会保留这个值

```

```

  ajax 不是新的编程语言,而是一门提供网页局部刷新的技术
  ajax 最大的优点是在不重新加载整个页面的情况下,与服务器交换数据并更新部分网页内容
  ajax 技术核心是 XMLHttpRequest 对象
  ajax 技术的工作原理:
    a> 创建 ajax 对象: var xhr = new XMLHttpRequest()
    b> xhr 发送请求: xhr.open("get", "test.html", "true")
                    xhr.send()
    c> xhr 获取响应:
        xhr.onreadystatechange = function(){
          if(xhr.readystate == 4){    // 请求的状态码
            /*
              0: 请求还没有建立(open 执行前)
              1: 请求建立了还没发送(执行了 open)
              2: 请求正式发送(执行了 send)
              3: 请求已受理,有部分数据可以用,但还没处理完成
              4: 请求完全处理完成
            */
            alert(xhr.responseText)   // 返回的数据
          }
        }

```

```

  var foo = "10" + 3 - "1"
  console.log(foo)
  以上的代码运行后,控制器输出的结果是 102

  解析:
    a> "+" 的含义:
          1. 如果操作数里有一个是字符串,其他的值都将被转换成字符串
          2. 其他情况下,操作数转换成数字执行加法运算
    b> "-"的含义:只是自然的做减法,不会转换成字符串,而转换为数字

```

```

  JS 中值的类型分为原始值类型和对象类型:
    a> 原始值类型: number, string, boolean, null 和 undefined
    b> 对象类型: object
    注:原始值类型不是对象
  "hello" 和 new String("hello")的区别:
    a> "hello" 是字符串字面值,属于原始类型
    b> new String("hello") 是对象
    c> 使用 typeof 运算符返回的值也是不一样的:
      typeof "hello"    // string
      typeof new String("hello")    // object
      new String("hello") instanceof String   // true, String 对象实例化判断是否是 string 需要是用 instanceof

```

```

  var d = new Date("2018-05-09")
  将 d 设置为 6 月份可以使用 d.setMonth(5) 和 d.setDate(40)

  解析:
    d.setDate(n):
      n 表示一个月中的一天的一个数值
      0 为上一个月的最后一天
      -1 为上一个月最后一天之前的一天
    d.setMonth(month, day):
      month:必填项,表示月份的数值,该值介于 0(一月) ~ 11(十二月) 之间
      day:选填项,表示月的某一天,该值介于 1 ~ 31 之间

```

```

  HTML5 新增的表单元素: autocomplete, autofocus, form, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, min, multiple, pattern, placeholder, required, step, width

```

```

  typeof null   // => object
  typeof undefined   // => undefined
  typeof []   // => object
  typeof 5   // => number

```

```

  label 元素:
    a> label 元素可以使用 for 属性关联表单控件,也可以将表单控件放置在它的内部  
    b> 当使用 for 属性来关联 label 元素和表单控件时, label 元素的 for 属性要和表单控件的 ID 一致

```

```

  readystatechange, DOMContentLoaded 两个事件会在页面加载完成(onload)之前触发.

  解析:
    a> readystatechange: document 有 readyState 属性来描述 document 的 loading 状态, readyState 的改变会触发 readystatechange 事件:
      1> loading 文档仍然在加载
      2> interactive 文档结束加载并且被解析,但是像图片,样式, frame 之类的子资源仍在加载
      3> complete 文档和子资源已经结束加载,该状态表明将要触发 load 事件
    因此 readystatechange 在 onload 之前触发
    b> onpageshow:
      1> onpageshow 事件在用户浏览网页时触发
      2> onpageshow 事件类似于 onload 事件, onload 事件在页面第一次加载时触发, onpageshow 事件在每次加载页面时触发,即 onload 事件在页面从浏览器缓存中读取时不触发
    c> beforeunload:当浏览器窗口,文档或其资源将要卸载时,会触发 beforeunload 事件;这个文档是依然可见的,并且这个事件在这一刻是可以取消的;如果处理函数为Event对象的returnValue属性赋值非空字符串,浏览器会弹出一个对话框,来询问用户是否确定要离开当前页面(如下示例);有些浏览器会将返回的字符串展示在弹框里,但有些其他浏览器只展示它们自定义的信息,没有赋值时,该事件不做任何响应
    d> DOMContentLoaded:当初始的 HTML 文档被完全加载和解析完成之后,DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载;另一个不同的事件 load 应该仅用于检测一个完全加载的页面。因此DOMContentLoaded是HTML完全加载和解析完成之后发生的，发生时间点要早于load;在使用 DOMContentLoaded 更加合适的情况下使用 load 是一个令人难以置信的流行错误,所以需要谨慎;
    注:DOMContentLoaded 事件必须等待其所属 script 之前的样式表加载解析完成才会触发

```

```

  css 选择器:
    a> 标签选择器:即页面中的各个标签名的 css 样式
    b> 类选择器:即定义的每个标签的 class 中的 css 样式
    c> id 选择器:即页面中的标签的 id
    d> 后代选择器(类选择器的后代选择器):即多个选择器以逗号的格式分隔,命名找到准确的标签
    e> 群组选择器:即具有相同样式的标签分组显示
  css 选择器的优先级:
    内联样式 > id 选择器 > 类选择器 > 标签选择器

```

```

  JavaScript 使用 window.open("http://www.w3school.com.cn","window2") 可以打开名为 "window2" 的新窗口

  解析:
    open() 方法可以查找一个已经存在或者新建的浏览器窗口。
      语法: window.open([url], [窗口名称], [参数字符串])
      参数说明:
        a> url:选填项,在窗口中要显示网页的网址或路径;如果省略这个参数,或者它的值是空字符串,name窗口就不显示任何文档
        b> 窗口名称:选填项,被打开窗口的名称
            1> 该名称由字母,数字和下划线字符组成
            2> "_top", "_blank", "_self" 具有特殊意义:
                1. _blank:在新窗口显示目标网页
                2. _self:在当前窗口显示目标网页
                3. _top:框架网页中在上部窗口中显示目标网页
            3> 相同 name 的窗口只能创建一个,想要创建多个窗口则 name 不能相同
            4> name 不能有空格
        c> 参数字符串:选填项,设置窗口参数,各参数用逗号隔开

```

```

  在 JavaScript 中,调用对象属性可以使用 obj["arr"], obj["a" + "r" + "r"], obj.arr

```

```

  if(! "a" in window){
    var a = 1
  }
  console.log(a)
  运行上面的代码,控制台输出结果为 undefined

  解析:
    if(! "a" in window){    // 判断全局对象 window 中是否有变量 a,由于变量的提前声明,所以 window 中就存在 a 这个变量,所以不进入
      var a = 1
    }
    console.log(a)    // 只有 window 中存在 a 这个变量,但是没有进行赋值,为 undefined

```

```

  web 表单登录中用到的图像验证码实现方式:服务器端生成验证码后一方面通过图片将验证码返回给客户端,同时在服务端保存文本的验证码,由服务端验证输入内容是否正确

```

```

  for(var i=0; i<5; ++i){
    setTimeout(function(){
      console.log(i+ " ")
    }, 100)
  }
  以上代码在控制台输出为 5 5 5 5 5

  解析:
    setTimeout() 是异步函数,只有等到主线上的任务都执行完,才会执行异步的,此时 i 已经变为 5;而且循环 5 次,异步队列中存放了五次 setTimeout(),并且按照队列的顺序依次执行,其共同访问的是同一个变量,所以结果都是 5
    使用闭包或者将全局变量变为块变量可以得到不一样的结果:
      a> 闭包
        for(var i=0;i<5;++i){
          (function(i){
            setTimeout(function(){alert(i+ ' ');},100);
          })(i)
        }
      b> 全局变量变为块变量
        for(let i=0; i<5; ++i){
          setTimeout(function(){
            console.log(i+ " ")
          }, 100)
        }

```

```

  var a = [1, 4, 5, 2, 9]
  求 a 的最大值:
  Math.max.apply(null, a)

  解析:
    Math.max() 即为求最大值的方法
    也可以写成:
      Math.max(...a)
      Math.max.call(...a)

```

```

  let x = 10
  let foo = () =>{
    console.log(x)
    let x = 20
    x++
  }
  foo()
  运行以上代码,控制台会抛出 ReferenceError
  
  解析:
    let 不同于 var:
      a> var 变量作用域为 global 或 function scope, let 可以在更小的范围内如 block scope(如 {} 括号内, for 循环内)
      b> var 变量声明后会被隐式赋值 undefined,而 let 变量声明后不会被初始化,知道显式的赋值表达式才会被初始化

```

```

  JavaScript 中数字的部分知识:
    a> JavaScript 中,由于其变量内容不同,变量被分为基本数据类型变量和引用数据类型变量;基本数据类型变量用 8 字节内存,存储基本数据类型(数字,布尔值, null 和未定义)的值,引用类型变量则只保存对对象,数组和函数等引用类型的值的引用(即内存地址)
    b> JS 中的数字是不分类型的,也就是没有 byte/int/float/double 等的差异
    c> JavaScript 内部,所有数字都是以 64 位浮点数形式储存,即使整数也是如此, 8 byte = 64 bit

```

```

  html5 新增规范的有 sessionStorage, localStorage 和 webSocket

```

```

  -moz 代表 firefox 浏览器私有属性
  -ms 代表 IE 浏览器私有属性
  -webkit 代表 chrome, safari 私有属性 IE 使用的是 Trident 内核, Firefox 使用的是 Gecko 内核;目前使用 IE 内核的浏览器还有搜狗,遨游,360等等

```

```

  console.log(1 + "2" + "2")
  console.log(1 + +"2" + "2")
  console.log("A" - "B" + "2")
  console.log("A" - "B" + 2)
  以上代码运行后,控制台输出为 122 32 NaN2 NaN

  解析:
    a> console.log(1 + "2" + "2")
       做加法时要注意双引号,当使用双引号时, JavaScript 认为是字符串,字符串相加等于字符串合并;因此,这里相当于字符串的合并,即为 122
    b> console.log(1 + +"2" + "2")
       第一个 +"2" 中的加号是一元加操作符, +"2" 会变成数值 2,因此 1 + +"2" 相当于 1+2=3,然后和后面的字符串 "2" 相合并,变成了字符串 "32"
    c> console.log("A" - "B" + "2")
       "A" - "B" 的运算中,需要先把 "A" 和 "B" 用 Number 函数转换为数值,其结果为 NaN,在减法操作中,如果有一个是 NaN,则结果是 NaN,因此 "A" - "B" 结果为 NaN,然后和 "2" 进行字符串合并,变成了 NaN2
    d> console.log("A" - "B" + 2)
       "A"-"B" 结果为 NaN,然后和数值 2 进行加法操作,在加法操作中,如果有一个操作数是 NaN,则结果为 NaN

```

```

  与其它 IEEE 754 表示浮点数的编程语言一样, JavaScript 的 number 存在精度问题,比如 0.2+0.4 的结果是 0.6000000000000001,使用  parseFloat((0.2 + 0.4).toFixed(1)) 可以得到 0.6

  解析:
    // parseFloat(),解析一个字符串,并返回一个浮点数
    // toFixed() 把数字转换为字符,结果的小数点后有指定位数的数字,按四舍五入取值
    var num = new Number(15.7857)
    var a = num.toFixed()   // 16,无参数,表示小数点后面位数为 0 位,然后四舍五入
    var b = num.toFixed(1)    // 15.8
    var c = num.toFixed(10)   // 15.7857000000,多出的补 0
    
    // toPrecision() 把数字格式化为指定长度
    var d = num.toPrecision()   // 15.7857,无参数,返回原数字
    var e = num.toPrecision(1)    // 2e+1,参数小于整数部分位数,返回科学计数
    var f = num.toPrecision(3)    // 15.8,也是有四舍五入的
    var g = num.toPrecision(10)   // 15.78570000,长度不够补 0

    // Math.round() 把一个数字舍入为最接近的整数
    var h = Math.round(num)   // 16

    // parseFloat() 解析一个字符串,并返回一个浮点数
    var i = parseFloat(num)   // 15.7857

```

```

  var foo={n:1};
  (function (foo) {
    console.log(foo.n)
    foo.n=3
    var foo={n:2}
    console.log(foo.n)
  })(foo)
  console.log(foo.n)
  以上代码运行后,在控制台输出 1 2 3

  解析:
    JavaScript 的 hoisting 机制:本质只提升声明部分
      a> 变量声明,会被提升在作用域顶端
        var a
      b> 变量定义,声明部分会提升,赋值部分不会被提升
        var b = "test"
      c> 函数定义(函数表示式),其实就是变量定义,只不过恰好被赋值的类型是函数,所以也只提升变量名,不提升函数值
        var c = function(){
          console.log("test")
        }
      d> 函数声明,所以全部被提升,包含函数名和函数体;另外,优先级比变量声明要高,名字相同的变量提升会被忽略
        function d(){
          console.log("test")
        }
      e> 参数是引用参数
        var foo={n:1};
        (function (foo) {
          console.log(foo.n)
          foo.n=3
          var foo={n:2}
          console.log(foo.n)
        })(foo)
        console.log(foo.n)
        结果为: 1 2 3
      f> 参数是传值参数
        var foo=1;  
        (function (foo) {   
            console.log(foo)
            foo=3
            var foo=2
            console.log(foo)
        })(foo)
        console.log(foo)
        结果: 1 2 1

```

```

  Math.round(-2019.5) 等于 -2019

  解析:
    Math.round() 函数返回一个数字四舍五入后最接近的整数:
      a> 参数的小数部分大于 0.5,四舍五入到相邻的绝对值更大的整数
      b> 参数的小数部分小于 0.5,四舍五入到相邻的绝对值更小的整数
      c> 参数的小数部分等于 0.5,四舍五入到相邻的在正无穷(+∞)方向上的整数

```

```

  在 es6 中,下面程序运行结果输出:
    1. for(let i=0; i<12; i++){}
       console.log(i)   // => i is not defined
    2. const a = 12
       a = 13
       console.log(a)   // => Assignment to constant variable
    3. const g = {b: 3}
       console.log(g.b)   // => 3
       g.b = 12
       console.log(g.b)   // => 12
    4. let [head,...tail] = [1, 2, 3, 4]
       console.log(tail)    // => [2, 3, 4]
  
  解析:
    1> let 与 var 不同,let 存在块级作用域,在 for 循环中声明,循环之外销毁,所以 i not defined
    2> const 声明一个常量无法更改,所以 Assignment to constant variable(常变量赋值)
    3> const 声明的是一个常量所以是无法更改的,但是 const 出来的是一个对象的话,它的属性是可以更改的
    4> 第一个值赋给 head,其他的赋值给 tail(解构赋值)

```

```

  var i = 1
  var i = 2
  var add = function(){
    var i = 0
    return function(){
      i++
      console.log(i)
    }
  }()
  add()
  上面代码存在 3 个变量没有被回收

  解析:
    a> 全局变量 i 不会被回收,但 i=1 会被 i=2 覆盖
    b> 全局变量 add 不会被回收
    c> 闭包引用的局部变量 i 不会被回收
    d> 代码回收规则:
      1> 全局变量不会被回收
      2> 局部变量会被回收,也就是函数一旦运行结束后,函数内部的东西都会被销毁
      3> 只要被另外一个作用域引用就不会被回收

```

```

  <input type="date" name="bday"> 和 <input type="datetime-local" name="bdaytime"> 都可以用来绘制日历,样式都可以通过 css 进行修改,日历标签目前只能应用于谷歌浏览器

```

```

  var x = 0
  switch(++x){
    case 0: ++x;
    case 1: ++x;
    case 2: ++x;
  }
  执行上面的代码后, x 的值是 3

  解析:
    switch 中, x 为 1,进入 case 1, 执行 ++x 后, x = 2,因为没有 break,所以又进入 case 2,执行 ++x 后, x = 3
    a> i++ 返回原来的值, ++i 返回加 1 后的值
    b> i++ 不能作为左值,而 ++i 可以

```

```

  定义函数的方法:
    a> 函数声明(其重要特征是函数声明提升,可以把函数声明放在调用它的语句后面)
      function functionName(arg){
        // 函数体
      }
    b> 函数表达式
      var functionName = function(arg){
        // 函数体
      }
  ES6 语法定义方法:
    a> 这个语法定义的是方法(method),因为这种写法只能在 class 里生效,所以这个 function 始终是跟一个 object 有关联的
      functionName(){
        // 函数体
      }

```

```

  a> 获取所有指定类名的元素: getElementsByClassName()
    1> 定义和使用
      getElementsByClassName() 方法返回文档中所有指定类名的元素集合,作为 NodeList 对象
      NodeList 对象代表一个有顺序的节点列表, NodeList 对象可以通过节点列表中的节点索引号来访问列表中的节点(索引号由 0 开始)
    2> 提示:可以使用 NodeList 对象的 length 属性来确定指定类名的元素个数,并循环各个元素来获取需要的元素
  b> 获取所有指定标签名的对象的集合: getElementsByTagName()
    1> 说明
      getElementsByTagName() 方法返回元素的顺序是它们在文档中的顺序
      如果把特殊字符串 "*" 传递给 getElementsByTagName() 方法,它将返回文档中所有元素的列表,元素排列的顺序就是它们在文档中的顺序
  c> 获取指定 id 的第一个对象: getElementById()
    1> 说明
      HTML DOM 定义了多种查找元素的方法,除了 getElementById() 之外,还有 getElementsByClassName() 和 getElementsByTagName(),不过,如果需要查找文档中的一个特定的元素,最好使用 getElementById()
    2> 在操作文档的一个特定的元素时,最后给该元素一个 id 属性,为它指定一个(在文档中)唯一的名称,然后就可以用该 id 查找想要的元素
  d> 获取指定名称的对象:  getElementsByName()
    1> 该方法和 getElementById() 方法相似,但它查询元素的 name 属性,而不是 id 属性
    2> 因为一个文档中的 name 属性可能不唯一(如 HTML 表单中的单选按钮通常具有相同的 name 属性),所以 getElementsByName() 方法返回的是元素的数组,而不是一个元素

```

```
  jQuery 操作方法:
    a> text():设置或返回被选元素的文本内容
    b> :contains():选取包含指定字符串的元素
    c> :input:选取表单元素
    d> attr():设置或返回被选元素的属性值

```

```

  a> append() 方法
    1> 方法作用:向每个匹配的元素内部追加内容
    2> 参数:要追加到目标中的内容
  b> appendTo() 方法
    1> 方法作用:把所有匹配的元素追加到指定的元素集合中
    2> 参数:用于匹配元素的 jQuery 表达式

```

```

  a> Object.keys():
     该方法会返回一个由一个给定对象的自身可枚举属性组成的数组,数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致,如果对象的键/值都不可枚举,那么将返回由键组成的数组
  b> String.prototype.split():
     split() 方法使用指定的分隔符字符串将一个 String 对象分割成字符串数组,将字符串分割为子字符串,确定每个拆分的位置
  c> Array.prototype.join():
     join() 方法将一个数组(或一个类数组对象)的所有元素连接成一个字符串并返回这个字符串,如果数组只有一个项目,那么将返回该项目而不使用分隔符
  d> Promise.all():
     Promise.all() 方法返回一个 Promise 实例,该实例在参数内所有的 Promise 都"完成(resolve)"或参数中不包含 Promise 是回调完成(resolve);如果参数中 Promise 有一个失败(rejected),此实例回调失败(reject),失败原因的是第一个失败 Promise 的结果

```

```

  var str = "stiabsstringapbs"
  var obj = {}
  for (var i = 0; i < str.length; i++) {
    var key = str[i]
    if (!obj[key]) {
      obj[key] = 1
    } else {
      obj[key]++
    }
  }
  var max = -1
  var max_key = ""
  var key
  for (key in obj) {
    if (max < obj[key]) {
      max = obj[key]
      max_key = key
    }
  }
  alert("max:"+max+" max_key:"+max_key)
  上面的代码中:(1)obj 是用来统计字符数量的;(2)max 统计的是一个字符串出现次数最多的字符的次数,而 key 即是这个字符;(3)代码实现的是判断一个字符串中出现次数最多的字符,统计这个次数

  解析:
    var str = "stiabsstringapbs"    // 定义字符串
    var obj = {}    // 定义对象
    for (var i = 0; i < str.length; i++) {    // 遍历字符串
      var key = str[i]    // 存储字符
      if (!obj[key]) {    // 若对象中不存在该 key,初始化为 1
        obj[key] = 1
      } else {    // 若对象中存在该 key,则数值加 1
        obj[key]++
      }
    }
    // 第一个 for 循环结束得到每个字符数量的对象
    // obj = {a: 2, b: 2, g: 1, i: 2, n: 1, p: 1, r: 1, s: 4, t: 2}
    var max = -1    // 初始化最大数量
    var max_key = ""    // 初始化最大字符
    var key
    for (key in obj) {    // 遍历 obj 对象,获得字符最大数量及对应字符
      if (max < obj[key]) {
        max = obj[key]
        max_key = key
      }
    }
    alert("max:"+max+" max_key:"+max_key)

```

```

  var k = 0
  for(var i=0, j=0; i<10, j<6; i++, j++){
    k += i +j
  }
  console.log(k)
  上面的代码运行后,控制台输出的是 30

  解析:
    0+0+1+1+2+2+3+3+4+4+5+5=30

```

```

  var a = [1, 2, 3]
  var b = a.slice()
  b.push(4)
  console.log(a)
  上面代码运行后,控制台输出的是 [1, 2, 3]

  解析:
    slice() 是选取数组的一部分,并返回一个新的数组,不会改变原数组

```

```

  html5 的媒体标签:
    a> audio 用来嵌入音频, video 用来嵌入视频
    b> embed 定义了一个内容,用来嵌入外部应用或者互动程序(插件)
    c> source 对于定义多个数据源
    d> track 标签为媒介规定外部文本轨道,用于规定字幕文件或其它包含文本的文件,当媒介播放时,这些文件是可见的

```

```

  当使用地图进行图形搜索时,可以把一副图片从电脑拖放到地图页面的输入框里,这是运用了 HTML5 的 File API 实现的

  解析:
    文件(File)接口提供有关文件的信息,并允许网页中的 JavaScript 访问其内容;通常情况下, File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自只有拖放操作生成的 DataTransfer 对象,或者来自 HTMLCanvasElement 上的 mozGetAsFile() API

```

```

  var a = "undefined"   // 字符串
  var b = "false"   // 字符串
  var c = ""    // 空字符串
  var d = undefined   // 未定义
  var e = false   // boolean: false
  function assert(aVar){
    if(aVar)
      console.log(true)
    else
      console.log(false)
  }
  assert(a)
  assert(b)
  assert(c)
  assert(d)
  assert(e)
  上面代码运行后,控制台输出的结果: true true false false false

```

```

  typeof Date.now() 的值是: number
  
  解析:
    Date.now() 方法返回自 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的毫秒数,故为 number

```

```

  DOM 树中总共分为如下几种节点格式: Element 类型(元素节点), Text 类型(文本节点), Comment 类型(注释节点), Document 类型(document 节点)
  document 可以说是一种节点格式,但节点树的根节点也叫 document
  所有的 HTML elements(元素节点,其实就是 HTML 标签)都是 element
  comments 属于注释节点
  HTML element 内的 text 内容也就是 文本节点

```

```

  ({} + "b" > {} + "a")的返回值是 true

  解析:
    {} + "b"    => [Object Object]b
    {} + "a"    => [Object Object]a
    a> "+" 连接字符会转换为字符
    b> "+" 优先级高于 ">"
    c> ">" 运算符比较字符串大小时,会把字符串转换为 ASCII 码依次比较,b > a

```

```

  let i = 1 + {
    valueOf(){
      return 9
    }
  }
  console.log(i)    => 10
  // "+" 使得对象发生类型转换,从而调用内部的 valueOf() 方法, 1+9=10

  let i = 0
  new Array(10).forEach(() => {
    i++
  })
  console.log(i)    => 0
  // forEach() 方法在数组元素为空时会跳过执行回调函数,相对于此选项回调函数为执行,所以输出为0

  let i = parseInt('0xA')
  console.log(i)    => 10
  // 十六进制解析

  let i = 5
  function a(i){
    i *= 2
  }
  a(i)
  console.log(i)    => 5
  // a 函数没有返回值

```

```

  可以使用 css3 里 rotateY 实现翻书的效果

  解析:
    a> rotateY:定义沿 Y 轴的 3D 旋转,可实现翻书效果
    b> translateY:沿着 Y 轴移动元素
    c> scaleY:定义 2D 缩放转换时,改变元素的高度;定义 3D 缩放转换时,通过给定一个 Y 轴的值
    d> perspective(n):改变 3D 元素时怎样查看透视图(注:只影响 3D 转换元素)

```

```
  a>
    var name = "World";
    (function(){
      console.log(name)   // world
      console.log(typeof name==="undefined")    // false
      if(typeof name==="undefined"){
        console.log("Goodbye"+name)
      }else{
        console.log("hello"+name)   // hello world
      }
    })()
  
  b>
    var name = "World";
    (function(){
      console.log(name)   // undefined
      console.log(typeof name==="undefined")    // true
      if(typeof name==="undefined"){
        var name = "Jack"
        console.log("Goodbye"+name)   // Goodbye Jack
      }else{
        console.log("hello"+name)
      }
    })()

```

```

  四种 touch 事件:
    a> touchstart:手指放到屏幕上时触发
    b> touchmove:手指在屏幕上滑动时触发
    c> touchend:手指离开屏幕时触发
    d> touchcancel:系统取消 touch 事件的时候触发(比较少用)
  每个触摸事件被触发后,会生成一个 event 对象, event 对象里额外包括以下三个触摸列表:
    a> touches:当前屏幕上所有手指的列表
    b> targetTouches:当前 DOM 元素上手指的列表,尽量使用这个代替 touches
    c> changedTouches:涉及当前事件的手指的列表,尽量使用这个代替 touches

```

```

  parseInt():转换为整数,默认 10 进制
  Math.floor():向下取整
  Math.ceil():向上取整
  split():操作数必需为正则或字符串
  Math.round():将数值四舍五入为最接近的整数

```

```

  "1" === 1   => false
    "1" 是字符串 string, 1 是数字 number,类型不同, === 下比较返回 false
  isNaN(1/0)    => false
    a> 任何数值除以 0 都会导致错误而终止程序执行,但是在 JavaScript 中,会返回出特殊的值,因此不会影响程序的执行
    b> 比 0 大的数除以 0,则会得到无穷大,所以 js 用 Infinity 来显示出来
    c> 1/0 得到 Infinity, isNaN(1/0)返回的是 false,但是 isNaN(0/0)返回的是 true
  1 in [1]    => false
    a> in 操作符,对于数组属性需要指定数字形式的索引值来表示数组的属性名称(固有属性除外,如 length)
    b> 在这里, 1 in [1] 并不是表示数字 1 在不在数组里,而是表示数组中是否含有 1 这个索引 index 值
  1 && 2 > 1    => true
    1 && 2 > 1,先判断右边的表达式, 2>1 返回 true, 1 && true 返回的结果也是 true

```

```

  <div>
    <input type="button" id="button1" value="1" onclick="moveBtn(this)">
    <input type="button" id="button2" value="2">
  </div>
  <script>
    function moveBtn(obj){
      var clone = obj.cloneNode(true)   // 复制一个 button1 节点
      var parent = obj.parentNode   // 找到 button1 的父节点
      parent.appendChild(clone)   // 将复制的节点加入到子节点,也就是 button1 的复制节点现在在 button2 后面了
      parent.removeChild(obj)   // 移除原来的 button1
    }
  </script>
  上面代码运行后的效果就是将 button1 节点移动到 button2 节点后面

```

## 补充知识点

### 静态语言（强类型语言）

静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 例如：C++、Java、Delphi、C#等。

### 动态语言（弱类型语言）

动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

### HTML5 语义化标签

#### 优点

1. 为了在没有 css 的情况下,页面也能呈现出很好的内容结构、代码结构
2. 比 ``` <div> ``` 标签有更加丰富的含义,方便开发和维护
3. 方便搜索引擎能识别页面结构,有利于 SEO
4. 方便其他设备解析(如移动设备、盲人阅读器等)
5. 有利于合作，遵守 W3C 标准

#### 注意

1. 尽可能少的使用无语义的标签 div 和 span
2. 在语义不明显时,既可以使用 div 或者 p 时,尽量用 p,因为 p 在默认情况下有上下间距,对兼容特殊终端有利
3. 不要使用纯样式标签，如：b、font、u等，改用css设置
4. 需要强调的文本，可以包含在strong或者em标签中
5. 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td
6. 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
7. 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性

#### 1.header 与 hgroup

- 放在页面或布局的顶部,一般放置导航栏或标题
- 一个文档可以包含一对或者一对以上的 ``` <header> ``` 标签
- 如果有连续多个 h1-h6 标签就用 hgroup
- 如果有连续多个标题和其他文章数据,h1-h6 标签就用 hgroup 包住,和其他文章元数据一起放入 header 标签

#### 2.nav

- 表示页面的导航,可以在 header 标签中使用,也可以显示在侧边栏中.一个页面之中可以有多个 nav 标签
- 为了方便搜索引擎解析,最好将主要的链接放在 nav 中

#### 3.aside

- 所包含的内容不合适页面的主要内容、具有独立性,是对页面的补充
- 一般使用在页面、文章的侧边栏、广告、友情链接等区域

#### 4.footer

- 一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。一个页面也可以有多个 footer

#### 5.article

- 应该使用在相对比较独立、完整的的内容区块，所以可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用article 元素。article 可以互相嵌套。

#### 6.section

- 一组或者一节内容。
- div、section、article 三者的比较
  - div:应用广泛,任意一个区域
  - section:包含的内容时一个明确的主题,通常有标题区域
  - article:如果页面中需要一个单独的模块来实现一个单独的功能,就用 article,其他时候都用 section

#### 7.time

- 可以带格式的时间标签

#### 8.mark

- 高亮

#### 9.address

- address 代表区块容器,必须是作为联系信息出现,邮编地址、邮件地址等,一般出现在 footer 标签中

### HTML DOM 事件

HTML DOM 事件允许 Javascript 在 HTML 文档元素中注册不同事件处理程序。

事件通常与函数结合使用，函数不会在事件发生前被执行

#### 鼠标事件

```

  onclick:当用户点击某个对象时调用的事件句柄
  oncontextmenu:在用户点击鼠标右键打开上下文菜单时触发
  ondblclick	当用户双击某个对象时调用的事件句柄
  onmousedown:鼠标按钮被按下
  onmouseenter:当鼠标指针移动到元素上时触发
  onmouseleave:当鼠标指针移出元素时触发	
  onmousemove:鼠标被移动
  onmouseover:鼠标移到某元素之上
  onmouseout:鼠标从某元素移开
  onmouseup:鼠标按键被松开

```

#### 键盘事件

```

  onkeydown:某个键盘按键被按下
  onkeypress:某个键盘按键被按下并松开
  onkeyup:某个键盘按键被松开

```

#### 表单事件

```

  onblur:元素失去焦点时触发
  onchange:该事件在表单元素的内容改变时触发( <input>, <keygen>, <select>, 和 <textarea>)
  onfocus:元素获取焦点时触发
  onfocusin:元素即将获取焦点时触发
  onfocusout:元素即将失去焦点时触发
  oninput:元素获取用户输入时触发
  onreset:表单重置时触发
  onsearch:用户向搜索域输入文本时触发 (<input="search">)
  onselect:用户选取文本时触发 ( <input> 和 <textarea>)
  onsubmit:表单提交时触发

```

### Number()

#### Number() 可以用于任何数据类型的转换,转换规则如下:

- 如果是 Boolean 值,true 和 false 将分别被转换为 1 或 0
- 如果是 null 值,则返回 0
- 如果是 undefined,返回 NaN
- 如果是字符串则遵循以下规则:
  - 字符串只把含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,前导零会被忽略
  - 如果字符串中包含有效的浮点格式,则将其转换为相应的浮点数值,前导零会被忽略
  - 如果字符串是空的,则将其转换为 0
  - 如果字符串中包含除以上格式之外的字符,则将其转换为 NaN
- 如果是数值,传啥值就返回啥值
- 如果是对象,则调用对象的 valueOf() 方法,然后依照前面的规则转换返回的值;如果转换的结果是 NaN,则调用对象的 toString() 方法,然后再次按照前面的规则转换返回的字符串值

### Canvas 和 SVG

> Canvas 和 SVG 是 HTML5 中主要的 2D 图形技术，前者提供画布标签和绘制 API，后者是一整套独立的矢量图形语言，成为 W3C 标准已经有十多年(2003.1至今)，总的来说，Canvas 技术较新，从很小众发展到广泛接受，注重栅格图像处理，SVG 则历史悠久，很早就成为国际标准，复杂，发展缓慢（Adobe SVG Viewer近十年没有大的更新）

#### 适用场景

- Canvas 提供的功能更原始,适合像素处理,动态渲染和大数据量绘制
- SVG 功能更完善,适合静态图片展示,高保真文档查看和打印的应用场景

|  | Canvas | SVG |
| --- | --- | --- |
| 历史 | 较新,由 Apple 私有的技术发展而来 | 历史悠久,2003年成为 W3C 标准 |
| 功能 | 功能简单,2D 绘图 API | 功能丰富,各种图形、滤镜、动画等 |
| 特点 | 像素，只能脚本驱动 | 矢量，XML、CSS，元素操作 |
| 支持 | 主流浏览器，IE9+ | 主流浏览器，IE9+,其他 SVG 阅读器 |
| 操作对象 | 基于像素(动态点阵图) | 基于图形元素 |
| 元素 | 单个 HTML 元素 | 多种图形元素(Rect, Path, Line ...) |
| 驱动 | 只能脚本驱动 | 支持脚本和 CSS |
| 事件交互 | 用户交互到像素点(x, y) | 用户交互到图形元素(rect, path) |
| 性能 | 适合小面积,大数量应用场景 | 适合大面积,小数量应用场景 |

### BFC(块级格式化上下文)

- BFC 就是页面上的一个隔离的独立容器,容器里面的子元素不会影响到外面的元素;反之也如此.包括浮动和外边距合并等等
- display 属性为 block, list-item, table 的元素,会产生 BFC
- 给这些元素添加如下属性就可以触发 BFC:
  - float 属性不为 none
  - position 为 absolute 或 fixed
  - display 为 inline-block, table-cell, table-caption, flex, inline-flex
  - overflow 不为 visible

#### BFC 布局规则特性

- 在 BFC 中,盒子从顶端开始垂直地一个接一个地排列
- 盒子垂直方向的距离由 margin 决定,属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠
- 在 BFC 中,每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘
  - BFC 的区域不会与浮动盒子产生交集,而是紧贴浮动边缘
  - 计算 BFC 的高度时,自然也会检测浮动或者定位的盒子高度
- 它是一个独立的渲染区域,只有 Block-level box 参与,它规定了内部 Block-level Box 如何布局,并且与这个区域外部毫不相干

#### BFC 的主要用途

- 清除元素内部浮动
  - 只要把父元素设为 BFC 就可以清除元素的浮动,最常见的用法就是在父元素上设置 overflow:hidden 样式,对于 IE6 加上 zoom:1 就可以了
- 解决外边距合并问题
  - 盒子垂直方向的距离由 margin 决定;属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠,那么创建不属于同一个 BFC,就不会发生 margin 重叠了
- 制作右侧自适应的盒子问题
  - 普通流体元素 BFC 后,为了和浮动元素不产生任何交集,顺着浮动边缘形成自己的封闭上下文

### display 和 visibility 之间的区别

#### 空间占据

- display:none 是彻底消失,不在文档中占位,浏览器也不会解析该元素(回流+重绘)
- visibility:hidden 是视觉上消失了,可以理解为透明度变为0的效果,在文档流中占位,浏览器会解析该元素(重绘)
- 使用 visibility:hidden 比 display:none 性能上要好,display:none 切换显示时,页面产生回流(当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等,页面重新构建,此时就是回流;所有页面第一次加载时需要产生一次回流),而 visibility 切换是否显示时则不会引起回流

#### 子元素继承

- display:none 不会被子元素继承,但是父元素都不在了,子元素自然也就不会显示了
- visibility:hidden 会被子元素继承,可以通过设置子元素 visibility:visible 使子元素显示出来
- opacity:0 也会被子元素继承,但是不能通过设置元素 opacity:0 使其重新显示

#### 事件绑定

- display:none 的元素都已经不再页面存在了,因此肯定也无法触发它上面的绑定的事件
- visibility:hidden 元素上绑定的事件也无法触发
- opacity:0 元素上面绑定的事件是可以触发的

#### 过渡动画

- transition 对于 display 是无效的
- transition 对于 visibility 是无效的
- transition 对于 opacity 是有效的

### HTML 结构

- ``` <!Doctype html> ```   // 声明文档类型
- ``` <html></html> ```   // 整个 html 文件
- ``` <head></head> ```   // 网页的头部内容
- ``` <body></body> ```   // 网页的主题内容

### Array 对象方法

- concat():连接两个或更多的数组,并返回结果, arr1.concat(arr2)
- join():把数组的所有元素放入一个字符串,元素通过指定的分割符进行分割,并返回结果字符串, arr.join("-") 
- pop():删除并返回数组的最后一个元素, arr.pop()
- push():向数组的末尾添加一个或更多元素,并返回新的长度, arr.push(e1, e2, ...)
- reverse():颠倒数组中元素的顺序,并返回新的数组, arr.reverse()
- shift():删除并返回数组的第一个元素, arr.shift()
- slice():从某个已有的数组返回选定的元素, arr.slice(start, end), start 是必填的,是选取的位置; end 是选填,结束的位置
- sort():对数组的元素进行排序
- splice():删除元素,并向数组添加新元素,返回新的数组, arr(index, howmany, arr1), index 是必填的,规定删除或添加的位置; howmany 也是必填项,需要删除的数量; arr1 是选填项,向数组添加的新项目
- toSource():返回该对象的源代码, object.toSource()
- toString():把数组转换为字符串,并返回结果, arr.toString()
- toLocaleString():将数组转化为本地数组,并返回结果, arr.toLocaleString()
- unshift():向数组的开头添加一个或更多元素,并返回新的长度, arr.unshift()
- valueOf():返回数组对象的原始值

### javascript 模块化

> AMD 是 "Asynchronous Module Definition" 的缩写,意思就是"异步模块定义";它采用异步方式加载模块,模块的加载不影响它后面语句的运行.所有依赖这个模块的语句,都定义在一个回调函数中,等到加载完成之后,这个回调函数才会运行;AMD 也采用 require() 语句加载模块,但是不同于 CommonJS.主要有两个 Javascript 库实现了 AMD 规范:requireJS 和 curlJS

- AMD 是 requireJS 在推广过程中对模块定义的规范化产出
- CMD 是 seaJS 在推广过程中对模块定义的规范化产出
- 区别:
  - 对于依赖的模块,AMD 是提前执行,CMD 是延迟执行
  - CMD 推崇依赖就近,AMD 推崇依赖前置

### Float

#### 浮动元素定位

- 当一个元素浮动之后,它会被移出正常的文档流,然后向左或者向右平移,一直平移到碰到所处的容器的边框,或者碰到了另一个浮动的元素

#### 浮动属性

- 只有横向浮动,并没有纵向浮动
- 当元素应用了 float 属性后,将会脱离普通流,其容器(父)元素将得不到脱离普通流的子元素高度
- 会将元素的 display 属性变更为 block
  | 指定值 | 计算值 |
  | -- | -- |
  | inline | block |
  | inline-block | block |
  | inline-table | table |
  | table-row | block |
  | table-row-group | block |
  | table-column | block |
  | table-column-group | block |
  | table-cell | block |
  | table-caption | block |
  | table-header-group | block |
  | table-footer-group | block |
  | flex | flex,but float has no effect on such elements(但是 float 对这些元素没有影响) |
  | inline-flex | inline-flex,but float has no effect on such elements(但是 float 对这些元素没有影响) |
  | other | unchanged(保持不变) |
    **备注：** 如果要在 JavaScript 中通过 [element.style](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/style) 对象来修改 float 属性，那么必须使用 [element.style](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/style) 对象的 cssFloat 属性来操作。另外还要注意到在 Internet Explorer 8 和更老的 IE 当中，要使用 styleFloat 属性。这是 DOM 驼峰命名和 CSS 所用的连字符分隔命名法对应关系中的一个特例。（这么做的原因是在 JavaScript 中 "float" 是一个保留字，因为同样的原因，"class" 被改成了 "className" 、"for" 被改成了 "htmlFor"。
- 浮动元素的后一个元素会围绕着浮动元素(典型运用是文字围绕图片),与应用了 position 的元素相比浮动元素并不会遮盖后一个元素
- 浮动元素的前一个元素不会受到任何影响(如果想让两个块状元素并排显示,必须让两个块状元素都是有都应用 float)

#### 与 position 的兼容

- 元素同时应用了 position:relative, float, (top/ left/ bottom/ right) 属性后,则元素先浮动到相应的位置,然后在根据 (top/ left/ bottom/ right) 所设置的距离来发生偏移
- 元素同时应用了 position:absolute 及 float 属性,则 float 失效
- 第一个元素应用了 position 之后会覆盖着接下来的 float 元素(如果两个元素所处的位置相同)
  ```

    如果不将 float 的元素的 position 设置成 relative 的话,想通过设置 float 元素的 z-index 来达到覆盖 position:absolute 是无效的.同理,float 元素下面存在 position:absolute 的子元素,如果不将 float 的元素的 position 设置成 relative 的话, absolute 元素是不会定位到 float 元素的

  ```
- 浮动元素在浮动的时候,其 margin 不会超过包含块的 padding,浮动元素的浮动位置不能超过包含块的内边界;浮动元素 margin 和父元素的 padding 不会合并(正常情况下也不会合并)

#### 浮动元素的延伸性

- 元素被设置成浮动后,该元素会进行延伸进而包含其所有浮动的元素;比如父元素不是浮动的,子元素浮动,子元素比较高,则子元素会超过父元素高度,如果父元素设计了 float 属性,则会包裹所有子元素

#### 浮动元素重叠问题

- 行内元素与浮动元素发生重叠,其边框,背景和内容都会显示在浮动元素之上
- 块级元素与浮动元素发生重叠,边框和背景会显示在浮动元素之下,内容会显示在浮动元素之上

#### 常见的清除浮动的方法

- 通过在容器中添加一个标签,设置该标签的样式为 clear:both
- 容器设置 overflow:hidden 或者 auto

### Javascript 异步编程的 4 种方法 

> JavaScript 语言的执行环境是"单线程"(single thread) ———— 一次只能完成一件任务;如果有多个任务,就必须排队,前面一个任务完成,在执行后面一个任务,以此类推.这种模式的好处是实现起来比较简单,执行环境相对单纯;坏处是只要有一个任务耗时长,后面的任务都必须排队等着,会拖延整个程序的执行.常见的浏览器无响应(假死),往往就是因为某一段 JavaScript 代码长时间运行(比如死循环),导致整个页面卡在这个地方,其他任务无法执行

#### 同步(Synchronous)和异步(Asynchronous)

- 同步:后一个任务等待前一个任务结束,然后在执行,程序的执行顺序与任务的排列顺序是一致的,同步的
- 异步:每一个任务有一个或多个回调函数,前一个任务结束后,不是执行后一个任务,而是执行回调函数,后一个任务则不等前一个任务结束就执行,所以程序的执行顺序与任务的排列顺序是不一致的,异步的
- **重点:**异步模式非常重要.在浏览器端,耗时很长的操作都应该异步执行,避免浏览器失去响应,最好的例子就是 Ajax 操作.在服务器端,"异步模式"甚至是唯一的模式,因为执行环境是单线程的,如果允许同步执行所有 http 请求,服务器性能会急剧下降,很快就会失去响应

#### 异步编程的 4 种方法

- 回调函数:
  - 这是异步编程最基本的方法
  - 优点:简单,容易理解和部署
  - 缺点:不利于代码的阅读和维护,各个部分之间高度耦合(Coupling),流程会很混乱,而且每个任务只能指定一个回调函数
- 事件监听:
  - 任务的执行不取决于代码的顺序,而取决于某个事件是否发生
  - 优点:比较容易理解,可以绑定多个事件,每个事件可以指定多个回调函数,而且可以"去耦合(Decoupling)",有利于实现模块化
  - 缺点:整个程序都要变成事件驱动型,运行流程会变得很不清晰
- 发布/订阅:
  - 假定存在一个"信号中心",某个任务执行完成,就向信号中心"发布(publish)"一个信号,其他任务可以向信号中心"订阅(subscribe)"这个信号,从而知道什么时候自己可以开始执行.这就是"发布/订阅模式(publish-subscribe pattern)",又称为"观察者模式(observer pattern)"
  - 这种方法的性质与"事件监听"类似,但是明显优于后者.因为可以通过查看"消息中心",了解存在多少信号,每个信号有多少订阅者,从而监控程序的运行
- Promise 对象:
  - 是 CommonJS 工作组提出的一种规范,目的是为异步编程提供统一接口.
  - 简单的说,每一个异步任务返回一个 Promise 对象,该对象有一个 then 方法,允许指定回调函数;回调函数变成了链式写法,程序的流程可以看得很清楚,而且有一整套的配套方法,可以实现很多强大的功能

### 集合转化为数组

- Array.form(arr, mapfn, thisArg):可以把对象转换为真正的数组,类似数组的对象和可遍历的对象(部署了 Iterator 接口的, String, ES6 新增的 Map 和 Set).可以传 3 个参数,其中第一个是数组,必填项;第二个是一个函数(类似 map 函数),对数组元素进行操作后再返回数组,选填项;第三个是对于 this 关键字的指向,选填项
- slice():从已有的数组中返回选定的元素,返回一个新的数组,包含从 start 到 end (不包括该元素)的 arrayObject 中的元素
  - 注意:该方法并不会修改数组,而是返回一个子数组.如果想要删除数组中的一段元素,应该使用方法 array.splice()
  - 在这里就是对集合应用 slice(),返回一个新的数组,不对数组做任何改变
- ...:展开运算符,把集合的元素展开后,用数组 [] 承载,返回新的数组
- map():返回一个新数组,数组中的元素为原始数组元素调用函数处理后的值
  - map() 方法按照原始数组元素顺序依次处理元素
  - map() 不会对空数组进行检测
  - map() 不会改变原始数组

### bootstrap

#### 工作原理

- bootstrap 框架的网络系统工作原理:
  - 数据行(.row)必须包含在容器(.container)中,以便为其赋予合适的对齐方式和内边距(padding).如:

    ```

      <div class="container">
        <div class="row"></div>
      </div>

    ```

  - 在行(.row)中可以添加列(.column),但列数之和不能超过平分的总列数 12.如:

    ```

      <div class="container">
        <div class="row">
          <div class="col-md-4"></div>
          <div class="col-md-8"></div>
        </div>
      </div>

    ```

  - 具体内容应该放置在列容器(column)之内,而且只有列(column)才可以作为行容器(.row)的直接子元素
  - 通过设置内边距(padding),从而创建列与列之间的间距.然后通过为第一列和最后一列设置负值的外边距(margin)来抵消内边距(padding)的影响

#### 栅格参数

<table style="text-align:center">
  <tr>
    <th></th>
    <th>超小屏幕(<768px),手机</th>
    <th>小屏幕(≥768),平板</th>
    <th>中等屏幕(≥992px),桌面显示器</th>
    <th>大屏幕(≥1200px),大桌面显示器</th>
  </tr>
  <tr>
    <td>栅格系统行为</td>
    <td>总是水平排列</td>
    <td colspan="3">开始是堆叠在一起的,当大于这些阈值时将变为水平排列 </td>
  </tr>
  <tr>
    <td>.container 最大宽度</td>
    <td>None(自动)</td>
    <td>750px</td>
    <td>970px</td>
    <td>1170px</td>
  </tr>
  <tr>
    <td>类前缀</td>
    <td>.col-xs-</td>
    <td>.col-sm-</td>
    <td>.col-md-</td>
    <td>.col-lg-</td>
  </tr>
  <tr>
    <td>列数</td>
    <td colspan="4">12</td>
  </tr>
  <tr>
    <td>最大列宽</td>
    <td>自动</td>
    <td>~62px</td>
    <td>~81px</td>
    <td>~97px</td>
  </tr>
  <tr>
    <td>槽宽</td>
    <td colspan="4">30px(每列左右具有 15px)</td>
  </tr>
</table>

### 关于 DOM 事件流, DOM0级事件与 DOM2级事件

#### DOM 事件模型

- DOM 事件模型包括捕获和冒泡,捕获是从上往下到达目标元素,冒泡是从当前元素,也就是目标元素往上到 window

#### 流

- 流的概念,在现今的 JavaScript 中随处可见.比如说  React 的单向数据流, Node 中的流,还有 DOM 事件流,都是流的一种生动体现
- 用术语说流就是对输入输出设备的抽象;以程序的角度说,流是具有方向的数据

#### 事件流

- 事件流所描述的就是从页面中接受事件的顺序,事件流分为两种:事件冒泡(主流)与事件捕获
  - 事件冒泡:事件开始时由具体元素接收,然后逐级向上传播到父元素
  - 事件捕获:父元素的节点更早接收事件,而具体元素最后接收事件,与事件冒泡相反

#### DOM 事件流

- DOM 事件流包括三个阶段
  - 事件捕获阶段:当事件发生时，首先发生的是事件捕获，为父元素截获事件提供了机会
  - 处于目标阶段:事件到了具体元素时，在具体元素上发生，并且被看成冒泡阶段的一部分
  - 事件冒泡阶段:最后，冒泡阶段发生，事件开始冒泡

#### 阻止事件冒泡

- 事件冒泡过程,是可以被阻止的.防止事件冒泡而带来不必要的错误和困扰
- 使用 stopPropagation() 阻止:事件在到达具体元素后，停止了冒泡，但不影响父元素的事件捕获

#### DOM0级事件

- DOM0级事件,就是直接通过 onclick 等方式实现相应的事件
  - 标签内写 onclick 事件
  - 在 JS 中使用 onclick = function(){}
- 这说明 DOM0级添加事件时,后面的事件会覆盖前面的事件,而 DOM2级则不会,多个事件都会执行;另外,DOM0级事件具有很好的跨浏览器优势,会以最快的速度绑定,但由于绑定速度太快,可能页面还未完全加载出来,以至于事件可能无法正常运行

#### DOM2级事件

- DOM2级事件的方法
  - 主流浏览器 DOM2级事件是通过以下两个方法用于出来指定和删除事件处理程序的操作:
    - addEventListener():为指定元素附加指定事件处理程序而不会覆盖已有的事件处理程序
    - removeEventListener():删除事件监听器
- DOM2级事件的使用
  - 所有的 DOM 节点都包含这两个方法,使用方法如下:
    - target.addEventListener(type, listener[, useCapture])
    - target.removeEventListener(type, listener[, useCapture])
    - 它们都接受三个参数:
      - type:事件类型,如 "click", "mouseover", "mouseout",在事件名前不加 "on"
      - listener:事件处理方法
      - useCapture:布尔参数,不传该参数时默认是 false,表示在事件冒泡阶段处理,如果是 true,则表示在捕获阶段调用事件处理程序
  - 注意:只有 DOM2级事件包含以下三个阶段
    - 事件捕获阶段
    - 处于目标阶段
    - 事件冒泡阶段

### a 标签不跳转的 3 种方法

- onclick 事件中返回 false
  ```

    <a href="http://www.baidu.com" onclick="return false">百度(不能跳转)</a>

  ```
- 用 href="javascript:void(0)" 这种伪协议(伪协议少写)
  ```

    <a href="javascript:void(0)">不能跳转</a>

  ```
- 使用(#)
  ```

    <a href="#" onclick="del()">删除</a>    // 总是跳转到当前页面,当前页面内容多的话,还是会有跳转的感觉,不推荐使用

  ```

### JavaScript 保留关键字

#### JavaScript 保留关键字

- JavaScript 的保留关键字不可以用作变量,标签或者函数名;有些保留关键字是作为 JavaScript 以后扩展使用

  |  |  |  |  |  |
  | -- | -- | --| -- | -- |
  | abstract | arguments | boolean | break | byte |
  | case | catch | char | class | const |
  | continue | debugger | default | delete | do |
  | double | else | enum | eval | export |
  | extends | false | final | finally | float |
  | for | function | goto | if | implements |
  | import | in | instanceof | int | interface |
  | let | long | native | new | null |
  | package | private | protected | public | return |
  | short | static | super | switch | synchronized |
  | this | throw | throws | transient | true |
  | try | typeof | var | void | volatile |
  | while | with | yield |

#### JavaScript 对象,属性和方法

- 也应该避免使用 JavaScript 内置的对象,属性和方法的名称作为 JavaScript 的变量或函数名:

  |  |  |  |  |  |
  | -- | -- | --| -- | -- |
  | Array | Date | eval | function | hasOwnProperty |
  | Infinity | isFinite |	isNaN |	isPrototypeOf |	length |
  | Math | NaN | name |	Number | Object |
  | prototype |	String | toString |	undefined |	valueOf |

### CSS3 新增属性

- box-shadow:阴影效果
- border-color:为边框设置多种颜色
- border-image:图片边框
- text-shadow:文本阴影
- text-overflow:文本截断
- word-wrap:自动换行
- border-radius:圆角边框
- opacity:透明度
- box-sizing:控制盒模型的组成模式
- resize:元素缩放
- outline:外边框
- background-size:指定背景图片尺寸
- background-origin:指定背景图片从哪里开始显示
- background-clip:指定背景图片从什么位置开始裁剪
- background:为一个元素指定多个背景
- hsl:通过色调、饱和度、亮度来指定颜色颜色值
- hsla:在hsl的基础上增加透明度设置
- rgba:基于rgb设置颜色，a设置透明度

### call(), apply() 和 bind() 方法的用法以及区别

> call(), apply() 和 bind() 的作用是改变函数运行时 this 的指向

#### 函数的调用方法

- 方法调用模式
  - 当一个函数被保存为对象的一个方法时,如果调用表达式包含一个提取属性的动作,那么它就是被当做一个方法来调用,此时的 this 被绑定到这个对象

    ```

      var a = 1
      var obj1 = {
        a: 2,
        fn: function(){
          console.log(this.a)
        }
      }
      obj1.fn()   // 2

      // 此时的 this 是指向 obj1 这个对象, obj1.fn() 实际上是 obj1.fn.call(obj1),事实上谁调用此函数, this 的指向就是谁.

    ```

  - DOM 对象绑定事件也属于方法调用模式,因此它绑定的 this 就是事件源 DOM 对象

    ```

      document.addEventListener("click", function(e){
        console.log(this)   // document
        setTimeout(function(){
          console.log(this)   // window
        }, 200)
      }, false)

      // 点击页面监听 click 事件属于方法调用,this 指向事件源 DOM 对象,即 obj.fn.apply(obj), setTimeout 内的函数属于回调函数,所以 this 指向 window

    ```

- 函数调用模式:就是普通函数的调用,此时的 this 被绑定到 window
  - 最普通的函数调用

    ```

      function fn1(){
        console.log(this)
      }
      fn1()   // window

    ```

  - 函数嵌套

    ```

      function fn1(){
        function fn2(){
          console.log(this)
        }
        fn2()
      }
      fn1()   // window

    ```
  
  - 把函数赋值之后再调用

    ```

      var a = 1
      var obj1 = {
        a: 2,
        fn: function(){
          console.log(this.a)
        }
      }
      var fn1 = obj1.fn
      fn1()   // 1

      // obj1.fn 是一个函数 function(){ console.log(this.a) },此时 fn1 就是不带任何修饰的函数调用, function(){console.log(this.a)}.call(undefined),按理说打印出来的 this 应该就是 undefined,但是浏览器里有一条规则:如果传的 context 为 null 或者 undefined,那么 window 对象就是默认的 context(严格模式下默认 context 是 undefined);因此上面的 this 绑定时 window,也被称为隐形绑定.

    ```
  
  - 回调函数

    ```

      var a = 1
      function f1(fn){
        fn()
        console.log(a)
      }
      f1(f2)    // 1
      function f2(){
        var a = 2
      }

      // 可以写成

      var a = 1
      function f1(){
        (function (){
          var a = 2
        })
        console.log(a)
      }
      f1()    // 1

      // 这仍然是最普通的函数调用, f1.call(undefined), this 指向 window,打印出来的是全局的 a.
      // 这就可以知道 setTimeout 总是丢失 this,因为它也是一个回调函数
      setTimeout(function(){
        console.log(this)   // window
        function fn(){
          console.log(this)   // window
        }
        fn()
      }, 0)

    ```

- 构造器调用模式
  - new 一个函数时,背地里会将创建一个连接到 prototype 成员的新对象,同时 this 会被绑定到那个新对象上

    ```

      function Person(name, age){
        // 这里的 this 指向实例
        this.name = name 
        this.age = age
        this.sayAge = function(){
          console.log(this.age)
        }
      }
      var dot = new Person("Dot", 2)
      dot.sayAge()    // 2

    ```

#### call()

- call() 方法第一个参数是要绑定给 this 的值,后面传入的是一个参数列表;当第一个参数为 null, undefined 的时候,默认指向 window

  ```

    var arr = [1, 2, 3, 89, 46]
    var max = Math.max.call(null, arr[0], arr[1], arr[2], arr[3], arr[4])
    console.log(max)    // 89

    // 可以理解为

    obj1.fn()
    obj1.fn.call(obj1)

    fn1()
    fn1.call(null)

    f1(f2)
    f1.call(null, f2)

  ```

#### apply()

- apply() 接受两个参数,第一个参数是要绑定给 this 的值,第二个参数是一个参数数组;当第一个参数为 null, undefined 的时候,默认指向 window

  ```

    var arr = [1, 2, 3, 89, 46]
    var max = Math.max.apply(null, arr)
    console.log(max)    // 89

    // 可以理解为

    obj1.fn() 
    obj1.fn.apply(obj1);

    fn1()
    fn1.apply(null)

    f1(f2)
    f1.apply(null,f2)

  ```

- 事实上 apply() 和 call() 的用法几乎相同,唯一的差别在于:当函数需要传递多个变量时,apply() 可以接受一个数组作为参数输入,call() 则是接受一系列的单独变量

#### bind()

- bind() 和 call() 很相似,第一个参数是 this 的指向,从第二个参数开始是接收的参数列表;区别在于:bind() 返回值是函数以及 bind() 接收的参数列表的使用
  - bind() 返回值是函数

    ```

      var obj = {
        name: "Dot"
      }

      function printName(){
        console.log(this.name)
      }

      var dot = printName.bind(obj)
      console.log(dot)    // function printName(){ console.log(this.name) }
      dot()   // Dot

      // bind() 方法不会立即执行,而是返回一个改变了上下文 this 后的函数;而原函数 printName 中的 this 并没有被改变,依旧指向全局对象 window

    ```

  - 参数的使用

    ```

      function fn(a, b, c){
        console.log(a, b, c)
      }
      var fn1 = fn1.bind(null, "Dot")

      fn("A", "B", "C")   // A B C
      fn1("A", "B", "C")    // Dot A B
      fn1("B", "C")   // Dot B C
      fn.call(null, "Dot")    // Dot undefined undefined

      // call() 是把第二个及以后的参数作为 fn 方法的实参传进去，而 fn1 方法的实参实则是在 bind() 中参数的基础上再往后排。

    ```

#### 应用场景

- 求数组中的最大和最小值

  ```

    var arr = [1, 2, 3, 89, 46]
    var max = Math.max.apply(null, arr)
    var min = Math.min.apply(null, arr)
    console.log(max)    // 89
    console.log(min)    // 1

  ```

- 将类数组转化为数组

  ```

    var trueArr = Array.prototype.slice.call(arrayLike)
  
  ```

- 数组追加

  ```

    var arr1 = [1, 2, 3]
    var arr2 = [4, 5, 6]
    var total = [].push.apply(arr1, arr2)
    console.log(arr1)   // [1, 2, 3, 4, 5, 6]
    console.log(arr2)   // [4, 5, 6]
    console.log(total)    // 6

  ```

- 判断变量类型

  ```

    function isArray(obj){
      return Object.prototype.toString.call(obj) == "[object Array]"
    }
    console.log(isArray([]))    // true
    console.log(isArray("dot"))    // false

  ```

- 利用 call() 和 apply() 做继承

  ```

    function Person(name, age){
      // 这里的 this 都指向实例
      this.name = name
      this.age = age
      this.sayAge = function(){
        console.log(this.age)
      }
    }
    function Female(){
      Person.apply(this, arguments)   // 将父元素所有方法在这里执行一遍就继承了
    }
    var dot = new Female("Dot", 2)

  ```

- 使用 log 代理 console.log

  ```

    function log(){
      console.log.apply(console, arguments)
    }

    // 当然也有更方便的 var log = console.log.bind()

  ```

#### 总结

- call(), apply() 和 bind() 函数存在的区别:
  - bind() 返回对应函数,便于稍后调用;apply(), call() 则是立即调用
  - 在 ES6 箭头函数下,call() 和 apply() 将失效,对于箭头函数来说:
    - 箭头函数内的 this 对象,就是定义时所在的对象,而不是使用时所在的对象;所以不需要类似于 var _this = this 这种丑陋写法
    - 箭头函数不可以当作构造函数,也就说不可以使用 new 命令,否则会抛出一个错误
    - 箭头函数不可以使用 arguments 对象,该对象在函数体内不存在;如果要用,可以用 Rest 参数代替
    - 不可以使用 yield 命令,因此箭头函数不能用作 Generator 函数

### 改变作用域链的三种方法

#### eval()

- eval() 函数可计算某个字符串,并执行其中的 JavaScript 代码
  - 返回值:通过计算 string 得到的值
  - 说明:
    - 该方法只接受原始字符串作为参数,如果 string 参数不是原始字符串,那么该方法将不作任何改变地返回;因此请不要为 eval() 函数传递 String 对象来作为参数
    - 如果试图覆盖 eval 属性或把 eval() 方法赋予另一个属性,并通过该属性调用它,则 ECMAScript 实现允许抛出一个 EvalError 异常
    - 如果字符串中有新定义函数,那么它就有可能再建一个执行环境
  - 抛出:
    - 如果参数中没有合法的表达式和语句,则抛出 SyntaxError 异常
    - 如果非法调用 eval(),则抛出 EvalError 异常
    - 如果传递 eval() 的 JavaScript 代码生成了一个异常, eval() 将把该异常传递给调用者

#### with()

- with 语句用于设置代码在特定对象中的作用域;将会指定的对象添加到作用域中
  
  ```

    var sMessage = "hello"
    with(sMessage){
      alert(toUpperCase())    // 输出 "HELLO"
    }

  ```

#### try-catch

- try-catch 中的 catch 块,会创建一个新的变量对象,其中包含的是被抛出的错误对象的声明

#### 总结

- 执行环境的类型只有两种:全局函数和局部函数;但是还有其他办法来延长作用域链
- 有些语句可以在作用域链的前端临时增加一个变量对象,该变量对象会在代码执行后被移除
- 在两种情况下会发生这种现象,具体来说,就是当执行流进入下列任何一个语句时,作用域链就会得到加强:
  - try-catch 语句的 catch 块
  - with 语句

### JS 基本数据类型

> JS 基本有 6 种简单数据类型: String, Number, Boolean, Null, undefined, symbol(ES6 新增);一种复杂的数据类型(引用数据类型) Object

- String(字符串)
  - 字符串可以使用 "" 赋值,也可以使用 '' 赋值
  - 将其他数据类型转换为 String 类型,可以使用 String() 和 toString() 这两个方法的区别是 String() 可以转任何类型,而 toString() 方法不能转 Null, undefined 两种类型
- Number(数字)
  - 将数字开头的字符串中提取数字使用 parseInt() 和 parseFloat()
- Boolean(布尔值)
  - 将其他数据类型转换为 Boolean 类型使用 Boolean() 方法
  - Number 的值为 0 返回 false,其他的返回为 true;字符串只赋值为 "" 返回为 false,其他返回为 true
- Null(空)
- undefined(未定义)

### Ajax 和 Flash 的区别

- Ajax 的优势
  - 可搜索性
    - 普通的文本网页会更有利于 SEO;文本内容是搜索引擎容易检索的，而繁琐的 SWF 字节码却是搜索引擎不愿触及的。虽然 Google 等一些大型的搜索引擎可以检索 SWF 内部的内容，但是仍然有很多麻烦存在
  - 开放性
    - Flash 常年以来被 Macromedia 看的很死;包括 Flex, FMS 等辅佐技术一直都需要昂贵的安装和维护费用;而 JS 则没有这样的麻烦,没有人愿意承担法律和版权的风险
  - 费用
    - Flash 开发是很昂贵的,因为 FlashID 等环境都是要收费的;而 Ajax 则不同,虽然有一些便宜的生成 SWF 的工具,但是它们的功能实在无法满足复杂需求
  - 易用性
    - Ajax 程序有更好的易用性,由于中间有一层 Flashplayer 代理层,因此许多辅助功能无法被 Flash 灵活利用;而且 Flash 在一些方面有着不好的口碑,比如弹出广告,恶意代码
  - 易于开发
    - 人们开发复杂的 Ajax 和 Flash 应用程序时,都会借助一些高级的开发工具;普遍来说, Ajax 的开发包比 Flash 简便,容易
- Flash 的优势
  - 多媒体处理
    - Flash 在音频、视频等多媒体领域相比 HTML 有绝对的优势。现在几乎所有的网站都包含有 Flash 内容
  - 兼容性
    - 由于通过了唯一的 FlashPlayer “代理”。不必像调试JS那样，在不同的浏览器中调试程序
  - 矢量图形
    - 这是 Flash 最大的优势，同样处在这一领域的 SVG, Canvas element 以及 Direct 完全不能与 Flash 相比
  - 客户端资源调度
    - Flash 能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的 HTML 无法完成的
- Ajax 的劣势
  - 它可能破坏浏览器的后退功能   
  - 使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中,不过这些都有相关方法解决
- Flash 的劣势
  - 二进制格式 
  - 格式私有 
  - flash 文件经常会很大,用户第一次使用的时候需要忍耐较长的等待时间  
  - 性能问题

### 前端性能优化 ———— reflow(回流)和 repaint(重绘)

> 在浏览器的整个渲染过程中(页面初始化,用户行为改变页面样式,动画改变界面样式等)reflow(回流)和 repaint(重绘)会大大影响 web 性能,尤其是手机页面;所以在页面设计的时候要尽量减少 reflow 和 repaint

#### 概念

- reflow
  - 例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流
  - 回流基本上是无法避免的.现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着
- repaint
  - 如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint(重绘);repaint 的速度明显快于 reflow

#### 导致 reflow 发生的情况

- 改变窗口大小
- 改变文字大小
- 内容的改变,如用户在输入框中输入
- 激活伪类,如 hover
- 操作 class 属性
- 脚本操作 DOM
- 计算 offsetWidth 和 offsetHeight
- 设置 style 属性

#### 减少 reflow 的方式

- 不要通过父级来改变元素样式,最好直接改变子元素样式,改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸
- 尽量通过 class 来设计元素样式,切忌在通过脚本改变 style
- 实现元素的动画,对应经常要进行回流的组件,要抽离出来,它的 position 属性应当设为 fixed 或 absolute
- 权衡速度的平滑,比如实现一个动画,以 1 像素为单位移动这样最平滑,但 reflow 就会过于频繁, CPU 很快就会被完全占用;如果以 3 个像素为单位移动就会好很多
- 不要用 tables 布局的另一个原因就是 tables 中某个元素一旦触发 reflow 就会导致 tables 里所有的其他元素 reflow;在适合用 table 的场合,可以设置 table-layout 为 auto 或 fixed
- 这样可以让 table 一行一行的渲染,这种做法也是为了限制 reflow 的影响范围
- css 里不要有表达式 expression
- 减少不必要的 DOM 层级,改变 DOM 树中的一级会导致所有层级的改变,上至根部,下至被改变节点的子节点,这导致大量时间耗费在执行 reflow 上面
- 避免不必要的复杂的 CSS 选择器,尤其是后代选择器,因为为了匹配选择器将耗费更多的 CPU
- 尽量不要过多的频繁的去增加,修改,删除元素,因为这可能会频繁的导致页面 reflow,可以先把该 DOM 节点抽离到内存中进行复杂的操作,然后在 display 到页面上
- 请求如下值: offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop, scrollLeft, scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth, clientHeight,浏览器会发生 reflow,建议将它们合并到一起操作,可以减少 reflow 的次数

### position 属性

> position 属性规定元素的定位类型

- absolute:生成绝对定位的元素,相对于 static 定位以外的第一个父元素进行定位
- fixed:生成绝对定位的元素,相对于浏览器窗口进行定位
- relative:生成相对定位的元素,相对于其正常位置进行定位
- static:默认值,没有定位,元素出现在正常的流中
- inherit:规定应该从父元素继承 position 属性的值

### link 与 @import 的区别

- link 是 XHTML 标签,除了加载 css 外,还可以定义 RSS 等其他事务; @import 属于 CSS 范畴,只能加载 CSS
- link 引用 CSS 时,在页面载入时同时加载; @import 需要页面网页完全载入以后加载
- link 是 XHTML 标签,无兼容问题; @import 是在 CSS2.1 提出的,低版本浏览器不支持
- link 支持使用 JavaScript 控制 DOM 去改变样式;而 @import 不支持

### Promise 对象

#### 概述

- Promise 对象是 JavaScript 的异步操作解决方案,为异步操作提供统一接口;它起到代理作用(proxy),充当异步操作与回调函数之间的中介,使得异步操作具备同步操作的接口;Promise 可以让异步操作写起来,就像在写同步操作的流程,而不必一层层地嵌套回调函数
- Promise 是一个对象,也是一个构造函数

  ```

    function f1(resolve, reject){
      // 异步代码...
    }
    var p1 = new Promise(f1)
    // 上面代码中, Promise 构造函数接受一个回调函数 f1 作为参数, f1 里面是异步操作的代码,然后返回的 p1 就是一个 Promise 实例

    // Promise 的设计思想:所有异步任务都返回一个 Promise 实例. Promise 实例有一个 then 方法,用来指定下一步的回调函数

    p1.then(f2)
    // 上面代码中, f1 的异步操作执行完成,就会执行 f2

    // 传统写法可能需要把 f2 作为回调函数传入 f1(f2),异步操作完成后,在 f1 内部调用 f2;Promise 使得 f1 和 f2 变成了链式写法.不仅改善了可读性,而且对于多层嵌套的回调函数尤其方便
    // 传统写法
    step1(function (value1) {
      step2(value1, function(value2) {
        step3(value2, function(value3) {
          step4(value3, function(value4) {
            // ...
          })
        })
      })
    })
    // Promise 的写法
    (new Promise(step1))
      .then(step2)
      .then(step3)
      .then(step4)
    // 从上面的代码可以看到,采用 Promise 以后,程序流程变得非常清楚,十分易读
 
  ```

- 总的来说,传统的回调函数写法使得代码混成一团,变得横向发展而不是向下发展;而 Promise 就是解决这个问题,使得异步流程可以写成同步流程
- Promise 原本只是社区提出的一个构想,一些函数库率先实现了这个功能, ECMAScript6 将其写入语言标准,目前 JavaScript 原生支持 Promise 对象

#### Promise 对象的状态

- Promise 对象通过自身的状态,来控制异步操作; Promise 实例具有三种状态:
  - pending(异步操作未完成)
  - fulfilled(异步操作成功)
  - rejected(异步操作失败)
- fulfilled 和 rejected 合在一起称为 resolved(已定型)
- Promise 对象的状态变化途径只有两种:
  - "未完成" => "成功"
  - "未完成" => "失败"
- 一旦状态发生变化,就凝固了,不会再有新的状态变化,这也是 Promise 名字的由来,它的名字的意思是承诺",一旦承诺成效,就不得再改变了,这也意味着 Promise 实例的状态变化只可能发生一次
- Promise 的最终结果只有两种:
  - 异步操作成功, Promise 实例传回一个值(value),状态变为 fulfilled
  - 异步操作失败, Promise 实例抛出一个错误(error),状态变为 rejected

#### Promise 构造函数

- JavaScript 提供原生的 Promise 构造函数,用来生成 Promise 实例

  ```

    var promise = new Promise(function(resolve, reject){
      // ...

      if(/* 异步操作成功 */){
        resolve(value)
      }else{  /* 异步操作失败 */
        reject(new Error())
      }
    })
    // 上面代码中, Promise 构造函数接受一个函数作为参数,该函数的两个参数分别是 resolve 和 reject;它们是两个函数,由 JavaScript 引擎提供,不用自己实现

  ```

- resolve 函数的作用是将 Promise 实例的状态从"未完成"变为"完成"(即从 pending 变为 fulfilled),在异步操作成功时调用,并将异步操作的结果作为参数传递出去
- reject 函数的作用是将 Promise 实例的状态从"未完成"变为"失败"(即从 pending 变为 fulfilled),在异步操作失败时调用,并将异步操作报出的错误作为参数传递出去

```

  function timeout(ms){
    return new Promise((resolve, reject) => {
      setTimeout(resolve, ms, "done")
    })
  }
  timeout(100)
  // 上面代码中, timeout(100) 返回一个 Promise 实例,在 100 毫秒后,该实例的状态会变为 fulfilled

```

#### Promise.prototype.then()

> Promise 实例的 then 方法,用来添加回调函数

- then 方法可以接受两个回调函数,第一个是异步操作成功时(变为 fulfilled 状态)时的回调函数,第二个是异步操作失败(变为 rejected)时的回调函数(该参数可以省略);一旦状态改变,就调用相应的回调函数

  ```

    var p1 = new Promise(function (resolve, reject){
      resolve("成功")
    })
    p1.then(console.log)    // 成功

    var p2 = new Promise(function (resolve, reject){
      reject("失败")
    })
    p2.catch(console.log)   // 失败
    // 上面代码中, p1 和 p2 都是 Promise 实例,它们的 then 方法绑定两个回调函数:成功时在 then 调用回调函数 console.log,失败时在 catch 中调动回调函数 console.log; p1 的状态变为成功, p2 的状态变为失败,对应的回调函数会受到异步操作传回的值,然后在控制台输出

  ```

- then 方法可以链式使用

  ```

    p1.then(step1)
      .then(step2)
      .then(step3)
      .then(
        console.log
      ).catch(
        console.log
      )
    // 上面代码中, p1 后面有四个 then 和一个 catch,意味着依次有四个回调函数,只要前一步的状态变为 fulfilled,就会依次执行紧跟在后面的回调函数
    // 最后一个 catch 方法,可以显示 p1, step1, step2, step3 之间任意一个发生的错误,如果 step1 的状态变为 rejected,那么 step2 和 step3 都不会执行了(因为它们是 resolve 的回调函数); Promise 开始寻找,接下来第一个为 rejected 的回调函数,这就是说, Promise 对象的报错具有传递性

  ```

#### then() 用法辨析

- Promise 的用法,简单说就是:使用 then 方法添加回调函数;但是不同的写法有一些差别

  ```

    // 写法一
    f1().then(function(){
      return f2()
    })

    // 写法二
    f1().then(function(){
      f2()
    })

    // 写法三
    f1().then(f2())

    // 写法四
    f1().then(f2)

    // 这四种写法再用 then 方法接一个回调函数 f3
    // 写法一:f3 回调函数的参数是 f2 函数的运行结果
    f1().then(function(){
      return f2()
    }).then(f3)

    // 写法二:f3 回调函数的参数是 undefined
    f1().then(function(){
      f2()
      return
    }).then(f3)

    // 写法三:f3 回调函数的参数是 f2 函数返回的函数的运行结果
    f1().then(f2())
      .then(f3)

    // 写法四:f3 回调函数的参数是 f2 函数的运行结果,但是 f2 会接收到 f1() 返回的结果
    f1().then(f2)
      .then(f3)

  ```

#### Promise 的实例

##### 加载图片

```

  // 图片的加载
  var preloadImage = function (path) {
    return new Promise(function (resolve, reject) {
      var image = new Image()
      image.onload  = resolve
      image.onerror = reject
      image.src = path
    })
  }

```

##### ajax 操作

```

  // ajax 操作时典型的异步操作
  // 传统写法
  function search(term, onload, onerror) {
    var xhr, results, url;
    url = 'http://example.com/search?q=' + term

    xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)

    xhr.onload = function (e) {
      if (this.status === 200) {
        results = JSON.parse(this.responseText)
        onload(results)
      }
    }
    xhr.onerror = function (e) {
      onerror(e)
    }
    xhr.send()
  }
  search('Hello World', console.log, console.error)

  // Promise 写法
  function search(term) {
    var url = 'http://example.com/search?q=' + term
    var xhr = new XMLHttpRequest()
    var result
    var p = new Promise(function (resolve, reject) {
      xhr.open('GET', url, true)
      xhr.onload = function (e) {
        if (this.status === 200) {
          result = JSON.parse(this.responseText)
          resolve(result)
        }
      }
      xhr.onerror = function (e) {
        reject(e)
      }
      xhr.send()
    })
    return p
  }
  search('Hello World').then(console.log, console.error)

  // 加载图片使用 ajax 操作
  function imgLoad(url) {
    return new Promise(function (resolve, reject) {
      var request = new XMLHttpRequest()
      request.open('GET', url)
      request.responseType = 'blob'
      request.onload = function () {
        if (request.status === 200) {
          resolve(request.response)
        } else {
          reject(new Error('图片加载失败：' + request.statusText))
        }
      }
      request.onerror = function () {
        reject(new Error('发生网络错误'))
      }
      request.send()
    })
  }

```

#### 小结

- Promise 的优点在于:让回调函数变成了规范的链式写法,程序的流程可以看到很清楚;它有一整套接口,可以实现许多强大的功能,比如同时执行多个异步操作,等到它们的状态都改变以后,再执行一个回调函数;或者为多个函数中抛出的错误,统一指定处理方法等等
- Promise 还有一个传统写法没有的好处:它的状态一旦改变,无论何时查询,都能得到这个状态;这意味着,无论何时为 Promise 实例添加回调函数,该函数都能正确执行,所以不用担心是否错过了某个事件或信号;如果是传统写法,通过监听事件来执行回调函数,一旦错过事件,再添加回调函数是不会执行的
- Promise 的缺点是,编写的难度比传统写法高,而且阅读代码也不是一眼可以看懂,必须要在回调函数里面理清逻辑

#### 微任务

- Promise 的回调函数属于异步任务,会在同步任务之后执行

  ```

    new Promise(function (resolve, reject) {
      resolve(1);
    }).then(console.log);

    console.log(2);
    // 2
    // 1
    // 上面代码会输出 2,再输出 1;因为 console.log(2) 是同步任务,而 then 的回调函数属于异步任务,一定晚于同步任务执行
    
    // 但是, Promise 的回调函数不是正常的异步任务,而是微任务（microtask）;它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务
    setTimeout(function() {
      console.log(1)
    }, 0)
    new Promise(function (resolve, reject) {
      resolve(2)
    }).then(console.log)
    console.log(3)
    // 3
    // 2
    // 1
    // 上面代码输出结果是 3, 2, 1,这说明 then 的回调函数的执行时间,早于 setTimeout(fn, 0),因为 then 是本轮事件循环执行, setTimeout(fn, 0) 在下一轮事件循环开始执行
  
  ```

### CSS Sprites

#### 简介

- CSS Sprites 在国内很多人叫 css 精灵,是一种网页图片应用处理方式;它允许将一个页面涉及到的所有零星图片都包含到一张大图中,利用 CSS 的 "background-image", "background-repeat", "background-position" 的组合进行背景定位,访问页面时避免图片载入缓慢的现象

#### 优点

- CSS Sprites 能很好地减少网页的 http 请求,从而大大的提高页面的性能,这是 CSS Sprites 最大的有点,也是其被广泛和应用的主要原因
- CSS Sprites 能减少图片的字节
- CSS Sprites 解决了网页设计师在图片命名上的困扰,只需要对集合的图片命名,不需要对每一个小图片进行命名,从而提高了网页制作效率
- CSS Sprites 只需要修改一张或少张图片的颜色或样式来改变整个网页的风格

#### 缺点

- 图片合并麻烦:图片合并时,需要把多张图片有序的合理的合并成一张图片,并留好足够的空间防止版块出现不必要的背景
- 图片适应性差:在高分辨的屏幕下自适应页面,若图片不够宽会出现背景断裂
- 图片定位繁琐:开发时需要通过工具测量计算每个背景单元的精确位置
- 可维护性差:页面背景需要少许改动,可能要修改部分或整张已合并的图片,进而要改动 css,在避免改动图片的前提下,又只能(最好)往下追加图片,这样增加了图片字节

### HTML 元素

#### 块级元素

- 块级元素:在浏览器显示时,通常会以新行来开始(和结束);块级元素按照其应用于结构还是内容分为三种:
  - 结构化块状元素:这类元素用于构造文档的结构,没有语义上的含义,仅仅划分出了文档的组织方式,并没有体现文档的内容
  - 终端块状元素:这类元素用于从结构转向内容,拥有语义上的含义,能够表明内容的性质;终端块状元素属于结构的终点,它们不能再包含其他块级元素,只能包含文本或行级元素
  - 多目标块状元素:多目标指的是可以自由的扩展或嵌套文档的结构,以可以终端的形式出现;当多目标块状元素以结构化的方式使用时就含有结构化的内涵,以终端的形式使用就含有语义的内涵 

  |  |  |
  | --- | --- |
  | ``` <address> ``` | 定义地址 |
  | ``` <caption> ``` | 定义表格标题 |
  | ``` <dd> ``` | 定义列表中定义条目 |
  | ``` <div> ``` | 定义文档中的分区或节 |
  | ``` <dl> ``` | 定义列表 |
  | ``` <dt> ``` | 定义列表中的项目 |
  | ``` <fieldset> ``` | 定义一个框架集 |
  | ``` <form> ``` | 定义 HTML 表单 |
  | ``` <h1> ``` | 定义最大标题 |
  | ``` <h2> ``` | 定义副标题 |
  | ``` <h3> ``` | 定义标题 |
  | ``` <h4> ``` | 定义标题 |
  | ``` <h5> ``` | 定义标题 |
  | ``` <h6> ``` | 定义最小的标题 |
  | ``` <hr> ``` | 创建一条水平线 |
  | ``` <legend> ``` | 元素为 fieldset 元素定义标题 |
  | ``` <li> ``` | 标签定义列表项目 |
  | ``` <noframes> ``` | 为那些不支持框架的浏览器显示文本,于 frameset 元素内部 |
  | ``` <noscript> ``` | 定义在脚本未被执行时的替代内容 |
  | ``` <ol> ``` | 定义有序列表 |
  | ``` <ul> ``` | 定义无序列表 |
  | ``` <p> ``` | 定义段落 |
  | ``` <pre> ``` | 定义预格式化的文本 |
  | ``` <table> ``` | 定义 HTML 表格 |
  | ``` <tbody> ``` | 标签表格主题(正文) |
  | ``` <td> ``` | 表格中的标准单元格 |
  | ``` <tfoot> ``` | 定义表格的页脚(脚注或表注) |
  | ``` <th> ``` | 定义表头单元格 |
  | ``` <thead> ``` | 标签定义表格的表头 |
  | ``` <tr> ``` | 定义表格中的行 |

#### 行内元素

- 内联元素或称为行内元素一般都是基于语义级的基本元素,只能容纳文本或者其它内联元素

  |  |  |
  | --- | --- |
  | ``` <a> ``` | 标签可定义锚 |
  | ``` <abbr> ``` | 表示一个缩写形式 |
  | ``` <acronym> ``` | 定义只取首字母缩写 |
  | ``` <b> ``` | 字体加粗 |
  | ``` <bdo> ``` | 可覆盖默认的文本方向 |
  | ``` <big> ``` | 大号字体加粗 |
  | ``` <br> ``` | 换行 |
  | ``` <cite> ``` | 引用进行定义 |
  | ``` <code> ``` | 定义计算机代码文本 |
  | ``` <dfn> ``` | 定义一个定义项目 |
  | ``` <em> ``` | 定义为强调的内容 |
  | ``` <i> ``` | 斜体文本效果 |
  | ``` <img> ``` | 向网页中嵌入一副图像 |
  | ``` <input> ``` | 输入框 |
  | ``` <kbd> ``` | 定义键盘文本 |
  | ``` <label> ``` | 标签为 input 元素定义标注(标记) |
  | ``` <q> ``` | 定义短的引用 |
  | ``` <samp> ``` | 定义样本文本 |
  | ``` <select> ``` | 创建单选或多选菜单 |
  | ``` <small> ``` | 呈现小号字体效果 |
  | ``` <span> ``` | 组合文档中的行内元素 |
  | ``` <strong> ``` | 语气更强的强调的内容 |
  | ``` <sub> ``` | 定义下标文本 |
  | ``` <sup> ``` | 定义上标文本 |
  | ``` <textarea> ``` | 多行的文本输入控件 |
  | ``` <tt> ``` | 打字机或者等宽的文本效果 |
  | ``` <var> ``` | 定义变量 |

#### 块级元素与行内元素的区别

- 块级元素会独占一行,其宽度自动填满其父元素宽度;行内元素不会独占一行,相邻的行内元素会排列在同一行,直至一行排不下才会换行,其宽度随元素的内容而变化
- 块级元素可以包含行内元素和块级元素;行内元素不能包含块级元素
- 行内元素设置 width, height, margin-top, margin-bottom, padding-top, padding-bottom 无效

#### 块级元素与行内元素的转换

- display: inline-block
- display: block
- display: block

#### 可变元素

- 可变元素列表:可变元素为根据上下文语境决定该元素为块元素或者内联元素

  |  |  |
  | --- | --- |
  | ``` <button> ``` | 按钮 |
  | ``` <del> ``` | 定义文档中已被删除的文本 |
  | ``` <iframe> ``` | 创建包含另外一个文档的内联框架(即行内框架) |
  | ``` <ins> ``` | 标签定义已经被插入文档中的文本 |
  | ``` <map> ``` | 客户端图像映射(即热区) |
  | ``` <object> ``` | object 对象 |
  | ``` <script> ``` | 客户端脚本 |

### input

- type 属性规定 input 元素的类型

  |  |  |
  | --- | --- |
  | ``` <button> ``` | 定义可点击按钮(多数情况下,用于通过 JavaScript 启动脚本) |
  | ``` <checkbox> ``` | 定义复选框 |
  | ``` <file> ``` | 定义输入字段和"浏览"按钮,供文件上传 |
  | ``` <hidden> ``` | 定义隐藏的输入字段 |
  | ``` <image> ``` | 定义图片形式的提交按钮 |
  | ``` <password> ``` | 定义密码字段,该字段的字符被掩码 |
  | ``` <radio> ``` | 定义单选按钮 |
  | ``` <reset> ``` | 定义重置按钮,重置按钮会清除表单中的所有数据 |
  | ``` <submit> ``` | 定义提交按钮,提交按钮会把表单数据发送到服务器 |
  | ``` <text> ``` | 定义单行的输入字段,用户可以在其中输入文本,默认宽度为 20 个字符 |

### 置换元素和非置换元素

#### 置换元素

- 浏览器根据元素的标签和属性,来决定元素的具体显示内容
  - 例: 浏览器根据 ``` <img> ``` 标签的 src 属性显示图片;根据标签的 type 属性决定显示输入框还是按钮
- 置换元素在其显示中生成了框,这也就是有的内联元素能够设置宽高的原因
  - html 中的 ``` <img> ```, ``` <input> ```, ``` <textarea> ```, ``` <select> ```, ``` <object> ``` 都是置换元素,这些置换元素往往没有实际内容,只是一个空元素

#### 非置换元素

- 浏览器中的大多数元素都是不可置换元素,即其内容直接展示给浏览器
  - 例: ``` <label> ``` 标签, ``` <p> ``` 标签里的内容会被浏览器直接显示给用户

### 浏览器加载 CommonJS 模块的原理与实现

#### 原理

- 浏览器不兼容 CommonJS 的根本原因,在于缺少四个 Node.js 环境的变量:
  - module
  - exports
  - require
  - global
- 只要能提供这四个变量,浏览器就能加载 CommonJS 模块

  ```

    var module = {
      exports: {}
    }
    (function(module, exports){
      exports.multiply = function(n){
        return n * 1000
      }
    }(module, module.exports))
    var f = module.exports.multiply
    f(5)    // 5000
    // 上面代码向一个立即执行函数提供 module 和 exports 两个外部变量,模块就放在这个立即执行函数里面;模块的输出值放在 module.exports 之中,这样就实现了模块的加载

  ```

#### Browserify 的实现

- Browserify 是目前最常用的 CommonJS 格式转换的工具

  ```

    // main.js 模块加载 foo.js 模块
    // foo.js
    module.exports = function(x){
      console.log(x)
    }

    // main.js
    var foo = require("./foo")
    foo("Hi")

    // node 安装 browserify
    npm install browserify -g

    // 输入命令,就能将 main.js 转为浏览器可用的格式
    browserify main.js > compiled.js

    // node 安装 browser-unpack
    npm install browser-unpack -g

    // 然后将前面生成的 commpile.js 解包
    browser-unpack < compiled.js

    // commpile.js
    [
      {
        "id": 1,
        "source": "module.exports = function(x) {\n  console.log(x);\n};",
        "deps": {}
      },
      {
        "id": 2,
        "source": "var foo = require(\"./foo\");\nfoo(\"Hi\");",
        "deps": {"./foo":1},
        "entry": true
      }
    ]

    // 可以看到, browerify 将所有模块放入一个数组, id 属性是模块的编号, source 属性是模块的源码, deps 属性是模块的依赖
    // 因为 main.js 里面加载了 foo.js, 所以 deps 属性就指定 ./foo 对应一号模块;执行的时候,浏览器遇到 require("./foo") 语句,就自动执行 1 号模块的 source 属性,并将执行后的 module.exports 属性值输出

  ```

### 常见的浏览器端的存储技术

- 有时需要将网页中的一些数据保存在浏览器端,这样做的好处:当下次访问页面时,不需要再次向服务器请求数据,直接就可以从本地读取数据;目前常用的有以下几种方法:
  - cookie
    - cookie 会随着每次 HTTP 请求头信息一起发送,无形中增加了网络流量,另外, cookie 能存储的数据容量有限,根据浏览器类型不同而不同, IE6 大约只能存储 2K
  - Flash ShareObject
    - 这种方式能解决 cookie 存储的两个弊端,而且能够跨浏览器,应该说是目前最好的本地存储方案;不过需要在页面中插入一个 Flash,当浏览器没有安装 Flash 控件时就不能用了,所幸的是,没有安装 Flash 的用户极少
    - 缺点:需要安装 Flash 插件
  - Google Gear
    - Google 开发出来的一种本地存储技术
    - 缺点:需要安装 Gear 组件
  - userData
    - IE 浏览器可使用 userData 来存储数据,容量可以达到 640K,这种方案很可靠的,不需要安装额外的插件
    - 缺点:仅在 IE 浏览器下有效
  - session Storage
    - 使用于 Firefox2+ 的火狐浏览器,用这种方式存储的数据仅窗口级别有效,同一个窗口(或者 Tab)页面刷新或者跳转,都能获取到本地存储的数据,当新开窗口或者页面时,原来的数据就失效了
    - 缺点: IE 不支持,不能实现数据的持久保存
  - global Storage
    - 使用于 Firefox2+ 的火狐浏览器,类似于 IE 的 userData

      ```

        // 1.赋值
        globalStorage[location.hostname]['name'] = 'tugai'
        // 2.读取
        globalStorage[location.hostname]['name']
        // 3.删除
        globalStorage[location.hostname].removeItem('name')

      ```
    
    - 缺点: IE 不支持
  - local Storage
    - local Storage 是 Web Storage 互联网存储规范中的一部分,现在在 Firefox3.5, Safari4 和 IE8 中得到支持
    - 缺点:低版本浏览器不支持
- 结论:
  - Flash shareobject 是不错的选择,如果不想在页面上嵌入 Flash,可以结合使用 userData(IE6+)和 gloabalStorage(Firefox2+)和 localStorage(chrome3+)实现跨浏览器

### 解释性语言和编译性语言

> 计算机不能直接理解高级语言,只能直接理解机器语言,所以必须要把高级语言翻译成机器语言,计算机才能执行高级语言编写的程序;翻译的方式有两种:一个是编译,一个是解释;两种方式只是翻译的时间不同

#### 解释性语言

- 定义:解释性语言的程序不需要编译,在运行程序的时候才翻译,每个语句都是执行的时候才翻译;这样解释性语言每执行一次就需要逐行翻译一次,效率比较低;现在解释性语言通常把源程序编译成中间代码,然后用解释器把中间代码一条条翻译成目标机器代码,一条条执行

#### 编译性语言

- 定义:编译性语言写的程序在被执行之前,需要一个专门的编译过程,把程序编译成为机器语言的文件,比如 .exe 文件,以后要运行的话就不用重新编译了,直接使用编译的结果就行了,因为翻译只做了一次,运行时不需要翻译,所以编译型语言的程序执行效率高

### 原型链知识

- Object.prototype 只是一个普通对象,它是 js 原型链的最顶端
  - ``` Object.prototype.__proto__===null ```   => true
  - ``` Object.prototype.prototype===undefined ```    => true
  - 注: ``` Object.prototype ``` 只是一个普通对象(普通对象是没有 prototype 属性,所以值是 undefined);``` Object.prototype ``` 是 js 原型链的最顶端,它的 ``` __proto__ ``` 是 null(有 ``` __proto__ ``` 属性,但值是 null,因为这是原型链的最顶端)
- 在 js 中如果 A 对象是由 B 函数构造的,那么 ``` A.__proto__===B.prototype ``` 
  - javascript 中对象是由 Object 创建的,函数是由 Function 创建的
- 内置的 Object 其实也是一个函数对象,它是由 Function 创建的
  - ``` Object.__proto__===Function.prototype ```
- js 中每一个对象或函数都有 ``` __proto__ ``` 属性,但是只有函数对象才有 prototype 属性
  - 函数对象

    ```

      function Person(){
        //函数体
      }

    ```
  
  - 普通对象

    ```

      var obj = {}

    ```
  
  - 它们的 ``` _proto__ ``` 属性和 prototype 属性

    ```

      obj.__proto__===Object.prototype    => true
      obj.prototype===undefined   => true
      Person.__proto__===Function.prototype   => true
      Person.prototype!==undefined    => true

    ```
  
  - 原型链是基于 ``` __proto__ ``` 形成的,继承是通过 prototype 实现的
- Function.prototype 是个特例,它是函数对象,但是没有 prototype 属性,其他所有函数都有 prototype 属性
  
  ```

    Function.prototype.prototype === undefined    => true

  ```

- 内置的 Function 也是一个函数对象,它是通过自己来创建自己的

  ```

    Function.__proto__===Function.prototype   => true

  ```

- 函数也是对象,因为 ``` Function.prototype.__proto__ ``` 指向 Object.prototype

  ```

    typeof Function.prototype.__proto__ === "object"    => true
    Function.prototype.__proto__ === Object.prototype   => true

  ```

### 循环遍历的方法

#### for 循环

- Array 数组

  ```

    var arr = [1, 2, 3]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

- Object 对象: for 循环无法遍历 Object 对象
- NodeLisr 数组

  ```

    // html
    <span>1</span>
    <span>2</span>
    <span>3</span>

    // js
    var span = document.getElementsByTagName("span") 
    for(let i=0; i<span.length; i++){
      console.log(span[i].innerHTML)
    }
    // => 1 2 3

  ```

- Set 对象: for 循环无法直接遍历 Set 对象,可以先用 Array.from() 方法或者 [...] 现将 Set 对象转换成普通数组

  ```

    let set = new Set(["red", "green", "blue"])
    var arr = Array.from(set)   // 或者使用 var arr = [...set]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => red green blue

  ```

- Map

  ```

    let map = new Map([
      ["F", "no"],
      ["T", "yes"]
    ])
    var arr = [...map]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => ["F", "no"] ["T", "yes"]

  ```

- Generator 对象:先利用 Array.from 或者 [...] 方法将其转换成常规数组

  ```

    function* gen() {
      yield 1;
      yield 2;
      yield 3;
    }
    var arr = Array.from(gen())   // 或者使用 var arr = [...gen()]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

#### forEach()

- Array

  ```

    var arr = [1, 2, 3]
    arr.forEach((value, key, item) => {
      console.log(value)
    })
    // => 1 2 3

  ```

- Object: 
  - JavaScript 原生的 Object 对象无法直接使用 forEach 循环遍历,可以先借用 Object 对象的方法获取键名数组

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      // object.getOwnPropertyNames() 方法可以获取对象属性名称,并存储在数组中
      var objName = Object.getOwnPropertyNames(obj)
      objName.forEach((key) => {
        console.log(obj[key])
      })
      // => Jack 16 male

    ```
  
  - 也可以使用 Reflect 的 ownKeys() 方法,该方法还能获取到以 Symbol 为键名的键值,而上述原生的 JavaScript 方法则无法获取

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      let email = Symbol()
      obj[email] = "123@qq.com"
      // Reflect.ownKeys() 返回对象的所有属性
      var objName = Reflect.ownKeys(obj)
      objName.forEach((key) => {
        console.log(obj[key])
      })
      // => Jack 16 male 123@qq.com

    ```
  
- Set

  ```

    let set = new Set(["red", "green", "blue"])
    set.forEach((value, key, item) => {
      console.log(value)
    })
    // => red green blue

  ```
  
- Map 对象

  ```

    const map = new Map([
      ["F", "no"],
      ["T", "yes"]
    ])
    map.forEach((value, key, item) => {
      console.log(value)
      console.log(key)
    })
    // => no F yes T

  ```

- Generator 对象:先利用 Array.from 或者 [...] 方法将其转换成常规数组

  ```

    function* gen(){
      yield 1
      yield 2
      yield 3
    }
    var arr = Array.from(gen())   // 或者使用 var arr = [...gen()]
    arr.forEach((value) => {
      console.log(value)
    })
    // => 1 2 3 

  ```
  
#### for ... in

> 适用于遍历普通对象,无法遍历 Set, Map 等对象

- Array

  ```

    var arr = [1, 2, 3]
    for(let i in arr){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

- Object

  ```

    var obj = "123"
    for(let i in obj){
      console.log(obj[i])
    }
    // => 1 2 3

  ```

- Generator 对象

  ```

    function* gen(){
      yield 1
      yield 2
      yield 3
    }
    var arr = Array.from(gen())   // 或者使用 var arr = [...gen()]
    for(let i in arr){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

#### for ... of

> 可以遍历 NodeList, Map, Set, Generator 对象

- Array

  ```

    let arr = [1, 2, 3]
    for(let i of arr){
      console.log(i)
    }
    // => 1 2 3

  ```

- Object 
  - JavaScript 原生的 Object 对象无法直接使用 forEach 循环遍历,可以先借用 Object 对象的方法获取键名数组

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      // object.getOwnPropertyNames() 方法可以获取对象属性名称,并存储在数组中
      var objName = Object.getOwnPropertyNames(obj)
      for(let i of objName){
        console.log(obj[i])
      }
      // => Jack 16 male

    ```
  
  - 也可以使用 Reflect 的 ownKeys() 方法,该方法还能获取到以 Symbol 为键名的键值,而上述原生的 JavaScript 方法则无法获取

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      let email = Symbol()
      obj[email] = "123@qq.com"
      // Reflect.ownKeys() 返回对象的所有属性
      var objName = Reflect.ownKeys(obj)
      for(let i of objName){
        console.log(obj[i])
      }
      // => Jack 16 male 123@qq.com

    ```
  
  - 也可以使用 Object.keys() 方法和 Object.values() 方法遍历,但是该方法无法获取继承的属性和 Symbol 属性

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      let email = Symbol()
      obj[email] = "123@qq.com"
      // 使用 Object.keys() 方法
      var keys = Object.keys(obj)
      for(let i of keys){
        console.log(obj[i])
      }
      // => Jack 16 male
      // 使用 Object.values() 方法
      var values = Object.values(obj)
      for(let i of values){
        console.log(i)
      }
      // => Jack 16 male

    ```

- Set 对象

> Set 对象具有 keys(), value(), entries() 方法可以分别获取 Set 对象的键名,键值和键值对,结合 for...of 实现遍历

  ```

    let set = new Set(["red", "green", "blue"])
    for(let i of set){
      console.log(i)
    }
    // => red green blue

  ```

- Map 对象

> 此外, Map 对象具有 keys(), values(), entries() 方法可以分别获取 Set 对象的键名,键值和键值对,结合 for...og 实现遍历

  ```

    let map = new Map([
      ["F", "no"],
      ["T", "yes"]
    ])
    for(let i of map){
      console.log(i)
    }
    // ["F", "no"] ["T", "yes"]

  ```

- Generator 对象:只能返回 yield 的结果,无法返回 return 的结果

  ```

    function *foo(){
      yield 1
      yield 2
      yield 3
      return 4
    }
    for(let i of foo()){
      console.log(i)
    }
    // => 1 2 3

  ```

### JS 对象

> JS 中,可以将对象分为"内部对象","宿主对象"和"自定义三种"

#### 内部对象

- JS 中的内部对象包括 Arguments(函数参数集合), Array(数组), Boolean(布尔对象), Date(日期时间), Function(函数构造器), Global, Math(数学对象), Number(数值对象), Object(基础对象), RegExp(正则表达式对象), String(字符串对象) 以及各种错误类对象,包括 Error, EvalError, RangeError, ReferenceError, SyntaxError 和 TypeError;其中 Global 和 Math 这两个对象又被称为"内置对象",这两个对象在脚本程序初始化时被创建,不必实例化这两个对象

#### 宿主对象

- 宿主对象就是执行 JS 脚本的环境提供的对象,对于嵌入到网页中的 JS 来说,其宿主对象就是浏览器提供的对象,所以又被称为浏览器对象,如 IE, Firefox 等浏览器提供的对象;不同的浏览器提供的宿主对象可能不同,即使提供的对象相同,其实现方法也大相径庭,并会带来浏览器兼容问题,增加开发难度

#### 自定义对象

- 顾名思义,就是开发人员自己定义的对象; JS 允许使用自定义对象,使 JS 应用及功能得到补充

### JavaScript 实现跨域的方式

- jsonp 请求: jsonp 的原理是利用 script 标签的跨域特性,可以不受限制地从其他域中加载资源,类似的标签还有 img
- document.domain:这种方式用在主域名相同子域名不同的跨域访问中
- window.name: window 的 name 属性有个特征:在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的,每个页面对 window.name 都有读写的权限, window.name 是持久存在一个窗口载入过的所有页面中的,并不会因新页面的载入而进行重置
- window.postMessage: window.postMessage 是 html5 中实现跨域访问的一种新方式,可以使用它来向其它的 window 对象发送消息,无论这个 window 对象是属于同源或不同源
- CORS: CORS 背后的基本思想,就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是应该失败
- Web Socket: 在 JS 创建了一个 web socket 之后,会有一个 HTTP 请求发送到浏览器以发起连接,取得服务器响应后,建立的连接会使用 HTTP 升级从 HTTP 协议交换为 Web Socket 协议

### MVC 架构

> MVC 模型是一种架构型的模式,本身不引入新功能,只是帮助将开发的结构组织的更加合理,使展示与模型分离,流程控制逻辑,业务逻辑调用与展示逻辑分离

- Model(模型)
  - 应用程序中用于处理应用程序数据逻辑的部分
  - 通常模型对象负责在数据库中存取数据
  - 提供要展示的数据,因此包含数据和行为,可以认为是领域模型或 JavaBean 组件(包含数据和行为),不过现在一般都分离开来,: Value Object(数据)和服务层(行为),也就是模型提供了模型数据查询和模型数据的状态更新等功能,包括数据和业务
- View(视图)
  - 应用程序中处理数据显示的部分
  - 通常视图是依据模型数据创建的
  - 负责进行模型的展示,一般就是见到的用户界面
- Controller(控制器)
  - 应用程序中处理用户交互的部分
  - 通常控制器负责从视图读取数据,控制用户输入,并向模型发送数据
  - 接受用户请求,委托给模型进行处理(状态改变),处理完毕后把返回的模型数据返回给视图,由视图负责展示,也就是说控制器做了个调度员的工作