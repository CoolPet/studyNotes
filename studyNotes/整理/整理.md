## 面试真题 + 解析

```

  var str1 = new RegExp("e")
  document.write(str1.exec("hello"))
  以上代码输出结果为 (e)

  解析:
    exec()方法用于检索字符串中的正则表达式的匹配.
    返回值:返回一个数组,其中存放匹配的结果;如果没有找到匹配值,则返回 null
    "e".exec("hello") 中, "e" 是正则表达式, "hello" 是检索的字符串,因为 "hello" 字符串中可以匹配到 "e",所以返回结果为 e


```

```

  js 原生属性中,可以使用 element.parentNode 获取父对象.

```

```

  var A = {n: 4399}
  var B = function(){
    this.n = 9999
  }
  var C = function(){
    var n = 8888
  }
  B.prototype = A
  C.prototype = A
  var b = new B()
  var c = new C()
  A.n++
  console.log(b.n)
  console.log(c.n)
  以上代码,在浏览器中执行的结果是 (9999 4400)

  解析:
    1.首先改写 B 和 C 的原型,使它们的原型对象都指向 A,因此,B 和 C 的原型都拥有属性 n:4399
    2.通过 new 创建 B 和 C 的实例,用这个方式调用构造函数需要四步:
      a> 创建一个新的实例对象 a 和 b
      b> 将构造函数的作用域赋值给新对象(this 指向新对象 b, c);此时 B 中的 this 指向实例对象 b,即 b.n=9999
      c> 执行构造函数中的代码;给实例添加属性,此时执行 b.n=9999,为 b 添加实例属性;执行 var n=8888,对实例 c 没有影响
      d> 返回新对象;返回实例对象 b,拥有实例属性 n=9999,通过原型链,具有原型属性 n=4399;返回实例对象 c,只有原型属性 n=4399
    3.然后改写原型的属性 A.n,因为原型上的属性是公用的,所以 b 和 c 中原型上的 n 属性都为 4400,吧 还有实例属性 n=9999.由于查找属性的时候现在实例上找,再去原型中找,只要找到了就不往后面找.于是 b.n=9999(在实例中找到),c.n=4400(在原型中找到)

```

```

  x={x: 1}
  y={y: 1}
  z=1
  n="1"
  只有 z==n 的结果为 true

  解析:
    x 和 y是不同的对象，地址不同，z 和 n值同，类型不同

```

```

  页面有一个按钮 button 标签, id 为 button1,通过原生 js 禁用.
  document.getElementById(“button1”).setAttribute(“disabled”,”true”)
  document.getElementById(“button1”).disabled=true;

  解析:
    setAttribute() 方法添加指定的属性,并未其赋指定的值;如果这个指定的属性已存在,则仅设置/更改值.
    readonly 属性规定输入字段为只读,只读字段是不可修改的,但是仍然可以使用 tab 键切换到该字段,还可以选中或拷贝其文本.readonly 属性可以防止用户对值进行修改.该属性只针对 input 和 textarea 有效.
    disabled 属性用于指明按钮禁用.

```

```

  js 数组的方法中,concat() 不能改变自身数组

  解析:
    concat() 连接数组但是不改变原数组
    splice() 删除数据会改变数组
    sort() 排序会改变数组
    pop() 出栈返回最后一个最后一个元素，改变数组

```

```

  在 jquery 中想要找到所有元素的同辈元素,可以用 siblings([expr]) 进行实现

  解析:
    jquery 中的方法:
      siblings() 方法返回被选元素的所有同胞元素。
      next() 方法返回被选元素的下一个同胞元素。
      find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。

```

```

  2.toString() => Uncaught SyntaxError: Invalid or unexpected token     解析:数字后面.会被解析为小数点,变为 (2.)toString 就会报错
  2..toString() => 2    解析:因为连续的两个小数点不符合number的格式规则，第二个小数点才会被解析为调用方法
  2 .toString() => 2    解析:因为空格,所以小数点会被解析为调用方法
  (2).toString() => 2   解析:正常调用

```

```

  ul:无序列表
  dl:定义列表
  ol:有序列表
  li:定义列表项目

```

```

  css 中 clear 的作用是指明该元素周围不可出现浮动元素
  
  解析:
    清除浮动方法:
      1.给父级元素添加 class="clearflex"
      2.在 css 中给父级添加属性: overflow:hidden
      3.伪元素清除法
      4.建立空的 div,命名 clear,在 css 中添加 clear:both
    clear 属性(这个规则只能影响使用清除的元素本身,不能影响其他元素)
      1.left:在左侧不允许浮动元素
      2.right:在右侧不允许浮动元素
      3.both:在左右两侧均不允许浮动元素
      4.none:默认值,允许浮动元素出现在两侧
      5.inherit:规定应该从父元素继承 clear 属性的值

```

```

  html 注释为 <!-- -->
  css 注释为 /* */
  js 注释为:
    1> 单行注释 //
    2> 多行注释 /* */

```

```

  <head>
    <style>
      #bg{
        background-image:url("/img/bg.png")
      }
      #test{
        background-image:url("/img/test.png")
      }
    </style>
  </head>
  <body>
    <div id="test"></div>
    <img src="/img/thumbnail.png">
    <img src="/img/arrow.png" style="visibility: hidden">
  </body>
  基于以上 html 结构,浏览器共会发送 3 个图片请求

  解析:
    css 控制前端图片 http 请求的各种情况:
      1. 隐藏图片
        <img src="haorooms.jpg" style="display: none" />
        结论:只有 Opera 不产生请求
        注意:使用 visibility:hidden 隐藏图片时,在 Opera 下也会产生请求
      2. 重复图片
        <img src="haorooms.jpg" />  
        <img src="haorooms.jpg" />  
        结论:所有浏览器都只产生一次请求
      3.重复背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg) 
          }   
          .test2 { 
            background: url(haorooms.jpg) 
          }   
        </style>   
        <div class="test1">test1</div>   
        <div class="test2">test2</div>  
        结论:所有浏览器都只产生一次请求
      4.不存在的元素的背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg) 
          }   
          .test2 { 
            background: url(http2.jpg) 
          } /* 页面中没有class为test2的元素 */  
        </style>   
        <div class="test1">test1</div>  
        结论:背景仅在应用的元素在页面中存在时,才会产生请求.这对 css 框架来说,很有意义
      5.隐藏元素的背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg); 
            display: none; 
          }   
          .test2 { 
            background: url(http2.jpg); 
            visibility: hidden; 
          }   
        </style>   
        <div class="test1">test1</div>  
        结论:Opera 和 Firefox对于用 display: none 隐藏的元素背景，不会产生 HTTP 请求。仅当这些元素非 display: none 时，才会请求背景图片。
      6.多重背景
        <style type="text/css">   
          .test1 { 
            background: url(haorooms.jpg); 
          }   
          .test1 { 
            background: url(http2.jpg); 
          }   
        </style>   
        <div class="test1">test1</div>  
        上面这段代码的 http 请求，只会请求 http2.jpg 这一张图片，原因是 test1 的 class 把上面的给覆盖掉了，所有只请求后面的一张图片
        如果使用 css3 多张背景图片:
        <style type="text/css">   
          .test1 { 
            background-image:url("haorooms.jpg"),url("http2.jpg"); 
          }   
        </style>   
        <div class="test1">test1</div>  
        webkit引擎浏览器对背景图都请求，是因为支持CSS3中的多背景图。
      7.hover 的背景加载
        <style type="text/css">   
          a.test1 { 
            background: url(haorooms.jpg); 
          }   
          a.test1:hover { 
            background: url(http2.jpg); 
          }   
        </style>   
        <a href="#" class="test1">test1</a>
        结论:触发 hover 时,才会请求 hover 状态下的背景;不触发的话,只请求默认的背景图片
      8.JS 里 innerHTML 中的图片
        <script type="text/javascript">   
          var el = document.createElement('div');   
          el.innerHTML = '<img src="haorooms.jpg" />';   
          //document.body.appendChild(el);   
        </script> 
        结论:只有 Opera 不会马上请求图片
        注意:当添加到 DOM 树上时,Opera 才会发送请求
      9.图片预加载
        js 方法:
          <script type="text/javascript">   
            new Image().src = 'haorooms.jpg';   
            new Image().src = 'http2.jpg';   
          </script> 
        无 js 支持的环境下,可以采用隐藏元素来预加载:
          <img src="haoroomscom.jpg" style="visibility: hidden; height: 0; width: 0" /> 
    总结:
      1.对于隐藏图片和隐藏元素的背景,Opera 不会产生请求
      2.对于隐藏元素的背景,Firefox 也不会产生请求
      3.对于尚未插入 DOM 树的 img 元素,Opera 不会产生请求
      4.基于 webkit 引擎的 Safari 和 Chrome 支持多背景图
      5.其他情况,所有主流浏览器保持一致
      
```

```

  <form name="a">
    <select name="a" size="1" id="obj">
      <option value="a">1</option>
      <option value="b">2</option>
      <option value="c">3</option>
    </select>
  </form>
  基于以上 html 结构,可以使用 obj.options[obj.selectedIndex].text 获取表单 select 域的选择部分的文本,使用 obj.options[obj.selectIndex].value 或 obj.value 获取表单 select 域的选择部分 value

  解析:
    window.onload = function(){
      // 首先获得下拉框的节点对象
      var obj = document.getElementById("obj")
      // 获得当前选中的值
      var value = obj.value
      // 获得该下拉框所有的 option 的节点对象
      var options = obj.options   // 注意:得到的 options 是一个对象数组
      // 获得某个 option 的 value 值,比如获取第一个 option 的 value
      var value1 = options[0].value
      // 获得某个 option 的文本内容,比如获取第一个 option 的文本
      var text1 = options[0].text
      // 获得当前选中的 option 的索引
      var index = obj.selectedIndex
      // 获得当前选中的 option 的文本内容
      var selectedText = options[index].text
    }

```

```

  Number() => 0
  Number(0) => 0
  Number("") => 0
  Number("0") => 0
  Number(false) => 0
  Number(null) => 0
  Number([]) => 0
  Number([0]) => 0
  Number(undefined) => NaN
  parseInt("")  => NaN
  parseInt(null)  => NaN
  parseInt(undefined)  => NaN
  null==0 => false
  undefined==0 => false

```

```

  Canvas 对象支持所有的 JavaScript 的鼠标事件,但绘制在其中的图形并不作为其子元素存在,所以需要通过获取 Canvas 对象上的鼠标坐标来绑定事件.因此,并不能直接给 Canvas 里面的图形绑定事件
  Canvas 和 SVG 都可以使用 JavaScript 来进行绘制
  WebGL(Web 图形库)是一种 JavaScript API,用于在任何兼容的 Web 浏览器中呈现交互式 3D 和 2D 图形,而无需使用插件;WebGL 通过引入一个与 OpenGL ES 2.0 紧密相符合的 API,可以在 HTML5 的 canvas 元素中使用
  SVG 功能更完善,适合静态图片展示,高保真文档查看和打印的应用场景;Canvas 提供的功能更原始,适合像素处理,动态渲染和大数据量绘制

```

```

  (function() {
    var a = b = 5;
  })();   
  console.log(b);
  console.log(a);
  上面输出的结果: 5, Uncaught ReferenceError: a is not defined

  解析:
    a> 使用 var 操作符,定义的变量将成为该作用域中的局部变量
    b> 省略 var 操作符,会创建一个全局变量，但在局部作用域中定义的全局变量很难维护，也会由于相应变量不会马上就有定义而导致不必要的混乱，给未经声明的变量赋值在严格模式下会导致抛出 Reference 错误，所以不推荐使用。
    c> 赋值运算是把左边的值给右边，所以这个连续的赋值运算符表达式，是从右往左
    综上所述,a 为局部变量,b 为全局变量,在函数运行结束后,a 变量即被销毁.

```

```

  <html>
    <body>
      <div id="ele" class="div">
        <span id="s1" class="sp" lang="zh-cn">
        </span>
      </div>
    </body>
    <script type="text/javascript">  
      function exct() {
        var oEle = document.getElementById("ele");
        var child = oEle.children;
        console.log("ele.children的执行结果是:");
        for(i = 0; i < child.length; i++){
          console.log(child[i].tagName);
        }  
        child = oEle.childNodes;
        console.log("ele.childNodes的执行结果是:");
        for(i = 0; i < child.length; i++){
          console.log(child[i].tagName);
        }
      }  
    exct (); 
    </script>
  </html>
  上面代码的运行结果是:
    ele.children的执行结果是:
    SPAN
    ele.childNodes的执行结果是:
    undefined
    SPAN
    undefined

  解析:
    1> children 属性返回子元素的元素节点
    2> childNodes 属性返回所有的子节点,包括文本节点、注释节点、元素节点
    3> tagName 属性用来获取元素的标签名
    由此可以知道:
      oEle.children 获取的是子元素的元素节点 <span id="s1" class="sp" lang="zh-cn"></span>,在通过 tagName 获取元素的标签名,所以得到 SPAN
      oEle.childNodes 获取的是所有子节点,得到了一个 span 元素节点,还有两个文本节点:空格和换行,因此得到了三个子节点,而 tagName 用来获取的是元素的标签名,文本节点是没有标签名的,所以就为 undefined

```

```

  一个 HTML 文档内含有阿拉伯文,则应该使用 utf-8 编码

  解析:
    1> utf-8(8-bit Unicode Transformation Format, 万国码):用在网页上可以同一页面显示中文简体繁体及其它语言(如英文,日文,韩文)
    2> GBK 是汉字编码,是双字节码,可以表示繁体字和简体字
    3> ISO8859-2 字符集,也称为 Latin-2,收集了东欧字符
    4> Unicode 是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案;目前的 Unicode 字符分为17组编排,0x0000 至 0x10FFFF,每组称为平面(Plane),而每平面拥有65536个码位,共1114112个;然而目前只用了少数平面,UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案

```

```

  var datas = [10, 20, 30]
  datas.unshift(40, 50)
  datas.pop()
  datas.push(60, 70)
  datas.shift()
  console.log(datas.toString())
  上面代码执行的结果是: 50, 10, 20, 60, 70

  解析:
    var datas = [10, 20, 30]
    datas.unshift(40, 50)   // 首部添加(40, 50),得到 [40, 50, 10, 20, 30]
    datas.pop()   // 尾部删除,得到 [40, 50, 10, 20]
    datas.push(60, 70)    // 尾部添加,得到 [40, 50, 10, 20, 60, 70]
    datas.shift()   // 首部删除,得到 [50, 10, 20, 60, 70]
    console.log(datas.toString())
    a> shift() 删除数组的第一个元素,返回被删除的元素, arr.shift()
    b> unshift() 向数组开头添加一个或多个元素,返回新的长度, arr.unshift(e1, e2, ...)
    c> pop() 删除数组最后一个元素,返回被删除的元素, arr.pop()
    d> push() 向数组尾部添加一个或多个元素,返回新的长度, arr.push(e1, e2, ...)

```

```

  var foo = function(x, y){
    return x-y
  }
  function foo(x, y){
    return x+y
  }
  var num = foo(1, 2)
  以上代码运行后, num 的值是 -1

  解析:
    var foo = function(x, y){
      return x-y
    }
    function foo(x, y){
      return x+y
    }
    var num = foo(1, 2)
    会被 JavaScript 编译器解析处理为:
    // 1.变量提升
    var foo
    var num
    // 2.函数声明提升
    function foo(x, y){
      return x+y
    }
    // 3.函数表达式不会被提升
    foo = function(x, y){
      return x-y
    }
    num = foo(1, 2)
    规则:
      1> 变量声明,函数声明都会被提升到作用域顶处
      2> 当出现相同名称时,优先级为:变量声明(1) => 函数声明(2) => 变量赋值(3)
    所以 num 计算事使用的是变量赋值(3),num 的值是 -1

```

```

  在一个表单中,如果想要给输入框添加一个输入验证,可以使用 change() 事件实现.

  解析:
    a> keypress():按键事件,抬起按键时验证
    b> change():属性值改变事件,输入完后验证
    c> blur():失去焦点事件,输入框失去焦点验证
    d> focus():聚焦事件,再次进入输入框验证

```

```

  W3C 标准定义的阻止事件向父容器传递使用的是 e.stopPropagation()

  解析:
    1> DOM 中的事件对象
      a> preventDefault():取消事件默认行为
      b> stopImmediatePropagation():取消事件冒泡同时阻止当前节点上的事件处理程序被调用(会影响当前的事件侦听器)
      c> stopPropagation():取消事件冒泡对当前节点无影响(不影响当前时间侦听器)
    2> IE 中的事件对象
      a> cancelBubble():取消事件冒泡
      b> returnValue():取消事件默认行为

```

```

  将某一对象的背景色透明度改为 80% 的声明是 filter: alpha(opacity=80)

```

```

  calc()使用通用的数学运算规则,但是也提供更智能的功能:
    1> 使用 "+", "-", "*", "/" 四则运算
    2> 可以使用百分比, px, em, rem 等单位
    3> 可以混合使用各种单位进行计算
    4> 表达式中有 "+" 和 "-" 时,其前后必须要有空格
    5> 表达式中有 "*" 和 "/" 时,其前后可以没有空格
  在 CSS3 中扩展了颜色值包含 currentColor 关键字,并用于所有接受颜色的属性上.
  currentColor 是 color 属性的值: currentColor 关键字的使用值是 color 属性值的计算值.如果 currentColor 关键字被应用在 color 属性自身,则相当于是 color: inherit

```

```

  script 写在头部会导致页面加载堵塞等情况

```

```

  JavaScript 定义 var a="40",var b=7,则执行 a%b=5

  解析:
    JavaScript 是弱类型语言,但是明显字符串 "40" 不能用于 % 运算符,所以会根据后面的类型进行转化,结果为5.
    在进行算术运算中,只有 "+" 号会将数字隐式转换为字符串,其他运算符号是字符串隐式转换成数字

```

```

  var a = 4399 < 0 || typeof("4399+")
  console.log(a)
  以上 javascript 代码,在浏览器运行的结果是 string

  解析:
    运算符 "||":
      1> 只要 "||" 前面为 false,不管 "||" 后面是 true 还是 false,都返回 "||" 后面的值
      2> 只要 "||" 前面为 true,不管 "||" 后面是 true 还是 false,都返回 "||" 前面的值
    所以 4399 < 0 为false,所以返回的是后面的值为 string
    另外:在 js 逻辑运算中, 0, "", null, false, undefined, NaN 都会判断为 false,其他都为 true

```

```

  JavaScript RegExp 对象有 3 个方法:
    1> test():用来检测一个字符串是否匹配某个正则表达式,如果匹配成功,返回 true,否则返回 false
    2> exrc():用来检索字符串中与正则表达式匹配的值;exec() 返回一个数组,其中存放匹配的结果,如果未找到匹配的值,则返回 null
    3> compile():可以在脚本执行过程中编译正则表达式,也可以改变已有表达式(但是已从 Web 标准中删除)
    注:match()方法是支持正则表达式的 String 对象的方法

```

```

  函数声明:
    function sum(a, b){
      return a+b
    }
  函数表达式:
    var sum = function(a, b){
      return a+b
    }
  Function 构造函数(从技术角度讲,这是一个函数表达式):
    var sum = new Function("a", "b", "return a+b")    // 不推荐使用,影响函数解析性能

```

```

  使用 CSS 来格式化网页,共有三种方式:在 HEAD 中引用,作为标记来引用,作为文件来引用

  解析:
    样式表允许以多种方式规定样式信息,样式可以规定在单个的 HTML 元素中,在 HTML 页的头元素中,或在一个外部的 CSS 文件中;甚至可以在同一个 HTML 文档内部引用多个外部样式表:
      a> 外链样式,如:<link></link>
      b> 行内样式,如:<div style=""></div>
      c> 内联样式,如:<style></style>

```

```

  img 标签的属性:
    a> title,描述图片信息
    b> alt,规定图片的替代文本
    c> crossorigin,设置图像的跨域属性
    d> ismap,将图片规定为服务器端图像映射
    e> usemap,将图片定义为客户端图像映射

```

```

  white-space 属性(设置如何处理元素的空白):
    a> normal:默认,空白会被浏览器忽略
    b> pre:空白会被浏览器保留,其行为方式类似于 HTML 中的 pre 标签
    c> nowrap:文本不会换行,文本会在同一行上继续,直到遇到 br 标签为止
    d> pre-wrap:保留空白符序列，但是正常地进行换行
    e> pre-line:合并空白符序列，但是保留换行符
    f> inherit:规定应该从父元素继承 white-space 属性的值
  text-overflow 属性(规定当文本溢出包含元素时发生的事):
    a> clip:修剪文本
    b> elipsis:显示省略符号来代表修剪的文本
    c> string:使用给定的字符串来代表被修剪的文本
  overflow 属性(规定当内容溢出元素框时发生的事情):
    a> visible:默认值。内容不会被修剪，会呈现在元素框之外
    b> hidden:内容会被修剪，并且其余内容是不可见的
    c> scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容
    d> auto:如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容
    e> inherit:规定应该从父元素继承 overflow 属性的值

```

```

  <form class="file" name="upload">
    <input id="file" name="file" class="file" />
  </form>
  以上代码可以使用 document.getElementsByClassName("file")[1] 获取 input 节点

```

```

  当在手机中需要保存移动手机号码,通过正则表达式判断: /^1[0-9]{10}$/

  解析:
    a> ^ 匹配输入字符串的开始位置,这里也就是要求 1 开始
    b> [0-9] 匹配 0~9 之间的数字
    c> {10} 重复10次
    d> $ 匹配输入字符串的结尾位置

```

```

  <script>
    var m = 1, j = k = 0
    function add(n){
      return n = n+1
    }
    y = add(n)
    function add(n){
      return n = n+3
    }
    z = add(m)
    console.log(y, z)
  </script>
  上面代码的运行结果为 4, 4

  解析:
    js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。在js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。结合这道题来说，由于函数声明提升，所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数，所以两次调用add()返回的值是相同的。也就是y,z都为4.

```

```

  在 HTML5 中,可以使用 getCurrentPosition() 获得用户的当前位置

  解析:
    a> getCurrentPositon() 获取用户当前位置放入一个值中保存,使用 watchPosition() 函数注册监听器,在设备地理位置发生改变时自动被调用
    b> getLocation() 地图定位

```

```

  js 里的 function 能访问它们的参数,局部变量或函数,全局变量,外部函数的变量或函数

```

```

  var a = 10
  function a(){  }
  console.log(typeof a)
  上面代码运行后,控制台的输出是 number

  解析:
    函数提升优先级高于变量提升,所以代码等价于:
      function a(){  }
      var a
      a = 10
      console.log(typeof a)

```

```

  for(var i=0; i<5; i++){
    requestAnimationFrame(() => {
      console.log(i)
    })
  }
  上面代码运行后, console 输出的信息是 5 5 5 5 5(5 个 5)

  解析:
    requestAnimationFrame 并非同步执行的,所以 for 循环中的 requestAnimationFrame 会在循环退出的时候才执行其中的回调,注意循环退出的时候 i 值为 5

```

```

  for(let i=0; i<5; i++){
    requestAnimationFrame(() => {
      console.log(i)
    })
  }
  上面代码运行后, console 输出的信息是 0 1 2 3 4

```

```

  let array = [, 1, , 2, , 3]
  array = array.map((i) => {
    ++1
  })
  console.log(array)
  上面代码运行后,控制台输出的结果是 [, 2, , 3, , 4]

  解析:
    map() 会跳过空位,但是会保留这个值

```

```

  ajax 不是新的编程语言,而是一门提供网页局部刷新的技术
  ajax 最大的优点是在不重新加载整个页面的情况下,与服务器交换数据并更新部分网页内容
  ajax 技术核心是 XMLHttpRequest 对象
  ajax 技术的工作原理:
    a> 创建 ajax 对象: var xhr = new XMLHttpRequest()
    b> xhr 发送请求: xhr.open("get", "test.html", "true")
                    xhr.send()
    c> xhr 获取响应:
        xhr.onreadystatechange = function(){
          if(xhr.readystate == 4){    // 请求的状态码
            /*
              0: 请求还没有建立(open 执行前)
              1: 请求建立了还没发送(执行了 open)
              2: 请求正式发送(执行了 send)
              3: 请求已受理,有部分数据可以用,但还没处理完成
              4: 请求完全处理完成
            */
            alert(xhr.responseText)   // 返回的数据
          }
        }

```

```

  var foo = "10" + 3 - "1"
  console.log(foo)
  以上的代码运行后,控制器输出的结果是 102

  解析:
    a> "+" 的含义:
          1. 如果操作数里有一个是字符串,其他的值都将被转换成字符串
          2. 其他情况下,操作数转换成数字执行加法运算
    b> "-"的含义:只是自然的做减法,不会转换成字符串,而转换为数字

```

```

  JS 中值的类型分为原始值类型和对象类型:
    a> 原始值类型: number, string, boolean, null 和 undefined
    b> 对象类型: object
    注:原始值类型不是对象
  "hello" 和 new String("hello")的区别:
    a> "hello" 是字符串字面值,属于原始类型
    b> new String("hello") 是对象
    c> 使用 typeof 运算符返回的值也是不一样的:
      typeof "hello"    // string
      typeof new String("hello")    // object
      new String("hello") instanceof String   // true, String 对象实例化判断是否是 string 需要是用 instanceof

```

```

  var d = new Date("2018-05-09")
  将 d 设置为 6 月份可以使用 d.setMonth(5) 和 d.setDate(40)

  解析:
    d.setDate(n):
      n 表示一个月中的一天的一个数值
      0 为上一个月的最后一天
      -1 为上一个月最后一天之前的一天
    d.setMonth(month, day):
      month:必填项,表示月份的数值,该值介于 0(一月) ~ 11(十二月) 之间
      day:选填项,表示月的某一天,该值介于 1 ~ 31 之间

```

```

  HTML5 新增的表单属性: autocomplete, autofocus, form, formaction, formenctype, formmethod, formnovalidate, formtarget, height, list, max, min, multiple, pattern, placeholder, required, step, width
  HTML5 新增的表单元素: 
    a> datalist:规定输入域的选项列表
    b> keygen:提供一种验证用户的可靠方法
    c> output:用于不同类型的输出

```

```

  typeof null   // => object
  typeof undefined   // => undefined
  typeof []   // => object
  typeof 5   // => number

```

```

  label 元素:
    a> label 元素可以使用 for 属性关联表单控件,也可以将表单控件放置在它的内部  
    b> 当使用 for 属性来关联 label 元素和表单控件时, label 元素的 for 属性要和表单控件的 ID 一致

```

```

  readystatechange, DOMContentLoaded 两个事件会在页面加载完成(onload)之前触发.

  解析:
    a> readystatechange: document 有 readyState 属性来描述 document 的 loading 状态, readyState 的改变会触发 readystatechange 事件:
      1> loading 文档仍然在加载
      2> interactive 文档结束加载并且被解析,但是像图片,样式, frame 之类的子资源仍在加载
      3> complete 文档和子资源已经结束加载,该状态表明将要触发 load 事件
    因此 readystatechange 在 onload 之前触发
    b> onpageshow:
      1> onpageshow 事件在用户浏览网页时触发
      2> onpageshow 事件类似于 onload 事件, onload 事件在页面第一次加载时触发, onpageshow 事件在每次加载页面时触发,即 onload 事件在页面从浏览器缓存中读取时不触发
    c> beforeunload:当浏览器窗口,文档或其资源将要卸载时,会触发 beforeunload 事件;这个文档是依然可见的,并且这个事件在这一刻是可以取消的;如果处理函数为Event对象的returnValue属性赋值非空字符串,浏览器会弹出一个对话框,来询问用户是否确定要离开当前页面(如下示例);有些浏览器会将返回的字符串展示在弹框里,但有些其他浏览器只展示它们自定义的信息,没有赋值时,该事件不做任何响应
    d> DOMContentLoaded:当初始的 HTML 文档被完全加载和解析完成之后,DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载;另一个不同的事件 load 应该仅用于检测一个完全加载的页面。因此DOMContentLoaded是HTML完全加载和解析完成之后发生的，发生时间点要早于load;在使用 DOMContentLoaded 更加合适的情况下使用 load 是一个令人难以置信的流行错误,所以需要谨慎;
    注:DOMContentLoaded 事件必须等待其所属 script 之前的样式表加载解析完成才会触发

```

```

  css 选择器:
    a> 标签选择器:即页面中的各个标签名的 css 样式
    b> 类选择器:即定义的每个标签的 class 中的 css 样式
    c> id 选择器:即页面中的标签的 id
    d> 后代选择器(类选择器的后代选择器):即多个选择器以逗号的格式分隔,命名找到准确的标签
    e> 群组选择器:即具有相同样式的标签分组显示
  css 选择器的优先级:
    内联样式 > id 选择器 > 类选择器 > 标签选择器

```

```

  JavaScript 使用 window.open("http://www.w3school.com.cn","window2") 可以打开名为 "window2" 的新窗口

  解析:
    open() 方法可以查找一个已经存在或者新建的浏览器窗口。
      语法: window.open([url], [窗口名称], [参数字符串])
      参数说明:
        a> url:选填项,在窗口中要显示网页的网址或路径;如果省略这个参数,或者它的值是空字符串,name窗口就不显示任何文档
        b> 窗口名称:选填项,被打开窗口的名称
            1> 该名称由字母,数字和下划线字符组成
            2> "_top", "_blank", "_self" 具有特殊意义:
                1. _blank:在新窗口显示目标网页
                2. _self:在当前窗口显示目标网页
                3. _top:框架网页中在上部窗口中显示目标网页
            3> 相同 name 的窗口只能创建一个,想要创建多个窗口则 name 不能相同
            4> name 不能有空格
        c> 参数字符串:选填项,设置窗口参数,各参数用逗号隔开

```

```

  在 JavaScript 中,调用对象属性可以使用 obj["arr"], obj["a" + "r" + "r"], obj.arr

```

```

  if(! "a" in window){
    var a = 1
  }
  console.log(a)
  运行上面的代码,控制台输出结果为 undefined

  解析:
    if(! "a" in window){    // 判断全局对象 window 中是否有变量 a,由于变量的提前声明,所以 window 中就存在 a 这个变量,所以不进入
      var a = 1
    }
    console.log(a)    // 只有 window 中存在 a 这个变量,但是没有进行赋值,为 undefined

```

```

  web 表单登录中用到的图像验证码实现方式:服务器端生成验证码后一方面通过图片将验证码返回给客户端,同时在服务端保存文本的验证码,由服务端验证输入内容是否正确

```

```

  for(var i=0; i<5; ++i){
    setTimeout(function(){
      console.log(i+ " ")
    }, 100)
  }
  以上代码在控制台输出为 5 5 5 5 5

  解析:
    setTimeout() 是异步函数,只有等到主线上的任务都执行完,才会执行异步的,此时 i 已经变为 5;而且循环 5 次,异步队列中存放了五次 setTimeout(),并且按照队列的顺序依次执行,其共同访问的是同一个变量,所以结果都是 5
    使用闭包或者将全局变量变为块变量可以得到不一样的结果:
      a> 闭包
        for(var i=0;i<5;++i){
          (function(i){
            setTimeout(function(){alert(i+ ' ');},100);
          })(i)
        }
      b> 全局变量变为块变量
        for(let i=0; i<5; ++i){
          setTimeout(function(){
            console.log(i+ " ")
          }, 100)
        }

```

```

  var a = [1, 4, 5, 2, 9]
  求 a 的最大值:
  Math.max.apply(null, a)

  解析:
    Math.max() 即为求最大值的方法
    也可以写成:
      Math.max(...a)
      Math.max.call(...a)

```

```

  let x = 10
  let foo = () =>{
    console.log(x)
    let x = 20
    x++
  }
  foo()
  运行以上代码,控制台会抛出 ReferenceError
  
  解析:
    let 不同于 var:
      a> var 变量作用域为 global 或 function scope, let 可以在更小的范围内如 block scope(如 {} 括号内, for 循环内)
      b> var 变量声明后会被隐式赋值 undefined,而 let 变量声明后不会被初始化,知道显式的赋值表达式才会被初始化

```

```

  JavaScript 中数字的部分知识:
    a> JavaScript 中,由于其变量内容不同,变量被分为基本数据类型变量和引用数据类型变量;基本数据类型变量用 8 字节内存,存储基本数据类型(数字,布尔值, null 和未定义)的值,引用类型变量则只保存对对象,数组和函数等引用类型的值的引用(即内存地址)
    b> JS 中的数字是不分类型的,也就是没有 byte/int/float/double 等的差异
    c> JavaScript 内部,所有数字都是以 64 位浮点数形式储存,即使整数也是如此, 8 byte = 64 bit

```

```

  html5 新增规范的有 sessionStorage, localStorage 和 webSocket

```

```

  -moz 代表 firefox 浏览器私有属性
  -ms 代表 IE 浏览器私有属性
  -webkit 代表 chrome, safari 私有属性 IE 使用的是 Trident 内核, Firefox 使用的是 Gecko 内核;目前使用 IE 内核的浏览器还有搜狗,遨游,360等等

```

```

  console.log(1 + "2" + "2")
  console.log(1 + +"2" + "2")
  console.log("A" - "B" + "2")
  console.log("A" - "B" + 2)
  以上代码运行后,控制台输出为 122 32 NaN2 NaN

  解析:
    a> console.log(1 + "2" + "2")
       做加法时要注意双引号,当使用双引号时, JavaScript 认为是字符串,字符串相加等于字符串合并;因此,这里相当于字符串的合并,即为 122
    b> console.log(1 + +"2" + "2")
       第一个 +"2" 中的加号是一元加操作符, +"2" 会变成数值 2,因此 1 + +"2" 相当于 1+2=3,然后和后面的字符串 "2" 相合并,变成了字符串 "32"
    c> console.log("A" - "B" + "2")
       "A" - "B" 的运算中,需要先把 "A" 和 "B" 用 Number 函数转换为数值,其结果为 NaN,在减法操作中,如果有一个是 NaN,则结果是 NaN,因此 "A" - "B" 结果为 NaN,然后和 "2" 进行字符串合并,变成了 NaN2
    d> console.log("A" - "B" + 2)
       "A"-"B" 结果为 NaN,然后和数值 2 进行加法操作,在加法操作中,如果有一个操作数是 NaN,则结果为 NaN

```

```

  与其它 IEEE 754 表示浮点数的编程语言一样, JavaScript 的 number 存在精度问题,比如 0.2+0.4 的结果是 0.6000000000000001,使用  parseFloat((0.2 + 0.4).toFixed(1)) 可以得到 0.6

  解析:
    // parseFloat(),解析一个字符串,并返回一个浮点数
    // toFixed() 把数字转换为字符,结果的小数点后有指定位数的数字,按四舍五入取值
    var num = new Number(15.7857)
    var a = num.toFixed()   // 16,无参数,表示小数点后面位数为 0 位,然后四舍五入
    var b = num.toFixed(1)    // 15.8
    var c = num.toFixed(10)   // 15.7857000000,多出的补 0
    
    // toPrecision() 把数字格式化为指定长度
    var d = num.toPrecision()   // 15.7857,无参数,返回原数字
    var e = num.toPrecision(1)    // 2e+1,参数小于整数部分位数,返回科学计数
    var f = num.toPrecision(3)    // 15.8,也是有四舍五入的
    var g = num.toPrecision(10)   // 15.78570000,长度不够补 0

    // Math.round() 把一个数字舍入为最接近的整数
    var h = Math.round(num)   // 16

    // parseFloat() 解析一个字符串,并返回一个浮点数
    var i = parseFloat(num)   // 15.7857

```

```

  var foo={n:1};
  (function (foo) {
    console.log(foo.n)
    foo.n=3
    var foo={n:2}
    console.log(foo.n)
  })(foo)
  console.log(foo.n)
  以上代码运行后,在控制台输出 1 2 3

  解析:
    JavaScript 的 hoisting 机制:本质只提升声明部分
      a> 变量声明,会被提升在作用域顶端
        var a
      b> 变量定义,声明部分会提升,赋值部分不会被提升
        var b = "test"
      c> 函数定义(函数表示式),其实就是变量定义,只不过恰好被赋值的类型是函数,所以也只提升变量名,不提升函数值
        var c = function(){
          console.log("test")
        }
      d> 函数声明,所以全部被提升,包含函数名和函数体;另外,优先级比变量声明要高,名字相同的变量提升会被忽略
        function d(){
          console.log("test")
        }
      e> 参数是引用参数
        var foo={n:1};
        (function (foo) {
          console.log(foo.n)
          foo.n=3
          var foo={n:2}
          console.log(foo.n)
        })(foo)
        console.log(foo.n)
        结果为: 1 2 3
      f> 参数是传值参数
        var foo=1;  
        (function (foo) {   
            console.log(foo)
            foo=3
            var foo=2
            console.log(foo)
        })(foo)
        console.log(foo)
        结果: 1 2 1

```

```

  Math.round(-2019.5) 等于 -2019
  Math.round(11.5) + Math.round(-11.5) = 1

  解析:
    Math.round() 函数返回一个数字四舍五入后最接近的整数:
      a> 参数的小数部分大于 0.5,四舍五入到相邻的绝对值更大的整数
      b> 参数的小数部分小于 0.5,四舍五入到相邻的绝对值更小的整数
      c> 参数的小数部分等于 0.5,四舍五入到相邻的在正无穷(+∞)方向上的整数

```

```

  在 es6 中,下面程序运行结果输出:
    1. for(let i=0; i<12; i++){}
       console.log(i)   // => i is not defined
    2. const a = 12
       a = 13
       console.log(a)   // => Assignment to constant variable
    3. const g = {b: 3}
       console.log(g.b)   // => 3
       g.b = 12
       console.log(g.b)   // => 12
    4. let [head,...tail] = [1, 2, 3, 4]
       console.log(tail)    // => [2, 3, 4]
  
  解析:
    1> let 与 var 不同,let 存在块级作用域,在 for 循环中声明,循环之外销毁,所以 i not defined
    2> const 声明一个常量无法更改,所以 Assignment to constant variable(常变量赋值)
    3> const 声明的是一个常量所以是无法更改的,但是 const 出来的是一个对象的话,它的属性是可以更改的
    4> 第一个值赋给 head,其他的赋值给 tail(解构赋值)

```

```

  var i = 1
  var i = 2
  var add = function(){
    var i = 0
    return function(){
      i++
      console.log(i)
    }
  }()
  add()
  上面代码存在 3 个变量没有被回收

  解析:
    a> 全局变量 i 不会被回收,但 i=1 会被 i=2 覆盖
    b> 全局变量 add 不会被回收
    c> 闭包引用的局部变量 i 不会被回收
    d> 代码回收规则:
      1> 全局变量不会被回收
      2> 局部变量会被回收,也就是函数一旦运行结束后,函数内部的东西都会被销毁
      3> 只要被另外一个作用域引用就不会被回收

```

```

  <input type="date" name="bday"> 和 <input type="datetime-local" name="bdaytime"> 都可以用来绘制日历,样式都可以通过 css 进行修改,日历标签目前只能应用于谷歌浏览器

```

```

  var x = 0
  switch(++x){
    case 0: ++x;
    case 1: ++x;
    case 2: ++x;
  }
  执行上面的代码后, x 的值是 3

  解析:
    switch 中, x 为 1,进入 case 1, 执行 ++x 后, x = 2,因为没有 break,所以又进入 case 2,执行 ++x 后, x = 3
    a> i++ 返回原来的值, ++i 返回加 1 后的值
    b> i++ 不能作为左值,而 ++i 可以

```

```

  定义函数的方法:
    a> 函数声明(其重要特征是函数声明提升,可以把函数声明放在调用它的语句后面)
      function functionName(arg){
        // 函数体
      }
    b> 函数表达式
      var functionName = function(arg){
        // 函数体
      }
  ES6 语法定义方法:
    a> 这个语法定义的是方法(method),因为这种写法只能在 class 里生效,所以这个 function 始终是跟一个 object 有关联的
      functionName(){
        // 函数体
      }

```

```

  a> 获取所有指定类名的元素: getElementsByClassName()
    1> 定义和使用
      getElementsByClassName() 方法返回文档中所有指定类名的元素集合,作为 NodeList 对象
      NodeList 对象代表一个有顺序的节点列表, NodeList 对象可以通过节点列表中的节点索引号来访问列表中的节点(索引号由 0 开始)
    2> 提示:可以使用 NodeList 对象的 length 属性来确定指定类名的元素个数,并循环各个元素来获取需要的元素
  b> 获取所有指定标签名的对象的集合: getElementsByTagName()
    1> 说明
      getElementsByTagName() 方法返回元素的顺序是它们在文档中的顺序
      如果把特殊字符串 "*" 传递给 getElementsByTagName() 方法,它将返回文档中所有元素的列表,元素排列的顺序就是它们在文档中的顺序
  c> 获取指定 id 的第一个对象: getElementById()
    1> 说明
      HTML DOM 定义了多种查找元素的方法,除了 getElementById() 之外,还有 getElementsByClassName() 和 getElementsByTagName(),不过,如果需要查找文档中的一个特定的元素,最好使用 getElementById()
    2> 在操作文档的一个特定的元素时,最后给该元素一个 id 属性,为它指定一个(在文档中)唯一的名称,然后就可以用该 id 查找想要的元素
  d> 获取指定名称的对象:  getElementsByName()
    1> 该方法和 getElementById() 方法相似,但它查询元素的 name 属性,而不是 id 属性
    2> 因为一个文档中的 name 属性可能不唯一(如 HTML 表单中的单选按钮通常具有相同的 name 属性),所以 getElementsByName() 方法返回的是元素的数组,而不是一个元素
  e> 获取文档中匹配指定 CSS 选择器的第一个元素: querySelector()
    1> querySelector() 方法仅仅返回匹配指定选择器的第一个元素,如果需要返回所有的元素,需要使用 querySelectorAll() 方法替代

```

```
  jQuery 操作方法:
    a> text():设置或返回被选元素的文本内容
    b> :contains():选取包含指定字符串的元素
    c> :input:选取表单元素
    d> attr():设置或返回被选元素的属性值

```

```

  a> append() 方法
    1> 方法作用:向每个匹配的元素内部追加内容
    2> 参数:要追加到目标中的内容
  b> appendTo() 方法
    1> 方法作用:把所有匹配的元素追加到指定的元素集合中
    2> 参数:用于匹配元素的 jQuery 表达式

```

```

  a> Object.keys():
     该方法会返回一个由一个给定对象的自身可枚举属性组成的数组,数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致,如果对象的键/值都不可枚举,那么将返回由键组成的数组
  b> String.prototype.split():
     split() 方法使用指定的分隔符字符串将一个 String 对象分割成字符串数组,将字符串分割为子字符串,确定每个拆分的位置
  c> Array.prototype.join():
     join() 方法将一个数组(或一个类数组对象)的所有元素连接成一个字符串并返回这个字符串,如果数组只有一个项目,那么将返回该项目而不使用分隔符
  d> Promise.all():
     Promise.all() 方法返回一个 Promise 实例,该实例在参数内所有的 Promise 都"完成(resolve)"或参数中不包含 Promise 是回调完成(resolve);如果参数中 Promise 有一个失败(rejected),此实例回调失败(reject),失败原因的是第一个失败 Promise 的结果

```

```

  var str = "stiabsstringapbs"
  var obj = {}
  for (var i = 0; i < str.length; i++) {
    var key = str[i]
    if (!obj[key]) {
      obj[key] = 1
    } else {
      obj[key]++
    }
  }
  var max = -1
  var max_key = ""
  var key
  for (key in obj) {
    if (max < obj[key]) {
      max = obj[key]
      max_key = key
    }
  }
  alert("max:"+max+" max_key:"+max_key)
  上面的代码中:(1)obj 是用来统计字符数量的;(2)max 统计的是一个字符串出现次数最多的字符的次数,而 key 即是这个字符;(3)代码实现的是判断一个字符串中出现次数最多的字符,统计这个次数

  解析:
    var str = "stiabsstringapbs"    // 定义字符串
    var obj = {}    // 定义对象
    for (var i = 0; i < str.length; i++) {    // 遍历字符串
      var key = str[i]    // 存储字符
      if (!obj[key]) {    // 若对象中不存在该 key,初始化为 1
        obj[key] = 1
      } else {    // 若对象中存在该 key,则数值加 1
        obj[key]++
      }
    }
    // 第一个 for 循环结束得到每个字符数量的对象
    // obj = {a: 2, b: 2, g: 1, i: 2, n: 1, p: 1, r: 1, s: 4, t: 2}
    var max = -1    // 初始化最大数量
    var max_key = ""    // 初始化最大字符
    var key
    for (key in obj) {    // 遍历 obj 对象,获得字符最大数量及对应字符
      if (max < obj[key]) {
        max = obj[key]
        max_key = key
      }
    }
    alert("max:"+max+" max_key:"+max_key)

```

```

  var k = 0
  for(var i=0, j=0; i<10, j<6; i++, j++){
    k += i +j
  }
  console.log(k)
  上面的代码运行后,控制台输出的是 30

  解析:
    0+0+1+1+2+2+3+3+4+4+5+5=30

```

```

  var a = [1, 2, 3]
  var b = a.slice()
  b.push(4)
  console.log(a)
  上面代码运行后,控制台输出的是 [1, 2, 3]

  解析:
    slice() 是选取数组的一部分,并返回一个新的数组,不会改变原数组

```

```

  html5 的媒体标签:
    a> audio 用来嵌入音频, video 用来嵌入视频
    b> embed 定义了一个内容,用来嵌入外部应用或者互动程序(插件)
    c> source 对于定义多个数据源
    d> track 标签为媒介规定外部文本轨道,用于规定字幕文件或其它包含文本的文件,当媒介播放时,这些文件是可见的

```

```

  当使用地图进行图形搜索时,可以把一副图片从电脑拖放到地图页面的输入框里,这是运用了 HTML5 的 File API 实现的

  解析:
    文件(File)接口提供有关文件的信息,并允许网页中的 JavaScript 访问其内容;通常情况下, File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自只有拖放操作生成的 DataTransfer 对象,或者来自 HTMLCanvasElement 上的 mozGetAsFile() API

```

```

  var a = "undefined"   // 字符串
  var b = "false"   // 字符串
  var c = ""    // 空字符串
  var d = undefined   // 未定义
  var e = false   // boolean: false
  function assert(aVar){
    if(aVar)
      console.log(true)
    else
      console.log(false)
  }
  assert(a)
  assert(b)
  assert(c)
  assert(d)
  assert(e)
  上面代码运行后,控制台输出的结果: true true false false false

```

```

  typeof Date.now() 的值是: number
  
  解析:
    Date.now() 方法返回自 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的毫秒数,故为 number

```

```

  DOM 树中总共分为如下几种节点格式: Element 类型(元素节点), Text 类型(文本节点), Comment 类型(注释节点), Document 类型(document 节点)
  document 可以说是一种节点格式,但节点树的根节点也叫 document
  所有的 HTML elements(元素节点,其实就是 HTML 标签)都是 element
  comments 属于注释节点
  HTML element 内的 text 内容也就是 文本节点

```

```

  ({} + "b" > {} + "a")的返回值是 true

  解析:
    {} + "b"    => [Object Object]b
    {} + "a"    => [Object Object]a
    a> "+" 连接字符会转换为字符
    b> "+" 优先级高于 ">"
    c> ">" 运算符比较字符串大小时,会把字符串转换为 ASCII 码依次比较,b > a

```

```

  let i = 1 + {
    valueOf(){
      return 9
    }
  }
  console.log(i)    => 10
  // "+" 使得对象发生类型转换,从而调用内部的 valueOf() 方法, 1+9=10

  let i = 0
  new Array(10).forEach(() => {
    i++
  })
  console.log(i)    => 0
  // forEach() 方法在数组元素为空时会跳过执行回调函数,相对于此选项回调函数为执行,所以输出为0

  let i = parseInt('0xA')
  console.log(i)    => 10
  // 十六进制解析

  let i = 5
  function a(i){
    i *= 2
  }
  a(i)
  console.log(i)    => 5
  // a 函数没有返回值

```

```

  可以使用 css3 里 rotateY 实现翻书的效果

  解析:
    a> rotateY:定义沿 Y 轴的 3D 旋转,可实现翻书效果
    b> translateY:沿着 Y 轴移动元素
    c> scaleY:定义 2D 缩放转换时,改变元素的高度;定义 3D 缩放转换时,通过给定一个 Y 轴的值
    d> perspective(n):改变 3D 元素时怎样查看透视图(注:只影响 3D 转换元素)

```

```
  a>
    var name = "World";
    (function(){
      console.log(name)   // world
      console.log(typeof name==="undefined")    // false
      if(typeof name==="undefined"){
        console.log("Goodbye"+name)
      }else{
        console.log("hello"+name)   // hello world
      }
    })()
  
  b>
    var name = "World";
    (function(){
      console.log(name)   // undefined
      console.log(typeof name==="undefined")    // true
      if(typeof name==="undefined"){
        var name = "Jack"
        console.log("Goodbye"+name)   // Goodbye Jack
      }else{
        console.log("hello"+name)
      }
    })()

```

```

  四种 touch 事件:
    a> touchstart:手指放到屏幕上时触发
    b> touchmove:手指在屏幕上滑动时触发
    c> touchend:手指离开屏幕时触发
    d> touchcancel:系统取消 touch 事件的时候触发(比较少用)
  每个触摸事件被触发后,会生成一个 event 对象, event 对象里额外包括以下三个触摸列表:
    a> touches:当前屏幕上所有手指的列表
    b> targetTouches:当前 DOM 元素上手指的列表,尽量使用这个代替 touches
    c> changedTouches:涉及当前事件的手指的列表,尽量使用这个代替 touches

```

```

  parseInt():转换为整数,默认 10 进制
  Math.floor():向下取整
  Math.ceil():向上取整
  split():操作数必需为正则或字符串
  Math.round():将数值四舍五入为最接近的整数

```

```

  "1" === 1   => false
    "1" 是字符串 string, 1 是数字 number,类型不同, === 下比较返回 false
  isNaN(1/0)    => false
    a> 任何数值除以 0 都会导致错误而终止程序执行,但是在 JavaScript 中,会返回出特殊的值,因此不会影响程序的执行
    b> 比 0 大的数除以 0,则会得到无穷大,所以 js 用 Infinity 来显示出来
    c> 1/0 得到 Infinity, isNaN(1/0)返回的是 false,但是 isNaN(0/0)返回的是 true
  1 in [1]    => false
    a> in 操作符,对于数组属性需要指定数字形式的索引值来表示数组的属性名称(固有属性除外,如 length)
    b> 在这里, 1 in [1] 并不是表示数字 1 在不在数组里,而是表示数组中是否含有 1 这个索引 index 值
  1 && 2 > 1    => true
    1 && 2 > 1,先判断右边的表达式, 2>1 返回 true, 1 && true 返回的结果也是 true

```

```

  <div>
    <input type="button" id="button1" value="1" onclick="moveBtn(this)">
    <input type="button" id="button2" value="2">
  </div>
  <script>
    function moveBtn(obj){
      var clone = obj.cloneNode(true)   // 复制一个 button1 节点
      var parent = obj.parentNode   // 找到 button1 的父节点
      parent.appendChild(clone)   // 将复制的节点加入到子节点,也就是 button1 的复制节点现在在 button2 后面了
      parent.removeChild(obj)   // 移除原来的 button1
    }
  </script>
  上面代码运行后的效果就是将 button1 节点移动到 button2 节点后面

```

```

  a> display: block
    将元素显示为块级元素,一般是其他元素的容器,可容纳内联元素和其他块状元素,块状元素排斥其他元素与其位于同一行,宽度(width)和高度(height)起作用;常见块状元素为 div 和 p
  b> display: inline
    将元素显示为内联元素,内联元素只能容纳文本或者其他内联元素,它允许其他内联元素与其位于同一行,但宽度(width)高度(height)不起作用;常见内联元素为 a
  c> display: inline-block
    将对象呈递为内联对象,但是对象的内容作为块对象呈递,旁边的内联对象会被呈递在同一行内,允许空格(准确的说,应用此特性的元素呈现为内联对象,周围元素保持在同一行,但是可以设置宽度和高度地块元素的属性)

```

```

  var arr = [1, 2, 3]
  arr.shift()   // => arr=[2, 3]   
  arr.push(1)    // => arr=[2, 3, 1]
  arr.unshift(2)    // => arr=[2, 2, 3, 1]
  arr1 = arr.concat([1, 2])   
  console.log(arr1)   // => [2, 2, 3, 1, 1, 2]

```

```

  <html>
    <head>
      <script type="text/javascript">
        function writeIt(value){
          document.myfm.first_text.value = value
        }
      </script>
    </head>
    <body bgcolor="#ffffff">
      <form name="myfm">
        <input type="text" name="first_text">
        <input type="text" name="second_text" onchange="writeIt(value)">
      </form>
    </body>
  </html>
  上面代码的含义:
    a> 在页面的第二个文本框中输入内容后,当光标离开第二个文本框时,将在第一个文本框中复制第二个文本框的内容
    b> 在页面的第一个文本框中输入内容后,当光标离开第一个文本框时,第二个文本框的内容不变
  
  解析:
    onchange: 在域的内容发生改变时发生

```

```

  Navigator:提供有关浏览器的信息
  Window: Window 对象处于对象层次的最顶层,它提供了处理 Navigator 窗口的方法和属性
  Location:提供了与当前打开的 URL 一起工作的方法和属性,是一个静态的对象
  History:提供了与历史清单有关的信息
  Document:包含于文档元素一起工作的对象,它将这些元素封装起来供人使用

```

```

  在标准的 JavaScript 中, Ajax 异步执行调用基于 event 和 callback 机制才能实现

  解析:
    JavaScript 是单线程的,浏览器实现了异步的操作,整个 js 程序是事件驱动的,每个事件都会绑定响应的回调函数

```

```

  console.log(foo)
  var foo = 1   // 变量提升
  console.log(foo)
  foo()
  function foo(){   // 函数提升
    console.log("函数") 
  }

  // 等价于

  function foo(){
    console.log("函数")
  }
  var foo
  console.log(foo)    // 输出 foo 这个函数,因为上面 foo 没有被赋值, foo 还是原来的值
  foo = 1   // 赋值不会提升,赋值后 foo 就不再是函数类型,而是 number 类型
  console.log(foo)    // 输出 1
  foo()   // 这里会报错,因为 foo 不是函数了

  解析:
    a> 首先, js 有变量提升和函数提升,指的是用 var 声明变量或用 function 函数名(){  } 声明的,会在 js 预解析阶段提升到顶端(es6 的 let 和 const 不会提升)
    b> 其次,函数提升优先级高于变量提升 
    c> 注意:相同作用域时声明变量而不赋值还是以前的值,而子作用域声明不赋值则函数内该值为 undefined,因为声明了私有变量

```

```

  // html
  <div id="a">
    <div id="b"></div>
  </div>

  // js
  document.getElementById("a").addEventListener("click", e => {
    console.log(1)
  })
  documentById("b").addEventListener("click", e => {
    e.preventDefault()
    console.log(2)
  })
  以上代码的输出结果为: 2 1

  解析:
    e.preventDefault() 是用来阻止默认事件的,这里的 click 并没有默认事件,所以先点击的 b,其次穿透点击的 a

```

```

  优化 CSS 图片加载:
    a> CSSSprite:减少对服务器请求
    b> SVGSprite:体积小,矢量
    c> Iconfont:体积小,矢量,集成度高
    d> Base64:减少对服务器的请求

```

```

  a 元素:
    a> a 元素可以没有 href 属性,此时为超链接的一个占位符
    b> target 属性可选有: _blank, _self, framename 等值
      1> _blank:在新窗口打开链接
      2> _self:在当前框架中打开链接
      3> _parent:在父框架打开链接
      4> _top:在当前窗口打开链接
      5> framename:在指定框架打开链接
    c> rel 属性有多个值时,使用空格 "" 分割
    d> href 属性是可选的:
      1> 绝对路径
      2> 相对路径
      3> 锚

```

```

  网页 html 文档支持的图片格式有 .jpg, .gif, .png 和 .bmp 这四种, .jpg, .gif 和 .png 格式的图片特点是体积小, .bmp 这种格式虽然很清晰色彩丰富,但是所占内存很大

```

```

  list-style-type 用于设置不同列表列表项的样式
    a> 无序列表常使用
      list-style-type: circle   // 每一项前都是圆圈
      list-style-type: square   // 每一项前都是正方形
    b> 有序列表使用
      list-style-type: upper-roman   // 每一项前都是大写罗马数字
      list-style-type: lower-alpha   // 每一项前都是小写字母

```

```

  var val = 12
  function fun1(){
    console.log(val)
    var val = 20
    console.log(val)
  }
  fun1()
  上面代码运行后输出的结果是: undefined 20

  解析:
    js 里有域的概念,函数外面的是全局值,在 fun1 函数内是局部值,可以读取外部变量,但是局部域中又重新定义,就不会在读取外部,直接覆盖

```

```

  var foo = "hello";
  (function(){
    var bar = "world"
    alert(foo + bar)
  })()
  alert(foo + bar)
  其中 alert 两次输出结果为: helloworld 报错

  解析:
    a> 此函数是一个匿名自执行函数,会先调用并执行一次,即第一个 alert 输出的结果为两个字符串的拼接, helloworld
    b> 变量 bar 是函数内部声明的局部变量,外部无法调用,所有外部的 alert 会报错

```

```

  console.log(([])? true: false)
  console.log(([]==false? true: false))
  console.log(({}==false)? true: false)
  运行上面的代码,得到的结果是: true true false

  解析:
    主要考察类型转换,三元运算符先"分清是非",再决定,"=="运算符比较喜欢 Number 类型:
      Boolean([])   => true
      Number([])   => 0
      Number({})   => NaN
      Number(false)   => 0
      console.log(([])? true: false)    => console.log((true)> true: false)
      console.log(([]==false? true: false))   => console.log(0==0? true: false)
      console.log(({}==false)? true: false)   => console.log((NaN==0)? true: false)
    a> "==" 运算符(两个操作数的类型不相同时):
      1> 如果一个值是 null,另一个值是 undefined,则它们相等
      2> 如果一个值是数字,另一个值是字符串,先将字符串转换为数字,然后使用转换后的值进行比较
      3> 如果其中一个值是 true,则将其转换为 1 再进行比较;如果其中的一个值是 false,则将其转换为 0 再进行比较
      4> 如果一个值是对象,另一个值是数字或字符串,则将对象转换为原始值,在进行比较
    b> 对象到数字的转换:
      1> 如果对象具有 valueOf() 方法,后者返回一个原始值,则 JavaScript 将这个原始值转换为数字(如果需要的话)并返回一个数字
      2> 否则,如果对象具有 toString() 方法,后者返回一个原始值,则 JavaScript 将其转换并返回(对象的 toString() 方法返回一个字符串直接量(原始值), JavaScript 将这个字符串转换为数字类型,并返回这个数字)
      3> 否则,JavaScript 抛出一个类型错误异常
    c> 空数组转换为数字 0:数组继承了默认的 valueOf() 方法,这个方法返回一个对象而不是一个原始值,因此,数组到数学的转换则调用 toString() 方法;空数组转换为空字符串,空字符串转换为数字 0

```

```

  function Foo(){"use strict"
    console.log(this.location)
  }
  Foo()
  运行上面的代码后,程序会报错 TypeError

  解析:
    "use strict" 是严格模式,在严格模式下禁止 this 关键字指向全局对象,此时 this 是 undefined

```

```

  a> 局部变量:在 JavaScript 函数内部声明的变量(使用 var)是局部变量,所有只能在函数内部访问它(该变量的作用域时局部的)
  b> 全局变量:在函数外声明的变量时全局变量,网页上的所有脚本和函数都能访问它
  c> typeof:用来检测变量的数据类型
  d> new: new 是用来实例化一个对象的

```

```

  a> ajax() 方法通过 HTTP 请求加载远程数据; $.ajax(opts): opts 为 json 格式,常见参数 url, type, data 等
  b> load() 方法从服务器加载数据,并把返回的数据放入被选元素中; $(select).load( URL, data, callback);
    1> URL,必填项,规定希望加载的 URL
    2> data,选填项,规定与请求一同发送的查询字符串键/值对集合
    3> callback,选填项, load() 方法完成后所执行的函数名称
  c> $.get() 方法通过 HTTP GET 请求从服务器请求数据
    1> url,必填项,规定希望请求的 URL
    2> callback,选填项,请求成功后所执行的函数名
  d> getScript() 方法通过 HTTP GET 请求载入并执行 JavaScript
    1> jQuery.getScript(url, success(response, status))

```

```

  function test(){
    var n = 4399
    function add(){
      n++
      console.log(n)
    }
    return {n: n, add: add}
  }
  var result = test()
  var result2 = test()
  result.add()
  result.add()
  console.log(result.n)
  result2.add()
  运行上面的代码,控制台输出的是: 4400 4401 4399 4400

```

```

  在大数据量场景下, Array.join() 字符串连接方法比较高效

  解析:
    a> "+" 的处理机制:新建一个临时字符串,将新字符串赋值为 a+b,然后返回这个临时新字符串并同时销毁原始字符串,所以字符串连接效率较低
    b> array.join() 方法不会新建临时字符串效率更高

```

```

  a> array 为 js 的原生对象,它有一个静态方法: Array.isArray(),能判断参数是否为数组
    let arr = [1, 2, 3]
    Array.isArray(arr)    => true
  b> instanceof 运算符返回一个布尔值,表示对象是否为某个构造函数的实例
    let arr = [1, 2, 3]
    arr instanceof Array    => true
  c> typeof 能判断类型有: number, string, boolean, symbol, undefined, function; object, array, null 的变量都返回 object
  d> Object.prototype.toString() 为 Object 对象的实例方法,默认情况下(即不重写该方法),返回参数的类型字符串
    Object.prototype.toString.call([1, 2, 3])   => [object Array]
    Object.prototype.toString.call(1)   => [object Number]
    Object.prototype.toString.call("1")   => [object String]
    Object.prototype.toString.call(false)   => [object Boolean]
    Object.prototype.toString.call(Symbol())   => [object Symbol]
    Object.prototype.toString.call(undefined)   => [object Undefined]
    Object.prototype.toString.call(null)   => [object Null]
    Object.prototype.toString.call({a: 1})   => [object Object]
    Object.prototype.toString.call(console.log)   => [object Function]

```

```

  在 jquery 中指定一个类,如果存在就执行删除功能,如果不存在就执行添加功能,可以使用 toggleClass(class) 直接完成该功能的

  解析:
    a> toggleClass() 方法对设置或移除被选元素的一个或多个类进行切换,该方法检查每个元素中指定的类,如果不存在则添加类,如果已设置则删除,则就是所谓的切换效果
    b> removeClass() 方法从被选元素移除一个或多个类,如果没有规定参数,则该方法将从被选元素中删除所有类
    c> addClass() 方法想被选元素添加一个或多个类,该方法不会移除已存在的 class 属性,仅仅添加一个或多个 class 属性,如果需要添加多个类,需要使用空格分隔类名

```

```

  表达式 "2" + 3 + 4 的值为 "234"

  解析:
    一元操作符 "+":
      1> 运算方式
        number + number = 数值相加
        number + string = 字符串拼接
      2> 对非数值会进行函数转换 number()
        undefined = 0
        null = 0
        true = 1
        false = 0
        number = 原先的数值
        object 转为 string

```

```

  a> instanceof 运算符希望左操作数是一个对象,右操作数表示对象的类(初始化对象的构造函数),如果左侧的对象是右侧对象的实例,返回 true,否则返回 false
  b> "==="严格相等运算符:首先计算其操作数的值,然后比较这两个值,比较过程中没有任何类型转换
  c> "=="相等运算符:如果两个操作数不是同一类型,那么会尝试进行一些类型转换,然后进行比较
    1> 尽管 null 和 undefined 是不同的,但是它们都表示"值的空缺",两者往往可以互换,因此"=="运算符认为两者是相等的
    2> NaN 表示非数字值,特殊之处:它和任何值都不相等,包括自身;判断 NaN 的方法: NaN != NaN 返回 true

```

```

  function * gen(){
    yield 1
    yield 2
    yield 3
  }
  以上 ES6 代码, gen() 执行后返回一个 Generator 对象

  解析:
    这个是 ES6 的新特性, function 后面带 * 的叫做 Generator Function(生成器函数),函数运行时,返回一个迭代器

```

```

  使用 keyframes 可以实现 css3 的动画效果

  解析:
    a> transform(转换):改变元素形状,尺寸和位置
    b> transition(过渡):元素从一种样式逐渐改变为另一种的效果
    c> animation(动画):通过 CSS3 的 @keyframes(关键帧)规则,可以创建动画
    d> rotate(deg):旋转给定的度数,正值为顺时针,负值为逆时针

```

```

  调用 canvas 对象的 getContext() 方法来获取绘图环境

  解析:
    getContext() 方法返回一个用于在画布上绘图的环境
      1> 语法: Canvas.getContext(contextID)
      2> 参数: contextID 指定了想要在画布上绘制的类型,当前唯一的合法值是 "2d",它指定了二维绘图,并且导致这个方法返回一个环境对象,该对象导出一个二维绘图 API
      3> 返回值:一个 CanvasRenderingContext2D 对象,使用它可以绘制到 Canvas 元素中
      4> 描述:返回一个表示用来绘制的环境类型的环境,其本意是要为不同的绘制类型(2维, 3维)提供不同的环境;当前,唯一支持的是 "2d",它返回一个 CanvasRenderingContext2D 对象,该对象实现了一个画布所使用的大多数方法

```

```

  求数组的最大值可以使用:
    var arr = [1, 2, 3, 4]
    Math.max(arr[0], arr[1], arr[4], arr[3])    => 4
    Math.max.call(Math, arr[0], arr[1], arr[4], arr[3])   => 4
    Math.max.apply(Math, arr)   => 4

  解析:
    a> Math.max() 方法中,参数需要是 Number 类型,不能传入数组
    b> Math.max.call() 可以传入任意多个参数
    c> Math.max.apply() 第二个参数以数组形式传递

```

```

  关于原型和原型链的说法:
    a> 每个 JS 对象一定对应一个原型对象,并从原型对象继承属性和方法
    b> 对象的 __proto__ 指向自己构造函数的 prototype
    c> Object.prototype.__proto__ === null,说明原型链到 Object.prototype 终止
    d> 表达式 Function.prototype.__proto__.__proto__ === null 的运行结果为 true

```

```

  function myFunc(){
    console.log(a)
    console.log(func())
    var a = 1
    function func(){
      return 2
    }
  }
  myFunc()
  运行上面代码,控制台输出为: undefined 2

  解析:
    function myFunc(){
      console.log(a)    // a 变量提升,但是赋值在后面,打印为 undefined
      console.log(func())   // 执行函数
      var a = 1   // a 已经变量提升,但是在这里才进行赋值
      function func(){
        return 2
      }
    }

```

```

  <table border="10">
    <tr>
      <td colspan=2 aliagn="center">员工号</td>
    </tr>
    <tr> 
      <td rowspan=2 align="center">学历</td>
      <td align="center">专业</td>
    </tr>
    <tr>
      <td colspan=2 align="center">毕业学校</td>
    </tr> 
  </table>
  通过分析 HTML 代码,可以得到:
    a> 该表格中的文字居中(aliagn="center")
    b> 该表格的边框宽度为 10 毫米(border="10")
    c> "员工号"单元格跨 2 列(colspan=2)
    d> 该表格有三行两列(3个 tr, 2个 td)

```

```

  创建 Array 对象的语法:
    a> var arr = [1, 2, 3]
    b> var arr = new Array(1, 2, 3)
    c> var arr = new Array(12)    // 12 个空对象
    d> var arr = new Array(0)   // 清空数组

```

```

  Boolean 类型转换:
    a> 对于 String:只有非空字符串为真
    b> 对于 Number:除了 0 和 NaN 之外都为真
    c> 对于 Boolean: true 为真
    d> 对于 Object:除了 null 之外都为真
    e> undefined 为 false

```

```

  var f = fucntion g(){
    return 23
  }
  typeof g()
  上面代码运行后,控制台输出: ReferenceError, g is not defined

  解析:
    在 JS 里,声明函数只有 2 种方式:
      a> function foo(){ ... }    // 函数声明
      b> var foo = fucntion(){ ... }    // 等号后面必须是匿名函数,这句实质是函数表达式
      c> 类似 var foo = function bar(){ ... } 这样的函数统一按照匿名函数的方法出来,即在函数外部无法通过 bar 访问到函数,因为这个时候已经变成了一个表达式
    本题的实践:
      typeof f    => function
      typeof f()    => number
      typeof g    => undefined
      typeof g()    => ReferenceError, g is not defined

```

```

  var p1 = {
    name: "小明",
    age: "12",
    action: function(where, doing){
      console.log(this.age + "岁的" + this.name + "在" + where + doing)
    }
  }
  var p2 = {
    name: "小红",
    age: 15
  }
  console.log(p1.action.call(p2, "操场上", "运动"))
  运行上面的代码,控制台输出的结果是:15岁的小红在操场上运动

  解析:
    p1.action.call(p2, "操场上", "运动"),这里使用了 call() 函数,这个函数的第一个参数都是 this 的指向对象,所以这里 this 指向 p2,调用的 name 和 age 都需要从 p2 中获取

```

```

  this 的四种情况:
    a> 当在函数调用的时候, this 指向 window
    b> 当方法调用的时候, this 指向调用对象
    c> 当用 apply() 和 call() 上下文调用的时候, this 指向传入的第一个参数
    d> 构造函数调用时, this 指向实例对象
    e> 在全局范围内, this 指向全局对象(浏览器下指向 window)

```

```

  enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码
  属性值:
    a> application/x-www-form-urlencoded:在发送前编码所有字符(默认) 
    b> multipart/form-data:不对字符编码, 在使用包含文件上传控件的表单时,必须使用该值
    c> text/plain:空格转换为 "+" 加号,但不对特殊字符编码

```

```

  var user = {
    count: 1,
    getCount: function(){
      return this.count
    }
  }
  var func = user.getCount
  console.log(func)
  运行上面的代码,控制台输出 undefined

  解析:
    a> 调用对象未声明的属性会 undefined
      var user = {}
      console.log(user.name)    // undefined
    b> 使用为赋值只声明的基本数据类型会 undefined
      var one
      console.log(one)    // undefined
    c> 使用未声明的变量会报错
      console.log(two)    // ReferenceError: two is not defined
    d> 本题, this 的指向的是 window 对象, window 对象已经自动被浏览器声明了,只是还没有声明 count 属性,所以是 undefined


```

```

  0xff ^ 33 的结果是: 222

  解析:
    0xff: 1111 1111(255)
    33:   0010 0001(33)
    二进制异或操作:
          1101 1110(2222)

```

```

  CSS 样式, Block Element(块级元素)能够达到最大宽度,且前后各有一个换行

```

```

  function test(a){
    a = a + 10
  }
  var a = 10
  test(a)
  console.log(a)
  上述代码执行后,输出变量 a 的值为 10

  解析:
    函数中的 a 是形参,属于局部变量,不影响全局变量 a 的值,因此输出的 a 是全局变量的值
    通过值传递参数:
      a> 函数中调用的参数是函数的隐式参数
      b> JavaScript 隐式参数通过值来传递,函数仅仅只是获取值
      c> 如果函数修改参数的值,不会修改显式参数的初始值(在函数外定义)
      d> 隐式参数的改变在函数外是不可见的
      e> 所以 a 的值不会被改变,但是,如果这个地方传入的是对象,修改的是对象某个属性的值,那么就会修改 a 对象的值
    通过对象传递参数:
      a> 在 JavaScript 中,可以引用对象的值
      b> 在函数内部修改对象的属性就会修改其初始的值
      c> 修改对象属性可作用于函数外部(全局变量)
      d> 修改对象属性在函数外是可见的

```

```

  CSS 的 text-transform 属性:
    1> none,默认,定义带有小写字母和大写字母的标准的文本
    2> capitalize,文本中的每个单词以大写字母开头
    3> uppercase,定义仅有大写字母
    4> lowercase,定义无大写字母,仅有小写字母
    5> inherit,规定应该从父元素继承 text-transform 属性的值

```

```

  var obj = {}
  obj.log = console.log
  obj.log.call(console, this)
  该代码在浏览器中执行,输出的日志是 Window

  解析:
    var obj = {}
    // obj 对象中创建了一个函数(即 console.log)的引用 log,因为是这个函数的引用,如果想要执行可以有两种方法,第一种是 obj.log(),第二种是使用 apply()或者 call(),二者第一个参数都是 this 的指向,接下来的参数, apply()是参数数组或者是"arguments",而 call() 的参数是直接的参数值
    obj.log = console.log
    // call()的第二个参数是要被传入 obj.log()的参数,这行代码其实可等价于 console.log(this),而且因为这三行代码都是在 global 环境下定义的(不是函数中的局部变量),所以 this 就是 window
    obj.log.call(console, this)

```

```

  function foo(){
    console.log("first")
    setTimeout(function(){
      console.log("second")
    }, 5)
  }
  for(var i=0; i<10; i++){
    foo()
  }
  运行上面的代码,在控制台输出:首先全部输出 first,然后全部输出 second

  解析:
    js 的运行环境为单线程,定时器 setTimeout 是在规定时间后把时间加入队列,但是必须是前边时间队列无任务,否则会优先执行队列里的任务

```

```

  var obj = {}
  ......
  obj.hasOwnProperty("val")
  上面代码中的 hasOwnProperty 的作用是:判断 obj 对象是否具有 val 属性

  解析:
    a> hasOwnProperty:用来判断一个对象是否有给出名称的属性或对象,不过需要注意的是,此方法无法检查该对象的原型链中是否具有该属性,该属性必须是对象本身的一个成员
    b> isPrototypeOf:用来判断要检查其原型链的对象是否存在于指定对象实例中,是则返回 true,否则返回 false

```

```

  创建带有 id 属性的 DOM 元素会创建同名的全局变量(副作用)

  解析:
    如果一个元素拥有 id 属性,那么 id 属性的属性值就会成为 window 对象的属性名

```

```

  var foo = "foo"
  var bar = "bar"
  function myFunc(){
    return foo + bar 
  }
  myFunc()
  上面的程序运行后,返回的结果为: foobar

```

```

  var x = 10
  function cals(myNum){
    return x + myNum
  }
  cals(7)
  上面的程序运行后,返回的结果为: 17

  解析:
    var x = 10    // 全局变量
    function cals(myNum){
      console.log(x)    // 根据全局变量获取,得到的类型是 Number
      console.log(myNum)    // 根据形参的类型判断所属类型,这里是 Number
      return x + myNum    // '+'号左右两边都是 Number 类型,所以即为数字相加
    }
    cals(7)   // 7 是形参,传入的类型是 Number

```

```

  表单的描述:
    a> input 的 multiple 属性用于 select 的多选或者上传多个文件
    b> placeholder 属性可以用来提示用户输入内容的类型
    c> 用户无法直接修改包含 disabled 属性的文本框内容
    d> maxlength 属性可以限制文本框内最多输入多少个字符
    e> 表单多行输入使用 textarea 标签

```

```

  正则表达式:
    a> \w 用来匹配字母数字或下划线
    b> ? 表示匹配 0 个或 1 个
    c> i 修饰符表示忽略大小写
    d> \1 表示对第一个捕获组的引用

```

```

  var msg = "hello"
  for(var i=0; i<10; i++){
    var msg = "hello" + i*2 + i
  }
  alert(msg)
  运行上面代码, alert 输出的是: hello189

  解析:
    变量提升,导致循环里每次都是在对 msg 进行赋值操作,所以只能得到最后一次赋值的结果,然后是字符串的拼接,因为第一个是字符串,所以后面的数字也都转换为字符串,所以"+"执行的是拼接字符串

```

```

  var color = "green"
  var test4399 = {
    color: "blue",
    getColor: function(){
      var color = "red";
      alert(this.color)
    }
  }
  var getColor = test4399.getColor
  getColor()
  test4399.getColor()
  运行上面代码,浏览器输出的是: green blue

  解析:
    a> 执行 getColor() 函数时, this 的指向为 window,调用 window.color 为 green
    b> 执行 test4399.getColor() 函数时, this 的执行为 test4399, test4399.color 为 blue
  注:
    a> js 函数调用时加括号和不加括号的区别:加括号是把函数返回值赋给等号左边,不加括号相当于把函数代码赋值给等号左边
    b> js 中 this 方法, this 总是指向调用它的对象,倒数第二行的 getColor 为 window 调用的,最后一行的 getColor 是 test4399 对象调用的

```

```

  console.log(1)
  let a = setTimeout(() => {
    console.log(2)
  }, 0)
  console.log(3)
  Promise.resolve(4).then( b => {
    console.log(b)
    clearTimeout(a)
  })
  console.log(5)
  运行上面的代码,控制台输出的是: 1 3 5 4

  解析:
    a> Promise 是微任务,会在当轮事件循环结束前执行
    b> setTimeout 是宏任务,在下一轮事件循环中执行
    c> 微任务比宏任务先执行,所以取消掉定时器的回调

```

```

  有关 JavaScript 的描述:
    a> 在原型上扩展的可枚举方法,会被 for in 循环出来
    b> 使用 Object.defineProperty 可向对象添加或修改属性
    c> 创建的每一个函数都有一个 prototype(原型)属性,浏览器实现的访问对象的 [[prototype]] 内部属性的方式是 __proto__ 属性;以 null 为原型创建的对象,因为 null 没有原型对象,所以这样创建出来的对象也没有原型对象
    d> for in 循环出的属性名顺序是不可预测的,返回的先后次序会因浏览器而异
    e> 原型链是 JS 实现继承的一种模型
    f> hasOwnProperty 可判断一个对象上是否具有指定名称的属性

```

```

  手动写动画最小时间间隔是 16.7ms,因为多数显示器的默认频率是 60hz,即每秒刷新 60 次,所以理论上的最小间隔就是 1/60*1000ms = 16.7ms

```

```

  var x = new Boolean(false)
  if(x){
    alert("hi")
  }
  var y = Boolean(0)
  if(y){
    alert("hello")
  }
  上面代码运行的结果是: hi

  解析:
    var x = new Boolean(false)    // 调用构造函数返回一个对象实例, x 是一个对象,任何对象转为布尔值都为 true(在 JS 中,只有 0, -0, NaN, "", null, undefined 这六个值转布尔值结果为 false)
    if(x){
      alert("hi")
    }
    var y = Boolean(0)    // 直接函数(方法)调用,结果为 false
    if(y){
      alert("hello")
    }

```

```

  a> DHTML 的动态样式的作用:使网页作者改变内容的外部特征而不强制用户再次下载全部内容
  b> DHTML 将 HTML, JavaScript, DOM 以及 CSS 组合在一起,用于创造动态性更强的网页
  c> DHTML 能够通过 JavaScript 和 HTML DOM 能够动态改变 HTML 元素的样式
  d> DHTML 实现了网页从 web 服务器下再后无需再经过服务的处理,而在浏览器中直接动态地更新页面的内容,排版样式和动画的功能,包括:
    1> 动态内容(Dynamic Content):动态地更新网页内容,可"动态"地插入,修改或删除网页的元件,如文字,图像,标记等
    2> 动态排版样式(Dynamic Style Sheets): W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小,字形,样式,粗细,文字颜色,行高度,加底线或加中间横线,缩排,与边缘距离,靠左右或置中,背景图片或颜色等排版功能,而"动态排版样式"即可以"动态"地改变排版样式
  e> DHTML 不是 W3C 标准, DHTML 指动态 HTML(Dynamic HTML),DHTML 不是由万维网联盟(W3C)规定的标准,DHTML 是一个营销术语 ———— 被网景公司(Netscape)和微软公司用来描述 4.x 代浏览器应当支持的新技术, DHTML 是一种用来创建动态站点的技术组合物,对大多数人来说, DHTML 意味着 HTML4.0,样式表以及 JavaScript 的结合物; W3C 曾讲过:动态 HTML 是一个被某些厂商用来描述可使文档动态性更强的 HTML,样式表以及脚本的结合物的术语

```

```

  [] == true    => false, "=="是比较运算符,存在隐式类型转换, Number([]) = 0, Number(true) = 1
  !![]    => true, "!"是逻辑运算符, Boolean([]) = true, !![] = true
  NaN == NaN    => false, NaN 与任何值都不相等,包括其本身
  null == undefined   => true, "=="是比较运算符,存在隐式类型转换, Boolean(null) = false, Boolean(undefined) = 
  "foo" == new function(){ return String("foo") }   => false, String() 作为普通函数使用时,将值转为字符串,不是对象,默认返回一个空对象,原型为匿名函数的 prototype
  "foo" == new function(){ return new String("foo") }   => true, String() 作为构造函数来用的时候,返回了一个字符串包装对象

```

```

  a> input 标签的 readonly 属性:
    readonly 规定输入的字段为只读,即用户不可修改,但是用户可以通过 tab 切换到该字段,还可以选中复制该字段,可以配合 js 设置条件控制用户是否可以更改或输入内容
  b> input 标签的 step 属性:
    1> step 规定输入字段的合法数字间隔(如 step="2",则合法数字可为 -2, 0, 2, 4 等)
    2> step 属性的值为负数或 0 时,默认为 1,该属性可以配合 max, min 属性来创建合法值的范围
    3> step, max, min 属性适用于 input 标签的类型有: number, range, date, datetime, month, time, week
  c> form 标签的 enctype 属性:
    规定在发送表达数据之前如何对其编码,可取值有:
      1> application/x-www-form-urlencoded
      2> multipart/form-data
      3> text/plain
  d> form 标签的 method 属性:
    规定用于发送表单数据的 http 方法,可取值有: post 和 get
  e> video 标签, h5 新标签:
    1> 用来定义视频,电影片段或其他视频流
    2> 常用属性:
      1. autoplay(视频就绪后马上播放)
      2. control(向用户显示播放插件,如按钮)
      3. loop(循环播放)
    3> 可以为没有 control 控件属性的 video 嵌套按钮控件

```

```

  var a = "30"
  var b = 8
  console.log(a%b)
  运行上面的代码,结果为: 6

  解析:
    运算中,只有"+"号数字隐式转换为字符串,其他的运算符号都是字符串隐式转为数字

```

```

  HTML DOCTYPE 的描述:
    a> 它就是告诉浏览器文档使用哪种 html 或者 xhtml 规范
    b> 不同文档模式主要影响 css 内容的呈现,尤其是浏览器对盒模型的解析
    c> 不同浏览器在混杂模式下的行为差异非常大,如果不使用某些 hock 技术,跨浏览器的行为根本就没有一致性可言
    d> 如果在文档开始处没有发现文档类型声明,则所有浏览器都会默认开启混杂模式

```

```

  var result = "75team2017".match(/\d+\w*/g)
  上面代码运行后,得出的结果是: ["75team2017"]

  解析:
    a> \d:匹配一个数字,等阶于 [0-9]
    b> \w:匹配字母,数字或者下划线,等阶于 [A-Za-z0-9_]
    c> +:匹配前面一个表达式 1 次或者多次
    d> *:匹配前一个表达式 0 次或多次
    e> /g:全局匹配

```

```

  output(typeof (function(){ output("Hello World!") })())
  假设 output 是一个函数,输出一行文本,上面的语句输出结果是: Hello World! undefined

  解析:
    a> 先立即执行匿名函数,输出 Hello World!
    b> 函数执行后无返回值,则输出 undefined

```

```

  function A(x){
    this.x = x
  }
  A.prototype.x = 1
  function B(x){
    this.x = x
  }
  B.prototype = new A()
  var a = new A(2), b = new B(3)
  delete b.x
  console.log(a.x)
  console.log(b.x)
  上面代码运行后,控制台输出是: 2 undefined

  解析:
    a> B.prototype = new A() 将 class B 的 prototype 设置为 class A 的一个 object,这意味着用 class B 实例化出来的 object 的 prototype 就是 '{x: undefined}'; prototype 是构造函数上的一个属性(这个属性实际上就是一个对象),所有用构造函数实例化出来的对象都会继承这个 prototype
    b> var b = new B(3) 根据上面可知,属于 b 本身的是 {x: 3},但它同时继承了 '{x: undefined}',只不过 b.x == 3,是因为子类覆盖了继承而来的属性
    c> delete b.x 中 delete 删除 b 自己的属性,因此在此引用 b.x 则得到继承链上的 undefined

```

```

  CSS 的 animation-timing-function 属性:
    a> linear:动画从头到尾的速度是相同的
    b> ease:默认值,动画以低速开始,然后加快,在结束前变慢
    c> ease-in:动画以低速开始
    d> ease-out:动画以低速结束
    e> ease-in-out:动画以低速开始和结束
    f> cubic-bezier(n, n, n, n):在 cubic-bezier 函数中自己的值,可能的值是从 0 到 1 的数值

```

```

  noscript 元素用来定义在脚本未被执行时的替代内容(文本),也可以用在检测浏览器是否支持脚本,若不支持脚本则可以显示 noscript 标签里的 innerText
  noscript:用以在不支持 js 的浏览器中显示替代的内容,这个元素可以包含能够出现在文档 body 中的任何 html 元素, script 元素除外,包含在 noscript 元素的内容只有在下列情况下才会显示出来:
    a> 浏览器不支持脚本
    b> 浏览器支持脚本,但脚本被禁用

```

```

  const str = "qwbewrbbeqqbbbweebbbbqee"
  console.log(str.match(/b+/g))   // => ["b", "bb", "bbb", "bbbb"]
  console.log(str.match(/b*/g))   // => ["", "", "b", "", "", "", "bb", "", "", "", "bbb", "", "", "", "bbbb", "", "", "", ""]
  console.log(str.match(/b{1,4}/g))   // => ["b", "bb", "bbb", "bbbb"]
  console.log(str.match(/b{1,5}/g))   // => ["b", "bb", "bbb", "bbbb"]

  解析:
    a> ?:出现 0 次或 1 次   [0, 1]
    b> *:出现 0 次或多次    [0, +∞]
    c> +:出现 1 次或多次    [1, +∞]

```

```

  身份证号码的正则表达式:
    a> 18 位身份证号码:
      ^:开头
      [1-9]\d{5}: 6 位地区编码
      [1-9]\d{3}: 4 位年份
      ((0\d)|(1[0-2])): 2 位月份
      (([0|1|2]\d)|3[0-1]): 2 位日数
      \d{3}[0-9Xx]: 4 位校验码
      $:结尾
      /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}[0-9Xx]$/

```

```

  JavaScript 全局变量:
    a> decodeURI():解码某个编码的URI
    b> decodeURIComponent():解码一个编码的 URI 组件
    c> encodeURI():把字符串编码为 URI
    d> encodeURIComponent():把字符串编码为 URI 组件
    e> escape():对字符串进行编码
    f> eval():计算 JavaScript 字符串,并把它作为脚本代码来执行
    g> isFinite():检查某个值是否为有穷大的数
    h> isNaN():检查某个值是否是数字
    i> Number():把对象的值转换为数字
    j> parseInt():解析一个字符串并返回一个整数
    k> parseFloat():解析一个字符串并返回一个浮点数
    l> String():把对象的值转换为字符串
    m> unescape():对由 escape() 编码的字符串进行解码

```

```

  判断对象 myObj 是否存在的方法:
    a> !myObj   // => true
    b> !window.myObj    // => true
    c> typeof myObj == "undefined"    // => 判断对象是否有定义,如果定义了但是未赋值,返回 true
    d> myObj == undefined   // => 已定义未赋值,返回 true
    e> !this.hasOwnProperty("myObj")    // => 判断是否为顶层对象的一个属性
    f> myObj == null    => null 指的是已经赋值为 null 的空对象,即这个对象实际上是有值的,而 undefined 值的是不存在或没有赋值的对象

```

```

  表达式的值为 0:
    a> (() => {}).length    // => 获取方法形参个数,形参为 0
    b> 1 & 2    // => 换算成二进制, 1 = 0001, 2 = 0010,同为 1 才为 1,否则返回 0
    c> +[]    // => 隐式类型转换,因为 [] 是对象,所以 [] 的值为"",结果就是 1 + "" = 0
    d> [1, 2, -3].reduce((a, b) => a - b, 0)    // => reduce() 对数组中的每个元素执行一个 reduce 函数(升序执行),将其结果汇总为单个返回值, a 为累计器累计回调的返回值, b 为数组的每一项元素,传入的初始值 0 -> 0 -(1) -> (-1) -2  -> (-3) - (-3) -> 0

```

```

  var a = []    // 创建一个长度为 0 的数组,空数组
  a[5] = 4    // 数组长度自动延伸到 6,没有赋值的元素均为 undefined

```

```

  触发隐式的类型转换:
    a> parseInt(12.34, 10)
      parseInt() 函数可以解析一个字符串,并返回一个整数,所以 number 类型的 12.34 发生隐式转换变为 string
    b> 0 ? 1: 2
      三元运算符会判断 ? 前面的表达式为 true 或者 false,所以 number 类型的 0 发生了隐式转换变为了 boolean
    c> 1 + "1"
      "+"号左边为 number,右边为 string,这时左边的 number 类型的 1 发生了隐式转换变为了 string

```

```

  for(let i=0; i<2; i++){
    setTimeout(function(){
      console.log(i)
    },100)
  }
  for(var i=0; i<2; i++){
    setTimeout(function(){
      console.log(i)
    },100)
  }
  上面代码运行后,控制台输出: 0 1 2 2

  解析:
    let 作用域 for 循环的时候会绑定 i 状态值,所以定时器触发后,分别输出 0, 1 两个值; var 变量 for 循环的时候不会绑定 i 的状态值,当 i = 1 时, i < 2 成了,此时 i++, i 的值变为了 2,所以定时器触发后,分别输出的是 2, 2

```

```

  白屏时间 first paint 和可交互时间 dom ready 的关系:
    先触发 first paint,后触发 dom ready
  
  解析:
    页面的性能指标详解:
      a> 白屏时间(first Paint Time) ———— 用户从打开页面开始到页面开始有东西呈现为止
      b> 首屏时间 ———— 用户浏览器首屏内所有都呈现出来所花费的时间
      c> 用户可操作时间(dom Interactive) ———— 用户可以进行正常的点击、输入等操作,默认可以统计 dom ready 时间,因为通常会在这时绑定事件操作
      d> 总下载时间 ———— 页面所有资源都加载完成并呈现出来所花的时间,即页面 onload 的时间

```

```

  var a, b;
  (function(){
    alert(a)
    alert(b)
    var a = b = 3
    alert(a)
    alert(b)
  })()
  alert(a)
  alert(b)
  运行上面代码,结果为: undefined undefined 3 3 undefined 3

  解析:
    var a, b;
    (function(){
      alert(a)    // 先在局部没找到 a 变量,然后去全局找,找到了没有定义,输出 undefined
      alert(b)    // 先在局部没找到 a 变量,然后去全局找,找到了没有定义,输出 undefined
      var a = b = 3   // 定义一个局部变量 a = 3,然后在给全局变量 b 赋值 b = 3
      alert(a)    // 局部变量 a = 3
      alert(b)    // 全局变量 b = 3
    })()    // 函数体执行完毕,里面的内存已经被垃圾回收器回收,局部变量 a 销毁
    alert(a)    // 全局变量 a = undefined
    alert(b)    // 全局变量 b = 3

```

```

  var arr = [-1, 1, 3, 4, 6, 10]
  arr.sort((a, b) => Math.abs(a-3) - Math.abs(b-3))
  运行上面代码后, arr 的结果是: [3, 4, 1, 6, -1, 10]

  解析:
    sort() 方法用于对数组的元素进行排序,参数决定排序的顺序
      a> 原数组 var arr = [-1, 1, 3, 4, 6, 10]
      b> 参数 (a, b)  => Math.abs(a-3) - Math.abs(b-3): 即数值减 3 的绝对值 [4, 2, 0, 1, 3, 7] 作为参数决定排序
      c> 根据绝对值减 3 大小排列 [0, 1, 2, 3, 4, 7],对应的原数组排序后为 [3, 4, 1, 6, -1, 10]

```

```

  typeof 1    // => "number"
  typeof (1)    // => "number"
  typeof ()    // => SyntaxError 语法错误
  void 0    // => undefined
  void (0)    // => undefined
  void ()    // => SyntaxError 语法错误
  typeof Symbol()    // => "symbol"
  typeof Number()    // => "number"
  typeof String()    // => "string"
  typeof Function()    // => "function"
  typeof Object()    // => "object"
  typeof Boolean()    // => "boolean"
  typeof null    // => "object"
  typeof undefined    // => "undefined"

```

```

  var obj = [ ]   // 创建一个数组对象
  var obj = { }   // 创建一个对象
  var obj = / /   // 创建一个正则对象,即赋值被注释掉,及运行被结束

```

```

  null == false   // => false
  null == true    // => false
  undefined == false    // => false
  undefined == true    // => false
  undefined == null    // => true
  undefined == undefined    // => true
  null == null    // => true

```

```

  var date = new Date()   // 当日的日期和时间
  date.getDate()    // 从 Date 对象返回一个月中的某一天(1 ~ 31)
  date.getDay()   // 从 Date 对象返回一周中的某一天(0 ~ 6)
  date.getYear()    // 从 Date 对象以四位数字返回年份
  date.getTime()    // 返回 1970 年 1 月 1 日至今的毫秒数

```

```

  var i = 0
  while(i < 40){
    if(i < 30)
      continue;
      document.write("########")
      i++
  }
  分析上面代码块,一共输出 "#######": 一行也没有

  解析:
    continue 语句只能用在 while 语句, do/while 语句, for 语句,或者 for...in 语句的循环体内,在其它地方都会引起错误,是停止当前语句,并从头执行该语句
    在这里, continue 跳过本次循环,之后循环体内代码不再执行, i 永远都是 0,无限循环

```

```

  a> isNaN() 函数用来判断一个数是否是 NaN,只有一个值是 NaN 或者能被转换为 NaN 的时候才返回 true
    1> isNaN("e")   // => true,因为 e 可以被转换为 NaN
    2> isNaN("11")    // => false,因为字符串可以被转换为数字,所以不能转为 NaN
    3> isNaN(null)    // => false,因为 null 可以被转换为 0,不能转为 NaN
    4> isNaN(NaN)   // => true, NaN 返回 true
  b> parseInt(string, raix) 函数有两个参数
    1> string 是字符串只会被解析从第一个字符开始直到不是数字的字符部分
      parseInt("223")   // => 223
    2> 当字符串中间存在非数字,那么就解析前面是数字的部分字符
      parseInt("22e3")    // => 22
    3> 如果字符串中第一个字符就不是数字,那么返回 NaN
      parseInt("e23")   // => NaN
    4> parseInt() 函数的第二个参数指的就是进制,这个参数小于 2 或者大于 36 的时候,都会返回 NaN
      parseInt(1, 1)    // => NaN,因为第二个参数是 1,表示 1 进制, 1 < 2,所以错误
      parseInt(1, 2)    // => 1,因为表示二进制, 2 = 2
    5> 如果第二个参数不写的话,默认是为十进制
      parseInt(99)    // => 99
      parseInt(99, 0)    // => 99,第二个参数是用 0 的时候也是使用十进制
    6> 如果第一个参数前缀使用 0x/0X 则表示使用十六进制
      parseInt(0x99)    // => 153
      parseInt(0x99, 10)    // => 153,如果第一个参数使用 0x 表示十六进制,name第二个参数设置了值也无效

```

```

  sort() 方法用于对数组的元素进行排序,返回值在原数组商家进行排序,不生成副本
  如果调动该方法没有使用参数,将按字母顺序对数组中的元素进行排序,说的精准点,是按照字符编码的顺序进行排序,如果想按照其他标准进行排序,据需要提供比较函数,该函数要比较两个值,然后返回一个用于说明这两个值的相对顺序的数字,比较两个函数应该具有两个参数 a 和 b,其返回值如下:
    a> 若 a < b,在排序后的数组中 a 应该出现在 b之前,则返回一个小于 0 的值
    b> 若 a = b,则返回 0
    c> 若 a > b,则返回一个大于 0 的值

```

```

  JavaScript 中的可迭代对象:
    a> 数组 Array
      console.log([][Symbol.iterator])
      for(let x of ["a", "b"]){
        console.log(x)
      }
    b> 字符串 String
      console.log([][Symbol.iterator])
      for(let x of "abc"){
        console.log(x)
      }
    c> Map
      let map = new Map().set("a", 1).set("b", 2)
      console.log([][Symbol.iterator])
      for(let x of map){
        console.log(x)
      }
    d> Set
      let set = new Set().add("a").add("b")
      for(let x of set){
        console.log(x)
      }
    e> arguments
      function printArgs(){
        for(let x of arguments){
          console.log(x)
        }
      }
      printArgs("a", "b")
    f> Typed Arrays
    g> Generators, ES6 新增加

```

```

  a> max-width 指的是显示区域的宽度,比如浏览器的显示区域宽度, max-width 在窗口大小改变或横竖屏转换时会发生变化
  b> max-device-width 指的是设备整个渲染(显示)区域的宽度,比如设备的实际屏幕大小,也就是设备分辨率, max-device-width 只有设备相关,横竖屏转换或改变尺寸,缩放都不会发生变化(部分 Android 的宽度会互换, iOS 不会)
  c> max-height 指的是显示区域的高度,比如浏览器的显示区域宽度 
  d> max-device-height 指的是设备整个渲染(显示)区域的高度,比如设备的实际屏幕大小,也就是设备分辨率

```

```

  (function(){
    var x = foo()
    var foo = function foo(){
      return "foobar"
    }
    return x
  })()
  运行上面的代码后,会报出:类型错误

  解析:
    上面代码等价于: 
      (function(){
        var x
        var foo 
        x = foo()   // 程序执行到这里, foo() 未被定义为函数,所以返回 TypeError: foo is not a function
        foo = function foo(){
          return "foobar"
        }
        return x
      })()

```

```

  a> 通过使用 word-break 属性,可以让浏览器实现在任意位置的换行:
    1> normal,使用浏览器默认的换行规则
    2> break-all,允许在单词内换行
    3> keep-all,只能在半角空格或连字符处换行
  b> white-space 属性设置如何处理元素内的空白:
    1> normal,默认,空白会被浏览器忽略
    2> pre,空白会被浏览器保留,其行为方式类似 HTML 中的 pre 标签
    3> nowrap,文本不会换行,文本会在同一行上继续,直到遇到 br 标签为止
    4> pre-wrap,保留空白符序列,但是正常的进行换行
    5> pre-line,合并空白符序列,但是保留换行符
    6> inherit,规定应该从父元素继承 white-space 属性的值

```

## 补充知识点

### 静态语言（强类型语言）

静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 例如：C++、Java、Delphi、C#等。

### 动态语言（弱类型语言）

动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。

### HTML5 语义化标签

#### 优点

1. 为了在没有 css 的情况下,页面也能呈现出很好的内容结构、代码结构
2. 比 ``` <div> ``` 标签有更加丰富的含义,方便开发和维护
3. 方便搜索引擎能识别页面结构,有利于 SEO
4. 方便其他设备解析(如移动设备、盲人阅读器等)
5. 有利于合作，遵守 W3C 标准

#### 注意

1. 尽可能少的使用无语义的标签 div 和 span
2. 在语义不明显时,既可以使用 div 或者 p 时,尽量用 p,因为 p 在默认情况下有上下间距,对兼容特殊终端有利
3. 不要使用纯样式标签，如：b、font、u等，改用css设置
4. 需要强调的文本，可以包含在strong或者em标签中
5. 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td
6. 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
7. 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性

#### 1.header 与 hgroup

- 放在页面或布局的顶部,一般放置导航栏或标题
- 一个文档可以包含一对或者一对以上的 ``` <header> ``` 标签
- 如果有连续多个 h1-h6 标签就用 hgroup
- 如果有连续多个标题和其他文章数据,h1-h6 标签就用 hgroup 包住,和其他文章元数据一起放入 header 标签

#### 2.nav

- 表示页面的导航,可以在 header 标签中使用,也可以显示在侧边栏中.一个页面之中可以有多个 nav 标签
- 为了方便搜索引擎解析,最好将主要的链接放在 nav 中

#### 3.aside

- 所包含的内容不合适页面的主要内容、具有独立性,是对页面的补充
- 一般使用在页面、文章的侧边栏、广告、友情链接等区域

#### 4.footer

- 一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。一个页面也可以有多个 footer

#### 5.article

- 应该使用在相对比较独立、完整的的内容区块，所以可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用article 元素。article 可以互相嵌套。

#### 6.section

- 一组或者一节内容。
- div、section、article 三者的比较
  - div:应用广泛,任意一个区域
  - section:包含的内容时一个明确的主题,通常有标题区域
  - article:如果页面中需要一个单独的模块来实现一个单独的功能,就用 article,其他时候都用 section

#### 7.time

- 可以带格式的时间标签

#### 8.mark

- 高亮

#### 9.address

- address 代表区块容器,必须是作为联系信息出现,邮编地址、邮件地址等,一般出现在 footer 标签中

### HTML DOM 事件

HTML DOM 事件允许 Javascript 在 HTML 文档元素中注册不同事件处理程序。

事件通常与函数结合使用，函数不会在事件发生前被执行

#### 鼠标事件

```

  onclick:当用户点击某个对象时调用的事件句柄
  oncontextmenu:在用户点击鼠标右键打开上下文菜单时触发
  ondblclick	当用户双击某个对象时调用的事件句柄
  onmousedown:鼠标按钮被按下
  onmouseenter:当鼠标指针移动到元素上时触发
  onmouseleave:当鼠标指针移出元素时触发	
  onmousemove:鼠标被移动
  onmouseover:鼠标移到某元素之上
  onmouseout:鼠标从某元素移开
  onmouseup:鼠标按键被松开

```

#### 键盘事件

```

  onkeydown:某个键盘按键被按下
  onkeypress:某个键盘按键被按下并松开
  onkeyup:某个键盘按键被松开

```

#### 表单事件

```

  onblur:元素失去焦点时触发
  onchange:该事件在表单元素的内容改变时触发( <input>, <keygen>, <select>, 和 <textarea>)
  onfocus:元素获取焦点时触发
  onfocusin:元素即将获取焦点时触发
  onfocusout:元素即将失去焦点时触发
  oninput:元素获取用户输入时触发
  onreset:表单重置时触发
  onsearch:用户向搜索域输入文本时触发 (<input="search">)
  onselect:用户选取文本时触发 ( <input> 和 <textarea>)
  onsubmit:表单提交时触发

```

### Number()

#### Number() 可以用于任何数据类型的转换,转换规则如下:

- 如果是 Boolean 值,true 和 false 将分别被转换为 1 或 0
- 如果是 null 值,则返回 0
- 如果是 undefined,返回 NaN
- 如果是字符串则遵循以下规则:
  - 字符串只把含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,前导零会被忽略
  - 如果字符串中包含有效的浮点格式,则将其转换为相应的浮点数值,前导零会被忽略
  - 如果字符串是空的,则将其转换为 0
  - 如果字符串中包含除以上格式之外的字符,则将其转换为 NaN
- 如果是数值,传啥值就返回啥值
- 如果是对象,则调用对象的 valueOf() 方法,然后依照前面的规则转换返回的值;如果转换的结果是 NaN,则调用对象的 toString() 方法,然后再次按照前面的规则转换返回的字符串值

### Canvas 和 SVG

> Canvas 和 SVG 是 HTML5 中主要的 2D 图形技术，前者提供画布标签和绘制 API，后者是一整套独立的矢量图形语言，成为 W3C 标准已经有十多年(2003.1至今)，总的来说，Canvas 技术较新，从很小众发展到广泛接受，注重栅格图像处理，SVG 则历史悠久，很早就成为国际标准，复杂，发展缓慢（Adobe SVG Viewer近十年没有大的更新）

#### 适用场景

- Canvas 提供的功能更原始,适合像素处理,动态渲染和大数据量绘制
- SVG 功能更完善,适合静态图片展示,高保真文档查看和打印的应用场景

|  | Canvas | SVG |
| --- | --- | --- |
| 历史 | 较新,由 Apple 私有的技术发展而来 | 历史悠久,2003年成为 W3C 标准 |
| 功能 | 功能简单,2D 绘图 API | 功能丰富,各种图形、滤镜、动画等 |
| 特点 | 像素，只能脚本驱动 | 矢量，XML、CSS，元素操作 |
| 支持 | 主流浏览器，IE9+ | 主流浏览器，IE9+,其他 SVG 阅读器 |
| 操作对象 | 基于像素(动态点阵图) | 基于图形元素 |
| 元素 | 单个 HTML 元素 | 多种图形元素(Rect, Path, Line ...) |
| 驱动 | 只能脚本驱动 | 支持脚本和 CSS |
| 事件交互 | 用户交互到像素点(x, y) | 用户交互到图形元素(rect, path) |
| 性能 | 适合小面积,大数量应用场景 | 适合大面积,小数量应用场景 |

### BFC(块级格式化上下文)

- BFC 就是页面上的一个隔离的独立容器,容器里面的子元素不会影响到外面的元素;反之也如此.包括浮动和外边距合并等等
- display 属性为 block, list-item, table 的元素,会产生 BFC
- 给这些元素添加如下属性就可以触发 BFC:
  - float 属性不为 none
  - position 为 absolute 或 fixed
  - display 为 inline-block, table-cell, table-caption, flex, inline-flex
  - overflow 不为 visible

#### BFC 布局规则特性

- 在 BFC 中,盒子从顶端开始垂直地一个接一个地排列
- 盒子垂直方向的距离由 margin 决定,属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠
- 在 BFC 中,每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘
  - BFC 的区域不会与浮动盒子产生交集,而是紧贴浮动边缘
  - 计算 BFC 的高度时,自然也会检测浮动或者定位的盒子高度
- 它是一个独立的渲染区域,只有 Block-level box 参与,它规定了内部 Block-level Box 如何布局,并且与这个区域外部毫不相干

#### BFC 的主要用途

- 清除元素内部浮动
  - 只要把父元素设为 BFC 就可以清除元素的浮动,最常见的用法就是在父元素上设置 overflow:hidden 样式,对于 IE6 加上 zoom:1 就可以了
- 解决外边距合并问题
  - 盒子垂直方向的距离由 margin 决定;属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠,那么创建不属于同一个 BFC,就不会发生 margin 重叠了
- 制作右侧自适应的盒子问题
  - 普通流体元素 BFC 后,为了和浮动元素不产生任何交集,顺着浮动边缘形成自己的封闭上下文

### display 和 visibility 之间的区别

#### 空间占据

- display:none 是彻底消失,不在文档中占位,浏览器也不会解析该元素(回流+重绘)
- visibility:hidden 是视觉上消失了,可以理解为透明度变为0的效果,在文档流中占位,浏览器会解析该元素(重绘)
- 使用 visibility:hidden 比 display:none 性能上要好,display:none 切换显示时,页面产生回流(当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等,页面重新构建,此时就是回流;所有页面第一次加载时需要产生一次回流),而 visibility 切换是否显示时则不会引起回流

#### 子元素继承

- display:none 不会被子元素继承,但是父元素都不在了,子元素自然也就不会显示了
- visibility:hidden 会被子元素继承,可以通过设置子元素 visibility:visible 使子元素显示出来
- opacity:0 也会被子元素继承,但是不能通过设置元素 opacity:0 使其重新显示

#### 事件绑定

- display:none 的元素都已经不再页面存在了,因此肯定也无法触发它上面的绑定的事件
- visibility:hidden 元素上绑定的事件也无法触发
- opacity:0 元素上面绑定的事件是可以触发的

#### 过渡动画

- transition 对于 display 是无效的
- transition 对于 visibility 是无效的
- transition 对于 opacity 是有效的

### HTML 结构

- ``` <!Doctype html> ```   // 声明文档类型
- ``` <html></html> ```   // 整个 html 文件
- ``` <head></head> ```   // 网页的头部内容
- ``` <body></body> ```   // 网页的主题内容

### Array 对象方法

- concat():连接两个或更多的数组,并返回结果, arr1.concat(arr2)
- join():把数组的所有元素放入一个字符串,元素通过指定的分割符进行分割,并返回结果字符串, arr.join("-") 
- pop():删除并返回数组的最后一个元素, arr.pop()
- push():向数组的末尾添加一个或更多元素,并返回新的长度, arr.push(e1, e2, ...)
- reverse():颠倒数组中元素的顺序,并返回新的数组, arr.reverse()
- shift():删除并返回数组的第一个元素, arr.shift()
- slice():从某个已有的数组返回选定的元素, arr.slice(start, end), start 是必填的,是选取的位置; end 是选填,结束的位置
- sort():对数组的元素进行排序
- splice():删除元素,并向数组添加新元素,返回新的数组, arr(index, howmany, arr1), index 是必填的,规定删除或添加的位置; howmany 也是必填项,需要删除的数量; arr1 是选填项,向数组添加的新项目
- toSource():返回该对象的源代码, object.toSource()
- toString():把数组转换为字符串,并返回结果, arr.toString()
- toLocaleString():将数组转化为本地数组,并返回结果, arr.toLocaleString()
- unshift():向数组的开头添加一个或更多元素,并返回新的长度, arr.unshift()
- valueOf():返回数组对象的原始值

### javascript 模块化

> AMD 是 "Asynchronous Module Definition" 的缩写,意思就是"异步模块定义";它采用异步方式加载模块,模块的加载不影响它后面语句的运行.所有依赖这个模块的语句,都定义在一个回调函数中,等到加载完成之后,这个回调函数才会运行;AMD 也采用 require() 语句加载模块,但是不同于 CommonJS.主要有两个 Javascript 库实现了 AMD 规范:requireJS 和 curlJS

- AMD 是 requireJS 在推广过程中对模块定义的规范化产出
- CMD 是 seaJS 在推广过程中对模块定义的规范化产出
- 区别:
  - 对于依赖的模块,AMD 是提前执行,CMD 是延迟执行
  - CMD 推崇依赖就近,AMD 推崇依赖前置

### Float

#### 浮动元素定位

- 当一个元素浮动之后,它会被移出正常的文档流,然后向左或者向右平移,一直平移到碰到所处的容器的边框,或者碰到了另一个浮动的元素

#### 浮动属性

- 只有横向浮动,并没有纵向浮动
- 当元素应用了 float 属性后,将会脱离普通流,其容器(父)元素将得不到脱离普通流的子元素高度
- 会将元素的 display 属性变更为 block
  | 指定值 | 计算值 |
  | -- | -- |
  | inline | block |
  | inline-block | block |
  | inline-table | table |
  | table-row | block |
  | table-row-group | block |
  | table-column | block |
  | table-column-group | block |
  | table-cell | block |
  | table-caption | block |
  | table-header-group | block |
  | table-footer-group | block |
  | flex | flex,but float has no effect on such elements(但是 float 对这些元素没有影响) |
  | inline-flex | inline-flex,but float has no effect on such elements(但是 float 对这些元素没有影响) |
  | other | unchanged(保持不变) |
    **备注：** 如果要在 JavaScript 中通过 [element.style](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/style) 对象来修改 float 属性，那么必须使用 [element.style](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/style) 对象的 cssFloat 属性来操作。另外还要注意到在 Internet Explorer 8 和更老的 IE 当中，要使用 styleFloat 属性。这是 DOM 驼峰命名和 CSS 所用的连字符分隔命名法对应关系中的一个特例。（这么做的原因是在 JavaScript 中 "float" 是一个保留字，因为同样的原因，"class" 被改成了 "className" 、"for" 被改成了 "htmlFor"。
- 浮动元素的后一个元素会围绕着浮动元素(典型运用是文字围绕图片),与应用了 position 的元素相比浮动元素并不会遮盖后一个元素
- 浮动元素的前一个元素不会受到任何影响(如果想让两个块状元素并排显示,必须让两个块状元素都是有都应用 float)

#### 与 position 的兼容

- 元素同时应用了 position:relative, float, (top/ left/ bottom/ right) 属性后,则元素先浮动到相应的位置,然后在根据 (top/ left/ bottom/ right) 所设置的距离来发生偏移
- 元素同时应用了 position:absolute 及 float 属性,则 float 失效
- 第一个元素应用了 position 之后会覆盖着接下来的 float 元素(如果两个元素所处的位置相同)
  ```

    如果不将 float 的元素的 position 设置成 relative 的话,想通过设置 float 元素的 z-index 来达到覆盖 position:absolute 是无效的.同理,float 元素下面存在 position:absolute 的子元素,如果不将 float 的元素的 position 设置成 relative 的话, absolute 元素是不会定位到 float 元素的

  ```
- 浮动元素在浮动的时候,其 margin 不会超过包含块的 padding,浮动元素的浮动位置不能超过包含块的内边界;浮动元素 margin 和父元素的 padding 不会合并(正常情况下也不会合并)

#### 浮动元素的延伸性

- 元素被设置成浮动后,该元素会进行延伸进而包含其所有浮动的元素;比如父元素不是浮动的,子元素浮动,子元素比较高,则子元素会超过父元素高度,如果父元素设计了 float 属性,则会包裹所有子元素

#### 浮动元素重叠问题

- 行内元素与浮动元素发生重叠,其边框,背景和内容都会显示在浮动元素之上
- 块级元素与浮动元素发生重叠,边框和背景会显示在浮动元素之下,内容会显示在浮动元素之上

#### 常见的清除浮动的方法

- 通过在容器中添加一个标签,设置该标签的样式为 clear:both
- 容器设置 overflow:hidden 或者 auto

### Javascript 异步编程的 4 种方法 

> JavaScript 语言的执行环境是"单线程"(single thread) ———— 一次只能完成一件任务;如果有多个任务,就必须排队,前面一个任务完成,在执行后面一个任务,以此类推.这种模式的好处是实现起来比较简单,执行环境相对单纯;坏处是只要有一个任务耗时长,后面的任务都必须排队等着,会拖延整个程序的执行.常见的浏览器无响应(假死),往往就是因为某一段 JavaScript 代码长时间运行(比如死循环),导致整个页面卡在这个地方,其他任务无法执行

#### 同步(Synchronous)和异步(Asynchronous)

- 同步:后一个任务等待前一个任务结束,然后在执行,程序的执行顺序与任务的排列顺序是一致的,同步的
- 异步:每一个任务有一个或多个回调函数,前一个任务结束后,不是执行后一个任务,而是执行回调函数,后一个任务则不等前一个任务结束就执行,所以程序的执行顺序与任务的排列顺序是不一致的,异步的
- **重点:**异步模式非常重要.在浏览器端,耗时很长的操作都应该异步执行,避免浏览器失去响应,最好的例子就是 Ajax 操作.在服务器端,"异步模式"甚至是唯一的模式,因为执行环境是单线程的,如果允许同步执行所有 http 请求,服务器性能会急剧下降,很快就会失去响应

#### 异步编程的 4 种方法

- 回调函数:
  - 这是异步编程最基本的方法
  - 优点:简单,容易理解和部署
  - 缺点:不利于代码的阅读和维护,各个部分之间高度耦合(Coupling),流程会很混乱,而且每个任务只能指定一个回调函数
- 事件监听:
  - 任务的执行不取决于代码的顺序,而取决于某个事件是否发生
  - 优点:比较容易理解,可以绑定多个事件,每个事件可以指定多个回调函数,而且可以"去耦合(Decoupling)",有利于实现模块化
  - 缺点:整个程序都要变成事件驱动型,运行流程会变得很不清晰
- 发布/订阅:
  - 假定存在一个"信号中心",某个任务执行完成,就向信号中心"发布(publish)"一个信号,其他任务可以向信号中心"订阅(subscribe)"这个信号,从而知道什么时候自己可以开始执行.这就是"发布/订阅模式(publish-subscribe pattern)",又称为"观察者模式(observer pattern)"
  - 这种方法的性质与"事件监听"类似,但是明显优于后者.因为可以通过查看"消息中心",了解存在多少信号,每个信号有多少订阅者,从而监控程序的运行
- Promise 对象:
  - 是 CommonJS 工作组提出的一种规范,目的是为异步编程提供统一接口.
  - 简单的说,每一个异步任务返回一个 Promise 对象,该对象有一个 then 方法,允许指定回调函数;回调函数变成了链式写法,程序的流程可以看得很清楚,而且有一整套的配套方法,可以实现很多强大的功能

### 集合转化为数组

- Array.form(arr, mapfn, thisArg):可以把对象转换为真正的数组,类似数组的对象和可遍历的对象(部署了 Iterator 接口的, String, ES6 新增的 Map 和 Set).可以传 3 个参数,其中第一个是数组,必填项;第二个是一个函数(类似 map 函数),对数组元素进行操作后再返回数组,选填项;第三个是对于 this 关键字的指向,选填项
- slice():从已有的数组中返回选定的元素,返回一个新的数组,包含从 start 到 end (不包括该元素)的 arrayObject 中的元素
  - 注意:该方法并不会修改数组,而是返回一个子数组.如果想要删除数组中的一段元素,应该使用方法 array.splice()
  - 在这里就是对集合应用 slice(),返回一个新的数组,不对数组做任何改变
- ...:展开运算符,把集合的元素展开后,用数组 [] 承载,返回新的数组
- map():返回一个新数组,数组中的元素为原始数组元素调用函数处理后的值
  - map() 方法按照原始数组元素顺序依次处理元素
  - map() 不会对空数组进行检测
  - map() 不会改变原始数组

### bootstrap

#### 工作原理

- bootstrap 框架的网络系统工作原理:
  - 数据行(.row)必须包含在容器(.container)中,以便为其赋予合适的对齐方式和内边距(padding).如:

    ```

      <div class="container">
        <div class="row"></div>
      </div>

    ```

  - 在行(.row)中可以添加列(.column),但列数之和不能超过平分的总列数 12.如:

    ```

      <div class="container">
        <div class="row">
          <div class="col-md-4"></div>
          <div class="col-md-8"></div>
        </div>
      </div>

    ```

  - 具体内容应该放置在列容器(column)之内,而且只有列(column)才可以作为行容器(.row)的直接子元素
  - 通过设置内边距(padding),从而创建列与列之间的间距.然后通过为第一列和最后一列设置负值的外边距(margin)来抵消内边距(padding)的影响

#### 栅格参数

<table style="text-align:center">
  <tr>
    <th></th>
    <th>超小屏幕(<768px),手机</th>
    <th>小屏幕(≥768),平板</th>
    <th>中等屏幕(≥992px),桌面显示器</th>
    <th>大屏幕(≥1200px),大桌面显示器</th>
  </tr>
  <tr>
    <td>栅格系统行为</td>
    <td>总是水平排列</td>
    <td colspan="3">开始是堆叠在一起的,当大于这些阈值时将变为水平排列 </td>
  </tr>
  <tr>
    <td>.container 最大宽度</td>
    <td>None(自动)</td>
    <td>750px</td>
    <td>970px</td>
    <td>1170px</td>
  </tr>
  <tr>
    <td>类前缀</td>
    <td>.col-xs-</td>
    <td>.col-sm-</td>
    <td>.col-md-</td>
    <td>.col-lg-</td>
  </tr>
  <tr>
    <td>列数</td>
    <td colspan="4">12</td>
  </tr>
  <tr>
    <td>最大列宽</td>
    <td>自动</td>
    <td>~62px</td>
    <td>~81px</td>
    <td>~97px</td>
  </tr>
  <tr>
    <td>槽宽</td>
    <td colspan="4">30px(每列左右具有 15px)</td>
  </tr>
</table>

### 关于 DOM 事件流, DOM0级事件与 DOM2级事件

#### DOM 事件模型

- DOM 事件模型包括捕获和冒泡,捕获是从上往下到达目标元素,冒泡是从当前元素,也就是目标元素往上到 window

#### 流

- 流的概念,在现今的 JavaScript 中随处可见.比如说  React 的单向数据流, Node 中的流,还有 DOM 事件流,都是流的一种生动体现
- 用术语说流就是对输入输出设备的抽象;以程序的角度说,流是具有方向的数据

#### 事件流

- 事件流所描述的就是从页面中接受事件的顺序,事件流分为两种:事件冒泡(主流)与事件捕获
  - 事件冒泡:事件开始时由具体元素接收,然后逐级向上传播到父元素
  - 事件捕获:父元素的节点更早接收事件,而具体元素最后接收事件,与事件冒泡相反

#### DOM 事件流

- DOM 事件流包括三个阶段
  - 事件捕获阶段:当事件发生时，首先发生的是事件捕获，为父元素截获事件提供了机会
  - 处于目标阶段:事件到了具体元素时，在具体元素上发生，并且被看成冒泡阶段的一部分
  - 事件冒泡阶段:最后，冒泡阶段发生，事件开始冒泡

#### 阻止事件冒泡

- 事件冒泡过程,是可以被阻止的.防止事件冒泡而带来不必要的错误和困扰
- 使用 stopPropagation() 阻止:事件在到达具体元素后，停止了冒泡，但不影响父元素的事件捕获

#### DOM0级事件

- DOM0级事件,就是直接通过 onclick 等方式实现相应的事件
  - 标签内写 onclick 事件
  - 在 JS 中使用 onclick = function(){}
- 这说明 DOM0级添加事件时,后面的事件会覆盖前面的事件,而 DOM2级则不会,多个事件都会执行;另外,DOM0级事件具有很好的跨浏览器优势,会以最快的速度绑定,但由于绑定速度太快,可能页面还未完全加载出来,以至于事件可能无法正常运行

#### DOM2级事件

- DOM2级事件的方法
  - 主流浏览器 DOM2级事件是通过以下两个方法用于出来指定和删除事件处理程序的操作:
    - addEventListener():为指定元素附加指定事件处理程序而不会覆盖已有的事件处理程序
    - removeEventListener():删除事件监听器
- DOM2级事件的使用
  - 所有的 DOM 节点都包含这两个方法,使用方法如下:
    - target.addEventListener(type, listener[, useCapture])
    - target.removeEventListener(type, listener[, useCapture])
    - 它们都接受三个参数:
      - type:事件类型,如 "click", "mouseover", "mouseout",在事件名前不加 "on"
      - listener:事件处理方法
      - useCapture:布尔参数,不传该参数时默认是 false,表示在事件冒泡阶段处理,如果是 true,则表示在捕获阶段调用事件处理程序
  - 注意:只有 DOM2级事件包含以下三个阶段
    - 事件捕获阶段
    - 处于目标阶段
    - 事件冒泡阶段

### a 标签不跳转的 3 种方法

- onclick 事件中返回 false
  ```

    <a href="http://www.baidu.com" onclick="return false">百度(不能跳转)</a>

  ```
- 用 href="javascript:void(0)" 这种伪协议(伪协议少写)
  ```

    <a href="javascript:void(0)">不能跳转</a>

  ```
- 使用(#)
  ```

    <a href="#" onclick="del()">删除</a>    // 总是跳转到当前页面,当前页面内容多的话,还是会有跳转的感觉,不推荐使用

  ```

### JavaScript 保留关键字

#### JavaScript 保留关键字

- JavaScript 的保留关键字不可以用作变量,标签或者函数名;有些保留关键字是作为 JavaScript 以后扩展使用

  |  |  |  |  |  |
  | -- | -- | --| -- | -- |
  | abstract | arguments | boolean | break | byte |
  | case | catch | char | class | const |
  | continue | debugger | default | delete | do |
  | double | else | enum | eval | export |
  | extends | false | final | finally | float |
  | for | function | goto | if | implements |
  | import | in | instanceof | int | interface |
  | let | long | native | new | null |
  | package | private | protected | public | return |
  | short | static | super | switch | synchronized |
  | this | throw | throws | transient | true |
  | try | typeof | var | void | volatile |
  | while | with | yield |

#### JavaScript 对象,属性和方法

- 也应该避免使用 JavaScript 内置的对象,属性和方法的名称作为 JavaScript 的变量或函数名:

  |  |  |  |  |  |
  | -- | -- | --| -- | -- |
  | Array | Date | eval | function | hasOwnProperty |
  | Infinity | isFinite |	isNaN |	isPrototypeOf |	length |
  | Math | NaN | name |	Number | Object |
  | prototype |	String | toString |	undefined |	valueOf |

### CSS3 新增属性

- box-shadow:阴影效果
- border-color:为边框设置多种颜色
- border-image:图片边框
- text-shadow:文本阴影
- text-overflow:文本截断
- word-wrap:自动换行
- border-radius:圆角边框
- opacity:透明度
- box-sizing:控制盒模型的组成模式
- resize:元素缩放
- outline:外边框
- background-size:指定背景图片尺寸
- background-origin:指定背景图片从哪里开始显示
- background-clip:指定背景图片从什么位置开始裁剪
- background:为一个元素指定多个背景
- hsl:通过色调、饱和度、亮度来指定颜色颜色值
- hsla:在hsl的基础上增加透明度设置
- rgba:基于rgb设置颜色，a设置透明度

### call(), apply() 和 bind() 方法的用法以及区别

> call(), apply() 和 bind() 的作用是改变函数运行时 this 的指向

#### 函数的调用方法

- 方法调用模式
  - 当一个函数被保存为对象的一个方法时,如果调用表达式包含一个提取属性的动作,那么它就是被当做一个方法来调用,此时的 this 被绑定到这个对象

    ```

      var a = 1
      var obj1 = {
        a: 2,
        fn: function(){
          console.log(this.a)
        }
      }
      obj1.fn()   // 2

      // 此时的 this 是指向 obj1 这个对象, obj1.fn() 实际上是 obj1.fn.call(obj1),事实上谁调用此函数, this 的指向就是谁.

    ```

  - DOM 对象绑定事件也属于方法调用模式,因此它绑定的 this 就是事件源 DOM 对象

    ```

      document.addEventListener("click", function(e){
        console.log(this)   // document
        setTimeout(function(){
          console.log(this)   // window
        }, 200)
      }, false)

      // 点击页面监听 click 事件属于方法调用,this 指向事件源 DOM 对象,即 obj.fn.apply(obj), setTimeout 内的函数属于回调函数,所以 this 指向 window

    ```

- 函数调用模式:就是普通函数的调用,此时的 this 被绑定到 window
  - 最普通的函数调用

    ```

      function fn1(){
        console.log(this)
      }
      fn1()   // window

    ```

  - 函数嵌套

    ```

      function fn1(){
        function fn2(){
          console.log(this)
        }
        fn2()
      }
      fn1()   // window

    ```
  
  - 把函数赋值之后再调用

    ```

      var a = 1
      var obj1 = {
        a: 2,
        fn: function(){
          console.log(this.a)
        }
      }
      var fn1 = obj1.fn
      fn1()   // 1

      // obj1.fn 是一个函数 function(){ console.log(this.a) },此时 fn1 就是不带任何修饰的函数调用, function(){console.log(this.a)}.call(undefined),按理说打印出来的 this 应该就是 undefined,但是浏览器里有一条规则:如果传的 context 为 null 或者 undefined,那么 window 对象就是默认的 context(严格模式下默认 context 是 undefined);因此上面的 this 绑定时 window,也被称为隐形绑定.

    ```
  
  - 回调函数

    ```

      var a = 1
      function f1(fn){
        fn()
        console.log(a)
      }
      f1(f2)    // 1
      function f2(){
        var a = 2
      }

      // 可以写成

      var a = 1
      function f1(){
        (function (){
          var a = 2
        })
        console.log(a)
      }
      f1()    // 1

      // 这仍然是最普通的函数调用, f1.call(undefined), this 指向 window,打印出来的是全局的 a.
      // 这就可以知道 setTimeout 总是丢失 this,因为它也是一个回调函数
      setTimeout(function(){
        console.log(this)   // window
        function fn(){
          console.log(this)   // window
        }
        fn()
      }, 0)

    ```

- 构造器调用模式
  - new 一个函数时,背地里会将创建一个连接到 prototype 成员的新对象,同时 this 会被绑定到那个新对象上

    ```

      function Person(name, age){
        // 这里的 this 指向实例
        this.name = name 
        this.age = age
        this.sayAge = function(){
          console.log(this.age)
        }
      }
      var dot = new Person("Dot", 2)
      dot.sayAge()    // 2

    ```

#### call()

- call() 方法第一个参数是要绑定给 this 的值,后面传入的是一个参数列表;当第一个参数为 null, undefined 的时候,默认指向 window

  ```

    var arr = [1, 2, 3, 89, 46]
    var max = Math.max.call(null, arr[0], arr[1], arr[2], arr[3], arr[4])
    console.log(max)    // 89

    // 可以理解为

    obj1.fn()
    obj1.fn.call(obj1)

    fn1()
    fn1.call(null)

    f1(f2)
    f1.call(null, f2)

  ```

#### apply()

- apply() 接受两个参数,第一个参数是要绑定给 this 的值,第二个参数是一个参数数组;当第一个参数为 null, undefined 的时候,默认指向 window

  ```

    var arr = [1, 2, 3, 89, 46]
    var max = Math.max.apply(null, arr)
    console.log(max)    // 89

    // 可以理解为

    obj1.fn() 
    obj1.fn.apply(obj1);

    fn1()
    fn1.apply(null)

    f1(f2)
    f1.apply(null,f2)

  ```

- 事实上 apply() 和 call() 的用法几乎相同,唯一的差别在于:当函数需要传递多个变量时,apply() 可以接受一个数组作为参数输入,call() 则是接受一系列的单独变量

#### bind()

- bind() 和 call() 很相似,第一个参数是 this 的指向,从第二个参数开始是接收的参数列表;区别在于:bind() 返回值是函数以及 bind() 接收的参数列表的使用
  - bind() 返回值是函数

    ```

      var obj = {
        name: "Dot"
      }

      function printName(){
        console.log(this.name)
      }

      var dot = printName.bind(obj)
      console.log(dot)    // function printName(){ console.log(this.name) }
      dot()   // Dot

      // bind() 方法不会立即执行,而是返回一个改变了上下文 this 后的函数;而原函数 printName 中的 this 并没有被改变,依旧指向全局对象 window

    ```

  - 参数的使用

    ```

      function fn(a, b, c){
        console.log(a, b, c)
      }
      var fn1 = fn1.bind(null, "Dot")

      fn("A", "B", "C")   // A B C
      fn1("A", "B", "C")    // Dot A B
      fn1("B", "C")   // Dot B C
      fn.call(null, "Dot")    // Dot undefined undefined

      // call() 是把第二个及以后的参数作为 fn 方法的实参传进去，而 fn1 方法的实参实则是在 bind() 中参数的基础上再往后排。

    ```

#### 应用场景

- 求数组中的最大和最小值

  ```

    var arr = [1, 2, 3, 89, 46]
    var max = Math.max.apply(null, arr)
    var min = Math.min.apply(null, arr)
    console.log(max)    // 89
    console.log(min)    // 1

  ```

- 将类数组转化为数组

  ```

    var trueArr = Array.prototype.slice.call(arrayLike)
  
  ```

- 数组追加

  ```

    var arr1 = [1, 2, 3]
    var arr2 = [4, 5, 6]
    var total = [].push.apply(arr1, arr2)
    console.log(arr1)   // [1, 2, 3, 4, 5, 6]
    console.log(arr2)   // [4, 5, 6]
    console.log(total)    // 6

  ```

- 判断变量类型

  ```

    function isArray(obj){
      return Object.prototype.toString.call(obj) == "[object Array]"
    }
    console.log(isArray([]))    // true
    console.log(isArray("dot"))    // false

  ```

- 利用 call() 和 apply() 做继承

  ```

    function Person(name, age){
      // 这里的 this 都指向实例
      this.name = name
      this.age = age
      this.sayAge = function(){
        console.log(this.age)
      }
    }
    function Female(){
      Person.apply(this, arguments)   // 将父元素所有方法在这里执行一遍就继承了
    }
    var dot = new Female("Dot", 2)

  ```

- 使用 log 代理 console.log

  ```

    function log(){
      console.log.apply(console, arguments)
    }

    // 当然也有更方便的 var log = console.log.bind()

  ```

#### 总结

- call(), apply() 和 bind() 函数存在的区别:
  - bind() 返回对应函数,便于稍后调用;apply(), call() 则是立即调用
  - 在 ES6 箭头函数下,call() 和 apply() 将失效,对于箭头函数来说:
    - 箭头函数内的 this 对象,就是定义时所在的对象,而不是使用时所在的对象;所以不需要类似于 var _this = this 这种丑陋写法
    - 箭头函数不可以当作构造函数,也就说不可以使用 new 命令,否则会抛出一个错误
    - 箭头函数不可以使用 arguments 对象,该对象在函数体内不存在;如果要用,可以用 Rest 参数代替
    - 不可以使用 yield 命令,因此箭头函数不能用作 Generator 函数

### 改变作用域链的三种方法

#### eval()

- eval() 函数可计算某个字符串,并执行其中的 JavaScript 代码
  - 返回值:通过计算 string 得到的值
  - 说明:
    - 该方法只接受原始字符串作为参数,如果 string 参数不是原始字符串,那么该方法将不作任何改变地返回;因此请不要为 eval() 函数传递 String 对象来作为参数
    - 如果试图覆盖 eval 属性或把 eval() 方法赋予另一个属性,并通过该属性调用它,则 ECMAScript 实现允许抛出一个 EvalError 异常
    - 如果字符串中有新定义函数,那么它就有可能再建一个执行环境
  - 抛出:
    - 如果参数中没有合法的表达式和语句,则抛出 SyntaxError 异常
    - 如果非法调用 eval(),则抛出 EvalError 异常
    - 如果传递 eval() 的 JavaScript 代码生成了一个异常, eval() 将把该异常传递给调用者

#### with()

- with 语句用于设置代码在特定对象中的作用域;将会指定的对象添加到作用域中
  
  ```

    var sMessage = "hello"
    with(sMessage){
      alert(toUpperCase())    // 输出 "HELLO"
    }

  ```

#### try-catch

- try-catch 中的 catch 块,会创建一个新的变量对象,其中包含的是被抛出的错误对象的声明

#### 总结

- 执行环境的类型只有两种:全局函数和局部函数;但是还有其他办法来延长作用域链
- 有些语句可以在作用域链的前端临时增加一个变量对象,该变量对象会在代码执行后被移除
- 在两种情况下会发生这种现象,具体来说,就是当执行流进入下列任何一个语句时,作用域链就会得到加强:
  - try-catch 语句的 catch 块
  - with 语句

### JS 基本数据类型

> JS 基本有 6 种简单数据类型: String, Number, Boolean, Null, undefined, symbol(ES6 新增);一种复杂的数据类型(引用数据类型) Object

- String(字符串)
  - 字符串可以使用 "" 赋值,也可以使用 '' 赋值
  - 将其他数据类型转换为 String 类型,可以使用 String() 和 toString() 这两个方法的区别是 String() 可以转任何类型,而 toString() 方法不能转 Null, undefined 两种类型
- Number(数字)
  - 将数字开头的字符串中提取数字使用 parseInt() 和 parseFloat()
- Boolean(布尔值)
  - 将其他数据类型转换为 Boolean 类型使用 Boolean() 方法
  - Number 的值为 0 返回 false,其他的返回为 true;字符串只赋值为 "" 返回为 false,其他返回为 true
- Null(空)
- undefined(未定义)

### Ajax 和 Flash 的区别

- Ajax 的优势
  - 可搜索性
    - 普通的文本网页会更有利于 SEO;文本内容是搜索引擎容易检索的，而繁琐的 SWF 字节码却是搜索引擎不愿触及的。虽然 Google 等一些大型的搜索引擎可以检索 SWF 内部的内容，但是仍然有很多麻烦存在
  - 开放性
    - Flash 常年以来被 Macromedia 看的很死;包括 Flex, FMS 等辅佐技术一直都需要昂贵的安装和维护费用;而 JS 则没有这样的麻烦,没有人愿意承担法律和版权的风险
  - 费用
    - Flash 开发是很昂贵的,因为 FlashID 等环境都是要收费的;而 Ajax 则不同,虽然有一些便宜的生成 SWF 的工具,但是它们的功能实在无法满足复杂需求
  - 易用性
    - Ajax 程序有更好的易用性,由于中间有一层 Flashplayer 代理层,因此许多辅助功能无法被 Flash 灵活利用;而且 Flash 在一些方面有着不好的口碑,比如弹出广告,恶意代码
  - 易于开发
    - 人们开发复杂的 Ajax 和 Flash 应用程序时,都会借助一些高级的开发工具;普遍来说, Ajax 的开发包比 Flash 简便,容易
- Flash 的优势
  - 多媒体处理
    - Flash 在音频、视频等多媒体领域相比 HTML 有绝对的优势。现在几乎所有的网站都包含有 Flash 内容
  - 兼容性
    - 由于通过了唯一的 FlashPlayer “代理”。不必像调试JS那样，在不同的浏览器中调试程序
  - 矢量图形
    - 这是 Flash 最大的优势，同样处在这一领域的 SVG, Canvas element 以及 Direct 完全不能与 Flash 相比
  - 客户端资源调度
    - Flash 能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的 HTML 无法完成的
- Ajax 的劣势
  - 它可能破坏浏览器的后退功能   
  - 使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中,不过这些都有相关方法解决
- Flash 的劣势
  - 二进制格式 
  - 格式私有 
  - flash 文件经常会很大,用户第一次使用的时候需要忍耐较长的等待时间  
  - 性能问题

### 前端性能优化 ———— reflow(回流)和 repaint(重绘)

> 在浏览器的整个渲染过程中(页面初始化,用户行为改变页面样式,动画改变界面样式等)reflow(回流)和 repaint(重绘)会大大影响 web 性能,尤其是手机页面;所以在页面设计的时候要尽量减少 reflow 和 repaint

#### 概念

- reflow
  - 例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流
  - 回流基本上是无法避免的.现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着
- repaint
  - 如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint(重绘);repaint 的速度明显快于 reflow

#### 导致 reflow 发生的情况

- 改变窗口大小
- 改变文字大小
- 内容的改变,如用户在输入框中输入
- 激活伪类,如 hover
- 操作 class 属性
- 脚本操作 DOM
- 计算 offsetWidth 和 offsetHeight
- 设置 style 属性

#### 减少 reflow 的方式

- 不要通过父级来改变元素样式,最好直接改变子元素样式,改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸
- 尽量通过 class 来设计元素样式,切忌在通过脚本改变 style
- 实现元素的动画,对应经常要进行回流的组件,要抽离出来,它的 position 属性应当设为 fixed 或 absolute
- 权衡速度的平滑,比如实现一个动画,以 1 像素为单位移动这样最平滑,但 reflow 就会过于频繁, CPU 很快就会被完全占用;如果以 3 个像素为单位移动就会好很多
- 不要用 tables 布局的另一个原因就是 tables 中某个元素一旦触发 reflow 就会导致 tables 里所有的其他元素 reflow;在适合用 table 的场合,可以设置 table-layout 为 auto 或 fixed
- 这样可以让 table 一行一行的渲染,这种做法也是为了限制 reflow 的影响范围
- css 里不要有表达式 expression
- 减少不必要的 DOM 层级,改变 DOM 树中的一级会导致所有层级的改变,上至根部,下至被改变节点的子节点,这导致大量时间耗费在执行 reflow 上面
- 避免不必要的复杂的 CSS 选择器,尤其是后代选择器,因为为了匹配选择器将耗费更多的 CPU
- 尽量不要过多的频繁的去增加,修改,删除元素,因为这可能会频繁的导致页面 reflow,可以先把该 DOM 节点抽离到内存中进行复杂的操作,然后在 display 到页面上
- 请求如下值: offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop, scrollLeft, scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth, clientHeight,浏览器会发生 reflow,建议将它们合并到一起操作,可以减少 reflow 的次数

### position 属性

> position 属性规定元素的定位类型

- absolute:生成绝对定位的元素,相对于 static 定位以外的第一个父元素进行定位
- fixed:生成绝对定位的元素,相对于浏览器窗口进行定位
- relative:生成相对定位的元素,相对于其正常位置进行定位
- static:默认值,没有定位,元素出现在正常的流中
- inherit:规定应该从父元素继承 position 属性的值

### link 与 @import 的区别

- link 是 XHTML 标签,除了加载 css 外,还可以定义 RSS 等其他事务; @import 属于 CSS 范畴,只能加载 CSS
- link 引用 CSS 时,在页面载入时同时加载; @import 需要页面网页完全载入以后加载
- link 是 XHTML 标签,无兼容问题; @import 是在 CSS2.1 提出的,低版本浏览器不支持
- link 支持使用 JavaScript 控制 DOM 去改变样式;而 @import 不支持

### Promise 对象

#### 概述

- Promise 对象是 JavaScript 的异步操作解决方案,为异步操作提供统一接口;它起到代理作用(proxy),充当异步操作与回调函数之间的中介,使得异步操作具备同步操作的接口;Promise 可以让异步操作写起来,就像在写同步操作的流程,而不必一层层地嵌套回调函数
- Promise 是一个对象,也是一个构造函数

  ```

    function f1(resolve, reject){
      // 异步代码...
    }
    var p1 = new Promise(f1)
    // 上面代码中, Promise 构造函数接受一个回调函数 f1 作为参数, f1 里面是异步操作的代码,然后返回的 p1 就是一个 Promise 实例

    // Promise 的设计思想:所有异步任务都返回一个 Promise 实例. Promise 实例有一个 then 方法,用来指定下一步的回调函数

    p1.then(f2)
    // 上面代码中, f1 的异步操作执行完成,就会执行 f2

    // 传统写法可能需要把 f2 作为回调函数传入 f1(f2),异步操作完成后,在 f1 内部调用 f2;Promise 使得 f1 和 f2 变成了链式写法.不仅改善了可读性,而且对于多层嵌套的回调函数尤其方便
    // 传统写法
    step1(function (value1) {
      step2(value1, function(value2) {
        step3(value2, function(value3) {
          step4(value3, function(value4) {
            // ...
          })
        })
      })
    })
    // Promise 的写法
    (new Promise(step1))
      .then(step2)
      .then(step3)
      .then(step4)
    // 从上面的代码可以看到,采用 Promise 以后,程序流程变得非常清楚,十分易读
 
  ```

- 总的来说,传统的回调函数写法使得代码混成一团,变得横向发展而不是向下发展;而 Promise 就是解决这个问题,使得异步流程可以写成同步流程
- Promise 原本只是社区提出的一个构想,一些函数库率先实现了这个功能, ECMAScript6 将其写入语言标准,目前 JavaScript 原生支持 Promise 对象

#### Promise 对象的状态

- Promise 对象通过自身的状态,来控制异步操作; Promise 实例具有三种状态:
  - pending(异步操作未完成)
  - fulfilled(异步操作成功)
  - rejected(异步操作失败)
- fulfilled 和 rejected 合在一起称为 resolved(已定型)
- Promise 对象的状态变化途径只有两种:
  - "未完成" => "成功"
  - "未完成" => "失败"
- 一旦状态发生变化,就凝固了,不会再有新的状态变化,这也是 Promise 名字的由来,它的名字的意思是承诺",一旦承诺成效,就不得再改变了,这也意味着 Promise 实例的状态变化只可能发生一次
- Promise 的最终结果只有两种:
  - 异步操作成功, Promise 实例传回一个值(value),状态变为 fulfilled
  - 异步操作失败, Promise 实例抛出一个错误(error),状态变为 rejected

#### Promise 构造函数

- JavaScript 提供原生的 Promise 构造函数,用来生成 Promise 实例

  ```

    var promise = new Promise(function(resolve, reject){
      // ...

      if(/* 异步操作成功 */){
        resolve(value)
      }else{  /* 异步操作失败 */
        reject(new Error())
      }
    })
    // 上面代码中, Promise 构造函数接受一个函数作为参数,该函数的两个参数分别是 resolve 和 reject;它们是两个函数,由 JavaScript 引擎提供,不用自己实现

  ```

- resolve 函数的作用是将 Promise 实例的状态从"未完成"变为"完成"(即从 pending 变为 fulfilled),在异步操作成功时调用,并将异步操作的结果作为参数传递出去
- reject 函数的作用是将 Promise 实例的状态从"未完成"变为"失败"(即从 pending 变为 fulfilled),在异步操作失败时调用,并将异步操作报出的错误作为参数传递出去

```

  function timeout(ms){
    return new Promise((resolve, reject) => {
      setTimeout(resolve, ms, "done")
    })
  }
  timeout(100)
  // 上面代码中, timeout(100) 返回一个 Promise 实例,在 100 毫秒后,该实例的状态会变为 fulfilled

```

#### Promise.prototype.then()

> Promise 实例的 then 方法,用来添加回调函数

- then 方法可以接受两个回调函数,第一个是异步操作成功时(变为 fulfilled 状态)时的回调函数,第二个是异步操作失败(变为 rejected)时的回调函数(该参数可以省略);一旦状态改变,就调用相应的回调函数

  ```

    var p1 = new Promise(function (resolve, reject){
      resolve("成功")
    })
    p1.then(console.log)    // 成功

    var p2 = new Promise(function (resolve, reject){
      reject("失败")
    })
    p2.catch(console.log)   // 失败
    // 上面代码中, p1 和 p2 都是 Promise 实例,它们的 then 方法绑定两个回调函数:成功时在 then 调用回调函数 console.log,失败时在 catch 中调动回调函数 console.log; p1 的状态变为成功, p2 的状态变为失败,对应的回调函数会受到异步操作传回的值,然后在控制台输出

  ```

- then 方法可以链式使用

  ```

    p1.then(step1)
      .then(step2)
      .then(step3)
      .then(
        console.log
      ).catch(
        console.log
      )
    // 上面代码中, p1 后面有四个 then 和一个 catch,意味着依次有四个回调函数,只要前一步的状态变为 fulfilled,就会依次执行紧跟在后面的回调函数
    // 最后一个 catch 方法,可以显示 p1, step1, step2, step3 之间任意一个发生的错误,如果 step1 的状态变为 rejected,那么 step2 和 step3 都不会执行了(因为它们是 resolve 的回调函数); Promise 开始寻找,接下来第一个为 rejected 的回调函数,这就是说, Promise 对象的报错具有传递性

  ```

#### then() 用法辨析

- Promise 的用法,简单说就是:使用 then 方法添加回调函数;但是不同的写法有一些差别

  ```

    // 写法一
    f1().then(function(){
      return f2()
    })

    // 写法二
    f1().then(function(){
      f2()
    })

    // 写法三
    f1().then(f2())

    // 写法四
    f1().then(f2)

    // 这四种写法再用 then 方法接一个回调函数 f3
    // 写法一:f3 回调函数的参数是 f2 函数的运行结果
    f1().then(function(){
      return f2()
    }).then(f3)

    // 写法二:f3 回调函数的参数是 undefined
    f1().then(function(){
      f2()
      return
    }).then(f3)

    // 写法三:f3 回调函数的参数是 f2 函数返回的函数的运行结果
    f1().then(f2())
      .then(f3)

    // 写法四:f3 回调函数的参数是 f2 函数的运行结果,但是 f2 会接收到 f1() 返回的结果
    f1().then(f2)
      .then(f3)

  ```

#### Promise 的实例

##### 加载图片

```

  // 图片的加载
  var preloadImage = function (path) {
    return new Promise(function (resolve, reject) {
      var image = new Image()
      image.onload  = resolve
      image.onerror = reject
      image.src = path
    })
  }

```

##### ajax 操作

```

  // ajax 操作时典型的异步操作
  // 传统写法
  function search(term, onload, onerror) {
    var xhr, results, url;
    url = 'http://example.com/search?q=' + term

    xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)

    xhr.onload = function (e) {
      if (this.status === 200) {
        results = JSON.parse(this.responseText)
        onload(results)
      }
    }
    xhr.onerror = function (e) {
      onerror(e)
    }
    xhr.send()
  }
  search('Hello World', console.log, console.error)

  // Promise 写法
  function search(term) {
    var url = 'http://example.com/search?q=' + term
    var xhr = new XMLHttpRequest()
    var result
    var p = new Promise(function (resolve, reject) {
      xhr.open('GET', url, true)
      xhr.onload = function (e) {
        if (this.status === 200) {
          result = JSON.parse(this.responseText)
          resolve(result)
        }
      }
      xhr.onerror = function (e) {
        reject(e)
      }
      xhr.send()
    })
    return p
  }
  search('Hello World').then(console.log, console.error)

  // 加载图片使用 ajax 操作
  function imgLoad(url) {
    return new Promise(function (resolve, reject) {
      var request = new XMLHttpRequest()
      request.open('GET', url)
      request.responseType = 'blob'
      request.onload = function () {
        if (request.status === 200) {
          resolve(request.response)
        } else {
          reject(new Error('图片加载失败：' + request.statusText))
        }
      }
      request.onerror = function () {
        reject(new Error('发生网络错误'))
      }
      request.send()
    })
  }

```

#### 小结

- Promise 的优点在于:让回调函数变成了规范的链式写法,程序的流程可以看到很清楚;它有一整套接口,可以实现许多强大的功能,比如同时执行多个异步操作,等到它们的状态都改变以后,再执行一个回调函数;或者为多个函数中抛出的错误,统一指定处理方法等等
- Promise 还有一个传统写法没有的好处:它的状态一旦改变,无论何时查询,都能得到这个状态;这意味着,无论何时为 Promise 实例添加回调函数,该函数都能正确执行,所以不用担心是否错过了某个事件或信号;如果是传统写法,通过监听事件来执行回调函数,一旦错过事件,再添加回调函数是不会执行的
- Promise 的缺点是,编写的难度比传统写法高,而且阅读代码也不是一眼可以看懂,必须要在回调函数里面理清逻辑

#### 微任务

- Promise 的回调函数属于异步任务,会在同步任务之后执行

  ```

    new Promise(function (resolve, reject) {
      resolve(1);
    }).then(console.log);

    console.log(2);
    // 2
    // 1
    // 上面代码会输出 2,再输出 1;因为 console.log(2) 是同步任务,而 then 的回调函数属于异步任务,一定晚于同步任务执行
    
    // 但是, Promise 的回调函数不是正常的异步任务,而是微任务（microtask）;它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务
    setTimeout(function() {
      console.log(1)
    }, 0)
    new Promise(function (resolve, reject) {
      resolve(2)
    }).then(console.log)
    console.log(3)
    // 3
    // 2
    // 1
    // 上面代码输出结果是 3, 2, 1,这说明 then 的回调函数的执行时间,早于 setTimeout(fn, 0),因为 then 是本轮事件循环执行, setTimeout(fn, 0) 在下一轮事件循环开始执行
  
  ```

### CSS Sprites

#### 简介

- CSS Sprites 在国内很多人叫 css 精灵,是一种网页图片应用处理方式;它允许将一个页面涉及到的所有零星图片都包含到一张大图中,利用 CSS 的 "background-image", "background-repeat", "background-position" 的组合进行背景定位,访问页面时避免图片载入缓慢的现象

#### 优点

- CSS Sprites 能很好地减少网页的 http 请求,从而大大的提高页面的性能,这是 CSS Sprites 最大的有点,也是其被广泛和应用的主要原因
- CSS Sprites 能减少图片的字节
- CSS Sprites 解决了网页设计师在图片命名上的困扰,只需要对集合的图片命名,不需要对每一个小图片进行命名,从而提高了网页制作效率
- CSS Sprites 只需要修改一张或少张图片的颜色或样式来改变整个网页的风格

#### 缺点

- 图片合并麻烦:图片合并时,需要把多张图片有序的合理的合并成一张图片,并留好足够的空间防止版块出现不必要的背景
- 图片适应性差:在高分辨的屏幕下自适应页面,若图片不够宽会出现背景断裂
- 图片定位繁琐:开发时需要通过工具测量计算每个背景单元的精确位置
- 可维护性差:页面背景需要少许改动,可能要修改部分或整张已合并的图片,进而要改动 css,在避免改动图片的前提下,又只能(最好)往下追加图片,这样增加了图片字节

### HTML 元素

#### 块级元素

- 块级元素:在浏览器显示时,通常会以新行来开始(和结束);块级元素按照其应用于结构还是内容分为三种:
  - 结构化块状元素:这类元素用于构造文档的结构,没有语义上的含义,仅仅划分出了文档的组织方式,并没有体现文档的内容
  - 终端块状元素:这类元素用于从结构转向内容,拥有语义上的含义,能够表明内容的性质;终端块状元素属于结构的终点,它们不能再包含其他块级元素,只能包含文本或行级元素
  - 多目标块状元素:多目标指的是可以自由的扩展或嵌套文档的结构,以可以终端的形式出现;当多目标块状元素以结构化的方式使用时就含有结构化的内涵,以终端的形式使用就含有语义的内涵 

  |  |  |
  | --- | --- |
  | ``` <address> ``` | 定义地址 |
  | ``` <caption> ``` | 定义表格标题 |
  | ``` <dd> ``` | 定义列表中定义条目 |
  | ``` <div> ``` | 定义文档中的分区或节 |
  | ``` <dl> ``` | 定义列表 |
  | ``` <dt> ``` | 定义列表中的项目 |
  | ``` <fieldset> ``` | 定义一个框架集 |
  | ``` <form> ``` | 定义 HTML 表单 |
  | ``` <h1> ``` | 定义最大标题 |
  | ``` <h2> ``` | 定义副标题 |
  | ``` <h3> ``` | 定义标题 |
  | ``` <h4> ``` | 定义标题 |
  | ``` <h5> ``` | 定义标题 |
  | ``` <h6> ``` | 定义最小的标题 |
  | ``` <hr> ``` | 创建一条水平线 |
  | ``` <legend> ``` | 元素为 fieldset 元素定义标题 |
  | ``` <li> ``` | 标签定义列表项目 |
  | ``` <noframes> ``` | 为那些不支持框架的浏览器显示文本,于 frameset 元素内部 |
  | ``` <noscript> ``` | 定义在脚本未被执行时的替代内容 |
  | ``` <ol> ``` | 定义有序列表 |
  | ``` <ul> ``` | 定义无序列表 |
  | ``` <p> ``` | 定义段落 |
  | ``` <pre> ``` | 定义预格式化的文本 |
  | ``` <table> ``` | 定义 HTML 表格 |
  | ``` <tbody> ``` | 标签表格主题(正文) |
  | ``` <td> ``` | 表格中的标准单元格 |
  | ``` <tfoot> ``` | 定义表格的页脚(脚注或表注) |
  | ``` <th> ``` | 定义表头单元格 |
  | ``` <thead> ``` | 标签定义表格的表头 |
  | ``` <tr> ``` | 定义表格中的行 |

#### 行内元素

- 内联元素或称为行内元素一般都是基于语义级的基本元素,只能容纳文本或者其它内联元素

  |  |  |
  | --- | --- |
  | ``` <a> ``` | 标签可定义锚 |
  | ``` <abbr> ``` | 表示一个缩写形式 |
  | ``` <acronym> ``` | 定义只取首字母缩写 |
  | ``` <b> ``` | 字体加粗 |
  | ``` <bdo> ``` | 可覆盖默认的文本方向 |
  | ``` <big> ``` | 大号字体加粗 |
  | ``` <br> ``` | 换行 |
  | ``` <cite> ``` | 引用进行定义 |
  | ``` <code> ``` | 定义计算机代码文本 |
  | ``` <dfn> ``` | 定义一个定义项目 |
  | ``` <em> ``` | 定义为强调的内容 |
  | ``` <i> ``` | 斜体文本效果 |
  | ``` <img> ``` | 向网页中嵌入一副图像 |
  | ``` <input> ``` | 输入框 |
  | ``` <kbd> ``` | 定义键盘文本 |
  | ``` <label> ``` | 标签为 input 元素定义标注(标记) |
  | ``` <q> ``` | 定义短的引用 |
  | ``` <samp> ``` | 定义样本文本 |
  | ``` <select> ``` | 创建单选或多选菜单 |
  | ``` <small> ``` | 呈现小号字体效果 |
  | ``` <span> ``` | 组合文档中的行内元素 |
  | ``` <strong> ``` | 语气更强的强调的内容 |
  | ``` <sub> ``` | 定义下标文本 |
  | ``` <sup> ``` | 定义上标文本 |
  | ``` <textarea> ``` | 多行的文本输入控件 |
  | ``` <tt> ``` | 打字机或者等宽的文本效果 |
  | ``` <var> ``` | 定义变量 |

#### 块级元素与行内元素的区别

- 块级元素会独占一行,其宽度自动填满其父元素宽度;行内元素不会独占一行,相邻的行内元素会排列在同一行,直至一行排不下才会换行,其宽度随元素的内容而变化
- 块级元素可以包含行内元素和块级元素;行内元素不能包含块级元素
- 行内元素设置 width, height, margin-top, margin-bottom, padding-top, padding-bottom 无效

#### 块级元素与行内元素的转换

- display: inline-block
- display: block
- display: block

#### 可变元素

- 可变元素列表:可变元素为根据上下文语境决定该元素为块元素或者内联元素

  |  |  |
  | --- | --- |
  | ``` <button> ``` | 按钮 |
  | ``` <del> ``` | 定义文档中已被删除的文本 |
  | ``` <iframe> ``` | 创建包含另外一个文档的内联框架(即行内框架) |
  | ``` <ins> ``` | 标签定义已经被插入文档中的文本 |
  | ``` <map> ``` | 客户端图像映射(即热区) |
  | ``` <object> ``` | object 对象 |
  | ``` <script> ``` | 客户端脚本 |

### input

- type 属性规定 input 元素的类型

  |  |  |
  | --- | --- |
  | ``` <button> ``` | 定义可点击按钮(多数情况下,用于通过 JavaScript 启动脚本) |
  | ``` <checkbox> ``` | 定义复选框 |
  | ``` <file> ``` | 定义输入字段和"浏览"按钮,供文件上传 |
  | ``` <hidden> ``` | 定义隐藏的输入字段 |
  | ``` <image> ``` | 定义图片形式的提交按钮 |
  | ``` <password> ``` | 定义密码字段,该字段的字符被掩码 |
  | ``` <radio> ``` | 定义单选按钮 |
  | ``` <reset> ``` | 定义重置按钮,重置按钮会清除表单中的所有数据 |
  | ``` <submit> ``` | 定义提交按钮,提交按钮会把表单数据发送到服务器 |
  | ``` <text> ``` | 定义单行的输入字段,用户可以在其中输入文本,默认宽度为 20 个字符 |

### 置换元素和非置换元素

#### 置换元素

- 浏览器根据元素的标签和属性,来决定元素的具体显示内容
  - 例: 浏览器根据 ``` <img> ``` 标签的 src 属性显示图片;根据标签的 type 属性决定显示输入框还是按钮
- 置换元素在其显示中生成了框,这也就是有的内联元素能够设置宽高的原因
  - html 中的 ``` <img> ```, ``` <input> ```, ``` <textarea> ```, ``` <select> ```, ``` <object> ``` 都是置换元素,这些置换元素往往没有实际内容,只是一个空元素

#### 非置换元素

- 浏览器中的大多数元素都是不可置换元素,即其内容直接展示给浏览器
  - 例: ``` <label> ``` 标签, ``` <p> ``` 标签里的内容会被浏览器直接显示给用户

### 浏览器加载 CommonJS 模块的原理与实现

#### 原理

- 浏览器不兼容 CommonJS 的根本原因,在于缺少四个 Node.js 环境的变量:
  - module
  - exports
  - require
  - global
- 只要能提供这四个变量,浏览器就能加载 CommonJS 模块

  ```

    var module = {
      exports: {}
    }
    (function(module, exports){
      exports.multiply = function(n){
        return n * 1000
      }
    }(module, module.exports))
    var f = module.exports.multiply
    f(5)    // 5000
    // 上面代码向一个立即执行函数提供 module 和 exports 两个外部变量,模块就放在这个立即执行函数里面;模块的输出值放在 module.exports 之中,这样就实现了模块的加载

  ```

#### Browserify 的实现

- Browserify 是目前最常用的 CommonJS 格式转换的工具

  ```

    // main.js 模块加载 foo.js 模块
    // foo.js
    module.exports = function(x){
      console.log(x)
    }

    // main.js
    var foo = require("./foo")
    foo("Hi")

    // node 安装 browserify
    npm install browserify -g

    // 输入命令,就能将 main.js 转为浏览器可用的格式
    browserify main.js > compiled.js

    // node 安装 browser-unpack
    npm install browser-unpack -g

    // 然后将前面生成的 commpile.js 解包
    browser-unpack < compiled.js

    // commpile.js
    [
      {
        "id": 1,
        "source": "module.exports = function(x) {\n  console.log(x);\n};",
        "deps": {}
      },
      {
        "id": 2,
        "source": "var foo = require(\"./foo\");\nfoo(\"Hi\");",
        "deps": {"./foo":1},
        "entry": true
      }
    ]

    // 可以看到, browerify 将所有模块放入一个数组, id 属性是模块的编号, source 属性是模块的源码, deps 属性是模块的依赖
    // 因为 main.js 里面加载了 foo.js, 所以 deps 属性就指定 ./foo 对应一号模块;执行的时候,浏览器遇到 require("./foo") 语句,就自动执行 1 号模块的 source 属性,并将执行后的 module.exports 属性值输出

  ```

### 常见的浏览器端的存储技术

- 有时需要将网页中的一些数据保存在浏览器端,这样做的好处:当下次访问页面时,不需要再次向服务器请求数据,直接就可以从本地读取数据;目前常用的有以下几种方法:
  - cookie
    - cookie 会随着每次 HTTP 请求头信息一起发送,无形中增加了网络流量,另外, cookie 能存储的数据容量有限,根据浏览器类型不同而不同, IE6 大约只能存储 2K
  - Flash ShareObject
    - 这种方式能解决 cookie 存储的两个弊端,而且能够跨浏览器,应该说是目前最好的本地存储方案;不过需要在页面中插入一个 Flash,当浏览器没有安装 Flash 控件时就不能用了,所幸的是,没有安装 Flash 的用户极少
    - 缺点:需要安装 Flash 插件
  - Google Gear
    - Google 开发出来的一种本地存储技术
    - 缺点:需要安装 Gear 组件
  - userData
    - IE 浏览器可使用 userData 来存储数据,容量可以达到 640K,这种方案很可靠的,不需要安装额外的插件
    - 缺点:仅在 IE 浏览器下有效
  - session Storage
    - 使用于 Firefox2+ 的火狐浏览器,用这种方式存储的数据仅窗口级别有效,同一个窗口(或者 Tab)页面刷新或者跳转,都能获取到本地存储的数据,当新开窗口或者页面时,原来的数据就失效了
    - 缺点: IE 不支持,不能实现数据的持久保存
  - global Storage
    - 使用于 Firefox2+ 的火狐浏览器,类似于 IE 的 userData

      ```

        // 1.赋值
        globalStorage[location.hostname]['name'] = 'tugai'
        // 2.读取
        globalStorage[location.hostname]['name']
        // 3.删除
        globalStorage[location.hostname].removeItem('name')

      ```
    
    - 缺点: IE 不支持
  - local Storage
    - local Storage 是 Web Storage 互联网存储规范中的一部分,现在在 Firefox3.5, Safari4 和 IE8 中得到支持
    - 缺点:低版本浏览器不支持
- 结论:
  - Flash shareobject 是不错的选择,如果不想在页面上嵌入 Flash,可以结合使用 userData(IE6+)和 gloabalStorage(Firefox2+)和 localStorage(chrome3+)实现跨浏览器

### 解释性语言和编译性语言

> 计算机不能直接理解高级语言,只能直接理解机器语言,所以必须要把高级语言翻译成机器语言,计算机才能执行高级语言编写的程序;翻译的方式有两种:一个是编译,一个是解释;两种方式只是翻译的时间不同

#### 解释性语言

- 定义:解释性语言的程序不需要编译,在运行程序的时候才翻译,每个语句都是执行的时候才翻译;这样解释性语言每执行一次就需要逐行翻译一次,效率比较低;现在解释性语言通常把源程序编译成中间代码,然后用解释器把中间代码一条条翻译成目标机器代码,一条条执行

#### 编译性语言

- 定义:编译性语言写的程序在被执行之前,需要一个专门的编译过程,把程序编译成为机器语言的文件,比如 .exe 文件,以后要运行的话就不用重新编译了,直接使用编译的结果就行了,因为翻译只做了一次,运行时不需要翻译,所以编译型语言的程序执行效率高

### 原型链知识

- Object.prototype 只是一个普通对象,它是 js 原型链的最顶端
  - ``` Object.prototype.__proto__===null ```   => true
  - ``` Object.prototype.prototype===undefined ```    => true
  - 注: ``` Object.prototype ``` 只是一个普通对象(普通对象是没有 prototype 属性,所以值是 undefined);``` Object.prototype ``` 是 js 原型链的最顶端,它的 ``` __proto__ ``` 是 null(有 ``` __proto__ ``` 属性,但值是 null,因为这是原型链的最顶端)
- 在 js 中如果 A 对象是由 B 函数构造的,那么 ``` A.__proto__===B.prototype ``` 
  - javascript 中对象是由 Object 创建的,函数是由 Function 创建的
- 内置的 Object 其实也是一个函数对象,它是由 Function 创建的
  - ``` Object.__proto__===Function.prototype ```
- js 中每一个对象或函数都有 ``` __proto__ ``` 属性,但是只有函数对象才有 prototype 属性
  - 函数对象

    ```

      function Person(){
        //函数体
      }

    ```
  
  - 普通对象

    ```

      var obj = {}

    ```
  
  - 它们的 ``` _proto__ ``` 属性和 prototype 属性

    ```

      obj.__proto__===Object.prototype    => true
      obj.prototype===undefined   => true
      Person.__proto__===Function.prototype   => true
      Person.prototype!==undefined    => true

    ```
  
  - 原型链是基于 ``` __proto__ ``` 形成的,继承是通过 prototype 实现的
- Function.prototype 是个特例,它是函数对象,但是没有 prototype 属性,其他所有函数都有 prototype 属性
  
  ```

    Function.prototype.prototype === undefined    => true

  ```

- 内置的 Function 也是一个函数对象,它是通过自己来创建自己的

  ```

    Function.__proto__===Function.prototype   => true

  ```

- 函数也是对象,因为 ``` Function.prototype.__proto__ ``` 指向 Object.prototype

  ```

    typeof Function.prototype.__proto__ === "object"    => true
    Function.prototype.__proto__ === Object.prototype   => true

  ```

### 循环遍历的方法

#### for 循环

- Array 数组

  ```

    var arr = [1, 2, 3]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

- Object 对象: for 循环无法遍历 Object 对象
- NodeLisr 数组

  ```

    // html
    <span>1</span>
    <span>2</span>
    <span>3</span>

    // js
    var span = document.getElementsByTagName("span") 
    for(let i=0; i<span.length; i++){
      console.log(span[i].innerHTML)
    }
    // => 1 2 3

  ```

- Set 对象: for 循环无法直接遍历 Set 对象,可以先用 Array.from() 方法或者 [...] 现将 Set 对象转换成普通数组

  ```

    let set = new Set(["red", "green", "blue"])
    var arr = Array.from(set)   // 或者使用 var arr = [...set]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => red green blue

  ```

- Map

  ```

    let map = new Map([
      ["F", "no"],
      ["T", "yes"]
    ])
    var arr = [...map]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => ["F", "no"] ["T", "yes"]

  ```

- Generator 对象:先利用 Array.from 或者 [...] 方法将其转换成常规数组

  ```

    function* gen() {
      yield 1;
      yield 2;
      yield 3;
    }
    var arr = Array.from(gen())   // 或者使用 var arr = [...gen()]
    for(let i=0; i<arr.length; i++){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

#### forEach()

- Array

  ```

    var arr = [1, 2, 3]
    arr.forEach((value, key, item) => {
      console.log(value)
    })
    // => 1 2 3

  ```

- Object: 
  - JavaScript 原生的 Object 对象无法直接使用 forEach 循环遍历,可以先借用 Object 对象的方法获取键名数组

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      // object.getOwnPropertyNames() 方法可以获取对象属性名称,并存储在数组中
      var objName = Object.getOwnPropertyNames(obj)
      objName.forEach((key) => {
        console.log(obj[key])
      })
      // => Jack 16 male

    ```
  
  - 也可以使用 Reflect 的 ownKeys() 方法,该方法还能获取到以 Symbol 为键名的键值,而上述原生的 JavaScript 方法则无法获取

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      let email = Symbol()
      obj[email] = "123@qq.com"
      // Reflect.ownKeys() 返回对象的所有属性
      var objName = Reflect.ownKeys(obj)
      objName.forEach((key) => {
        console.log(obj[key])
      })
      // => Jack 16 male 123@qq.com

    ```
  
- Set

  ```

    let set = new Set(["red", "green", "blue"])
    set.forEach((value, key, item) => {
      console.log(value)
    })
    // => red green blue

  ```
  
- Map 对象

  ```

    const map = new Map([
      ["F", "no"],
      ["T", "yes"]
    ])
    map.forEach((value, key, item) => {
      console.log(value)
      console.log(key)
    })
    // => no F yes T

  ```

- Generator 对象:先利用 Array.from 或者 [...] 方法将其转换成常规数组

  ```

    function* gen(){
      yield 1
      yield 2
      yield 3
    }
    var arr = Array.from(gen())   // 或者使用 var arr = [...gen()]
    arr.forEach((value) => {
      console.log(value)
    })
    // => 1 2 3 

  ```
  
#### for ... in

> 适用于遍历普通对象,无法遍历 Set, Map 等对象

- Array

  ```

    var arr = [1, 2, 3]
    for(let i in arr){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

- Object

  ```

    var obj = "123"
    for(let i in obj){
      console.log(obj[i])
    }
    // => 1 2 3

  ```

- Generator 对象

  ```

    function* gen(){
      yield 1
      yield 2
      yield 3
    }
    var arr = Array.from(gen())   // 或者使用 var arr = [...gen()]
    for(let i in arr){
      console.log(arr[i])
    }
    // => 1 2 3

  ```

#### for ... of

> 可以遍历 NodeList, Map, Set, Generator 对象

- Array

  ```

    let arr = [1, 2, 3]
    for(let i of arr){
      console.log(i)
    }
    // => 1 2 3

  ```

- Object 
  - JavaScript 原生的 Object 对象无法直接使用 forEach 循环遍历,可以先借用 Object 对象的方法获取键名数组

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      // object.getOwnPropertyNames() 方法可以获取对象属性名称,并存储在数组中
      var objName = Object.getOwnPropertyNames(obj)
      for(let i of objName){
        console.log(obj[i])
      }
      // => Jack 16 male

    ```
  
  - 也可以使用 Reflect 的 ownKeys() 方法,该方法还能获取到以 Symbol 为键名的键值,而上述原生的 JavaScript 方法则无法获取

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      let email = Symbol()
      obj[email] = "123@qq.com"
      // Reflect.ownKeys() 返回对象的所有属性
      var objName = Reflect.ownKeys(obj)
      for(let i of objName){
        console.log(obj[i])
      }
      // => Jack 16 male 123@qq.com

    ```
  
  - 也可以使用 Object.keys() 方法和 Object.values() 方法遍历,但是该方法无法获取继承的属性和 Symbol 属性

    ```

      let obj = {
        name: "Jack",
        age: 16,
        sex: "male"
      }
      let email = Symbol()
      obj[email] = "123@qq.com"
      // 使用 Object.keys() 方法
      var keys = Object.keys(obj)
      for(let i of keys){
        console.log(obj[i])
      }
      // => Jack 16 male
      // 使用 Object.values() 方法
      var values = Object.values(obj)
      for(let i of values){
        console.log(i)
      }
      // => Jack 16 male

    ```

- Set 对象

> Set 对象具有 keys(), value(), entries() 方法可以分别获取 Set 对象的键名,键值和键值对,结合 for...of 实现遍历

  ```

    let set = new Set(["red", "green", "blue"])
    for(let i of set){
      console.log(i)
    }
    // => red green blue

  ```

- Map 对象

> 此外, Map 对象具有 keys(), values(), entries() 方法可以分别获取 Set 对象的键名,键值和键值对,结合 for...og 实现遍历

  ```

    let map = new Map([
      ["F", "no"],
      ["T", "yes"]
    ])
    for(let i of map){
      console.log(i)
    }
    // ["F", "no"] ["T", "yes"]

  ```

- Generator 对象:只能返回 yield 的结果,无法返回 return 的结果

  ```

    function *foo(){
      yield 1
      yield 2
      yield 3
      return 4
    }
    for(let i of foo()){
      console.log(i)
    }
    // => 1 2 3

  ```

### JS 对象

> JS 中,可以将对象分为"内部对象","宿主对象"和"自定义三种"

#### 内部对象

- JS 中的内部对象包括 Arguments(函数参数集合), Array(数组), Boolean(布尔对象), Date(日期时间), Function(函数构造器), Global, Math(数学对象), Number(数值对象), Object(基础对象), RegExp(正则表达式对象), String(字符串对象) 以及各种错误类对象,包括 Error, EvalError, RangeError, ReferenceError, SyntaxError 和 TypeError;其中 Global 和 Math 这两个对象又被称为"内置对象",这两个对象在脚本程序初始化时被创建,不必实例化这两个对象

#### 宿主对象

- 宿主对象就是执行 JS 脚本的环境提供的对象,对于嵌入到网页中的 JS 来说,其宿主对象就是浏览器提供的对象,所以又被称为浏览器对象,如 IE, Firefox 等浏览器提供的对象;不同的浏览器提供的宿主对象可能不同,即使提供的对象相同,其实现方法也大相径庭,并会带来浏览器兼容问题,增加开发难度

#### 自定义对象

- 顾名思义,就是开发人员自己定义的对象; JS 允许使用自定义对象,使 JS 应用及功能得到补充

### JavaScript 实现跨域的方式

- jsonp 请求: jsonp 的原理是利用 script 标签的跨域特性,可以不受限制地从其他域中加载资源,类似的标签还有 img
- document.domain:这种方式用在主域名相同子域名不同的跨域访问中
- window.name: window 的 name 属性有个特征:在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的,每个页面对 window.name 都有读写的权限, window.name 是持久存在一个窗口载入过的所有页面中的,并不会因新页面的载入而进行重置
- window.postMessage: window.postMessage 是 html5 中实现跨域访问的一种新方式,可以使用它来向其它的 window 对象发送消息,无论这个 window 对象是属于同源或不同源
- CORS: CORS 背后的基本思想,就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是应该失败
- Web Socket: 在 JS 创建了一个 web socket 之后,会有一个 HTTP 请求发送到浏览器以发起连接,取得服务器响应后,建立的连接会使用 HTTP 升级从 HTTP 协议交换为 Web Socket 协议

### MVC 架构

> MVC 模型是一种架构型的模式,本身不引入新功能,只是帮助将开发的结构组织的更加合理,使展示与模型分离,流程控制逻辑,业务逻辑调用与展示逻辑分离

- Model(模型)
  - 应用程序中用于处理应用程序数据逻辑的部分
  - 通常模型对象负责在数据库中存取数据
  - 提供要展示的数据,因此包含数据和行为,可以认为是领域模型或 JavaBean 组件(包含数据和行为),不过现在一般都分离开来,: Value Object(数据)和服务层(行为),也就是模型提供了模型数据查询和模型数据的状态更新等功能,包括数据和业务
- View(视图)
  - 应用程序中处理数据显示的部分
  - 通常视图是依据模型数据创建的
  - 负责进行模型的展示,一般就是见到的用户界面
- Controller(控制器)
  - 应用程序中处理用户交互的部分
  - 通常控制器负责从视图读取数据,控制用户输入,并向模型发送数据
  - 接受用户请求,委托给模型进行处理(状态改变),处理完毕后把返回的模型数据返回给视图,由视图负责展示,也就是说控制器做了个调度员的工作

### JavaScript 实现继承的 6 种方式

#### JavaScript 的继承

- 许多面向对象语言都支持两种继承的方式:接口继承和实现继承;接口继承只继承方法签名,而实现继承则继承实际的方法.在 JavaScript 中由于函数没有签名也就无法实现接口继承,而只支持实现继承,而且实现继承主要通过原型链来实现的
- 原型链:其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法
- 构造函数,原型和实例的关系:
  - 每个构造函数(只要是函数)都有一个 prototype 属性,该属性指向一个对象(这个对象就是构造函数的原型对象)
  - 原型对象(只要是对象)中都有一个 constructor 属性,该属性指向一个构造函数
  - 实例中都包含一个指向原型对象的内部指针 ``` `prototype` ```
- 原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的
- 这样子类型就可以访问定义在超类型上的所有属性和方法了;每个对象都有自己的原型对象,以原型对象为模板从原型对象中继承属性和方法,原型对象也可以有自己的原型并从中继承属性和方法,以此类推,这种关系被称之为原型链

#### JavaScript 实现继承的方式

##### 原型链继承

```

  // 实现原型链的一种基本模式
  function SuperType(){
    this.property = true
  }
  SuperType.prototype.getSuperValue = function(){
    return this.property
  }
  function SubType(){
    this.subproperty = false
  }

  // 继承,用 SuperType 类型的一个实例来重写 SubType 类型的原型对象
  SubType.prototype = new SuperType()
  SubType.prototype.getSubValue = function(){
    return this.subproperty
  }
  var instance = new SubType()
  alert(instance.getSuperValue())   // true

```

- 其中, SubType 继承了 SuperType,而继承是通过创建 SuperType 的实例,并将该实例赋值给 SubType 的原型实现的
- 实现的本质是重写子类型的原型对象,代之以一个新类型的实例,子类型的新原型对象中有一个内部属性 ``` ` Prototype ` ``` 指向了 SuperType 的原型,还有一个从 SuperType 原型中继承过来的属性 constructor 指向了 SuperType 构造函数
- 最终的原型链是这样的: instance 指向 SubType 的原型, SubType 的原型又指向 SuperType 的原型, SuperType 的原型又指向 Object 的原型(所有函数的默认原型都是 Object 的实例,因此默认原型都会包含一个内部指针,指向 Object.prototype)
- 原型链的缺点:
  - 在通过原型来实现继承时,原型实际上会变成另一个类型的实例;于是,原先的实例属性也就顺理成章地变成了现在的原型属性,并且会被所有的实例共享,这样理解:在超类型构造函数中定义的引用类型值的实例属性,会在子类型原型上变成原型属性被所有子类型实例所共享
  - 在创建子类型的实例时,不能向超类型的构造函数中传递参数

##### 借用构造函数继承(也称伪造对象或经典继承)

```

  // 在子类型构造函数的内部调用超类型构造函数;使用 apply() 或 call() 方法将父对象的构造函数绑定在子对象上
  function SuperType(){
    // 定义引用类型值属性
    this.colors = ["red", "green", "blue"]
  }
  function SubType(){
    // 继承 SuperType,在这里还可以给超类型构造函数传参
    SuperType.call(this)
  }
  var instance1 = new SubType()
  instance1.colors.push("purple")
  alert(instance1.colors)   // "red, green, blue, purple"
  var instance2 = new SubType()
  alert(instance2.colors)   // "red, green, blue"

```

- 通过使用 apply() 或 call() 方法,实际上是在将要创建的 SubType 实例的环境下调用了 SuperType 构造函数;这样一来,就会在新 SubType 对象上执行 SuperType() 函数中定义的所有对象初始化代码,结果 SubType 的每个实例就都会具有自己的 colors 属性的副本了
- 借用构造函数的优点:解决了原型链实现继承存在的两个问题
- 借用构造函数的缺点:方法都在构造函数中定义,因此函数复用就无法实现了;而且,在超类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式

##### 组合继承(也称伪经典继承)

```

  // 将原型链和借用构造函数的技术组合到一块,使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承,这样即通过在原型上定义方法实现了函数复用,又能够保证每个实例都有自己的属性
  function SuperType(name){
    this.name = name
    this.colors = ["red", "green", "blue"]
  }
  SuperType.prototype.sayName = function(){
    alert(this.name)
  }
  function SubType(name, age){
    // 借用构造函数方法继承属性
    SuperType.call(this, name)
    this.age = age
  }
  // 原型链方法继承方法
  SubType.prototype = new SuperType()
  SubType.prototype.constructor = SubType
  SubType.prototype.sayAge = function(){
    alert(this.age)
  }
  var instance1 = new SubType("luochen",22)
  instance1.colors.push("purple")
  alert(instance1.colors)    // "red,green,blue,purple"
  instance1.sayName()
  instance1.sayAge()
  var instance2 = new SubType("tom",34)
  alert(instance2.colors)    // "red,green,blue"
  instance2.sayName()
  instance2.sayAge()

```

- 组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 javascript 中最常用的继承模式,而且使用 instanceof 操作符合 isPrototype() 方法也能够用于识别基于组合继承创建的对象
- 组合继承的缺点:无论在什么情况下,都会调用两次超类型构造函数,一次是在创建子类型原型的时候,另一次是在子类型构造函数内部

##### 原型式继承

```

  // 借助原型可以基于已有的对象创建新对象,同时还不必因此创建自定义类型
  // 1. 自定义一个函数来实现原型式继承
  function object(e){
    function F(){  }
    F.prototype = e
    return new F()
  }

```

- 在 object() 函数内部,先创建一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回这个临时类型的一个新实例;实质上, object() 对传入其中的对象执行了一次浅复制
- 使用 Object.create() 方法实现原型式继承
  - 这个方法接收两个参数:一是用做新对象原型的对象和一个为新对象定义额外属性的对象;在传入一个参数的情况下,此方法与 object() 方法作用一致,在传入第二个参数的情况下,指定的任何属性都会覆盖原型对象上的同名属性

    ```

      var person = {
        name: "luochen",
        colors: ["red", "green", "blue"]
      }
      var anotherPerson1 = Object.create(person, {
        name:{
          value: "tom"
        }
      })
      var anotherPerson2 = Object.create(person, {
        name:{
          value: "jerry"
        }
      })
      anotherPerson1.colors.push("purple")
      alert(anotherPerson1.name)    // "tom"
      alert(anotherPerson2.name)    // "jerry"
      alert(anotherPerson1.colors)    // "red, green, blue, purple"
      alert(anotherPerson1.colors)    // "red, green, blue, purple"

    ```
  
- 只是想让一个对象与另一个对象类似的情况下,原型式继承是完全可以胜任的
- 原型式继承的缺点:包含引用类型值的属性始终都会共享相应的值

##### 寄生式继承

```

  // 创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后返回这个对象
  function createPerson(original){
    var clone = Object.create(original)   // 通过 Object.create() 函数创建一个新对象
    clone.sayGood = function(){   // 增强这个对象
      alert("hello world!!!")
    }
    return clone    // 返回这个对象
  }

```

- 在主要考虑对象而不是自定义类型和构造函数的情况下,寄生式继承也是一种有用的模式
- 寄生式继承的缺点:做不好函数复用

##### 寄生组合式继承

```

  // 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型
  function SuperType(name){
    this.name = name
    this.colors = ["red","green","blue"]
  }
  SuperType.prototype.sayName = function(){
    alert(this.name)
  }
  function SubType(name,age){
    SuperType.call(this,name)
    this.age = age
  }
  // 创建超类型原型的一个副本
  var anotherPrototype = Object.create(SuperType.prototype)
  // 重设因重写原型而失去的默认的 constructor 属性
  anotherPrototype.constructor = SubType
  // 将新创建的对象赋值给子类型的原型
  SubType.prototype = anotherPrototype
  SubType.prototype.sayAge = function(){
    alert(this.age)
  }
  var instance1 = new SubType("luochen",22)
  instance1.colors.push("purple")
  alert(instance1.colors)    // "red,green,blue,purple"
  instance1.sayName()
  instance1.sayAge()
  var instance2 = new SubType("tom",34)
  alert(instance2.colors)      // "red,green,blue"
  instance2.sayName()
  instance2.sayAge()

```

- 这个式子的高效率体现在它只调用一次 SuperType 构造函数,并且因此避免了在 SubType.prototype 上面创建不必要,多余的属性,原型链还能保持不变,因此还能够正常使用 instance 操作符和 isPrototype() 方法

### HTML 中 meta 标签

> ``` meta ``` 标签是 ``` html ``` 标记语言的 ``` head ``` 区一个非常有用的一个辅助性标签,在所有网页中都可以看到

#### meta 标签的组成

- ``` meta ``` 标签共有两个属性:不同的属性又有不同的参数值,这些不同的参数值就实现了不同网页功能
  - ``` http-equiv ``` 属性
    - ``` http-equiv ```:顾名思义,相当于 ``` http ``` 的文件头作用,它可以向浏览器传回一些有关的信息,以帮助正确和精确地显示网页内容,与之对应的属性值为 ``` content ```, ``` content ``` 中的内容其实就是各个参数的变量值
    - ``` meta ``` 标签的 ``` http-equiv ``` 属性语法格式是
      - ``` <meta http-equiv="参数" content="参数变量值"> ```
    - 其中 ``` http-equiv ``` 属性主要有以下几种参数:
      
      ```

        1. 如果网页过期,那么存盘的cookie将被删除,必须使用GMT的时间格式
        <meta http-equiv="Set-Cookie" content="cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/">
        2. 用于设定网页的到期时间,一旦网页过期,必须到服务器上重新传输
        <meta http-equiv='expires' content='时间' >
        3. 告诉浏览器在【数字】秒后跳转到【一个网址】
        <meta http-equiv="Refresh" content="5;URL">
        4. 设定页面使用的字符集
        <meta http-equiv="content-Type" content="text/html; charset=utf-8">
        5. 在HTML5中设定字符集的简写写法
        <meta charset="utf-8">
        6. 禁止浏览器从本地计算机的缓存中访问页面内容,访问者将无法脱机浏览
        <meta http-equiv="Pragma" content="no-cache">
        7.用来防止别人在 iframe(框架)里调用自己的页面,这也算是一个非常实用的属性
        <meta http-equiv="Window-target" content="_top">
        8. 强制浏览器按照特定的版本标准进行渲染,但不支持IE7及以下版本;如果是ie浏览器就用最新的 ie 渲染,如果是双核浏览器就用 chrome 内核
        <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>

      ```

  - ``` name ``` 属性
    - 主要用于描述网页,与之对应的属性值为 ``` content ```, ``` content ``` 中的内容主要是便于搜索引擎机器人查找信息和分类信息用的
    - ``` meta ``` 标签的 ``` name ``` 属性语法格式是
      - ``` <meta name="参数" content="具体的参数值"> ```
    - 其中 ``` name ``` 属性主要有以下几种参数
      
      ```

        1. 在移动设备浏览器上,禁用缩放(zooming)功能,用户只能滚动屏幕
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        2. 告诉搜索引擎,当前页面的主要内容
        <meta name="description" content="">
        3. 告诉搜索引擎,当前页面的关键字
        <meta name="keywords" content="">
        4. 告诉搜索引擎,标注网站作者是谁
        <meta name="author" content="">
        5. 标注网站的版权信息
        <meta name="copyright" content="">

      ```
  
  - ``` meta ``` 中 ``` name ``` 标签的功能
    - 帮助主页被各大搜索引擎登录
      - ``` meta ``` 标签的一个很重要的功能就是设置关键字,来帮助主页被各个搜索引擎登录,提高网站的访问量
      - 在这个功能中,最重要的就是对 ``` Keywords ``` 和 ``` description ``` 的设置,因为按照搜索引擎的工作原理,搜索引擎首先派出机器人自动检索页面的 ``` keywords ``` 和 ``` decription ```,并将其加入到自己的数据库,然后再根据关键词的密度将网站排序
      - 因此,必须设置好关键字,来提高页面的搜索点击率
        
        ```

          <meta name="keywords" content="网页,网页制作,网页特效,建站指南,教程下载,动画制作,网页教学，网页素材，视频教程，技术论坛，免费空间，免费域名">
          <meta name="description" content="网页教学网,专业的网页教学网站">

        ```

### 函数的调用方法

|  | 函数调用方式 | 方法调用模式 | 构造器调用模式 | 间接调用模式 |
| --- | --- | --- | --- | --- |
| 实参处理 | 参数表达式运行结果作为实参传递给函数形参 | 与函数调用模式一致 | 一般情况下,与函数调用模式一致;但如果构造函数没有形参, JavaScript 构造函数调用语法是允许省略实参列表和圆括号的 | call() 方法使用它自有的实参列表作为函数的实参; apply() 方法要求以数组的形式传入参数 | 
| 调用上下文 | 指向全局变量 | 指向方法所属的对象 | 指向新创建的对象 | 允许显示的指定调用所需的 this 值,为 call() 或 apply() 中的第一个参数 |
| 返回值 | 没有执行到 return 语句,返回 undefined;执行到 return xxx 语句,返回 return 之后的值; return 后没有值,返回 undefined | 与函数调用模式一致 | 构造函数通常不使用 return 关键字,返回值就是新对象;如果构造函数显示地使用 return 语句返回一个对象,那么调用表达式值就为这个对象;如果构造函数使用 return 语句但没有指定返回值或者返回一个原始值,则忽略返回值,同时使用新对象作为调用结果 |  |

### 闭包(closure)

> 闭包是函数和声明该函数的词法环境的组合([MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures))

#### MDN 上的例子

```

  function makeFunc(){
    var name = "Mozilla"
    function displayName(){
      alert(name)
    }
    return displayName
  }
  var myFunc = makeFunc()
  myFunc()

```

- JavaScript 中的函数会形成闭包;闭包是由函数以及创建该函数的词法环境组合而成,这个环境包含了这个闭包创建时所能访问的所有局部变量
- myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用,而 displayName 实例仍可访问其词法作用域中的变量,即可以访问到 name;由此,当 myFunc 被调用时, name 仍可被访问,其值 Mozilla 就被传递到 alert 中

#### 使用闭包的理由

- 局部变量无法共享和长久的保存,而全局变量可能造成变量污染,所以希望有一种机制既可以长久的保存变量又不会造成全局污染

#### 闭包的使用

- 定义外层的函数(outer),封装被保护的局部变量
- 定义内层的函数(inner),执行对外层函数变量的引用
- 外层函数(outer)返回内层(inner)的函数对象,并且外层函数(outer)被调用,结果保存在一个全局的变量中

##### 注意一:手动解除引用

```

  function makeAdder(x){
    return fucntion(y){
      return x + y
    }
  }
  var add5 = makeAdder(5)
  var add10 = makeAdder(10)
  console.log(add5(2))    // 7
  console.log(add10(2))   // 12
  // 释放对闭包的引用
  add5 = null
  add10 = null

```

- add5 和 add10 都是闭包,它们共享相同的函数定义,但是保存了不同的环境,在 add5 的环境中, x 为 5,而在 add10 中, x 则为 10,最后通过 null 释放了 add5 和 add10 对闭包的引用

> 在 javascript 中,如果一个对象不再被引用,那么这个对象就会被垃圾回收机制回收,而 makeAdder 对象被全局变量 add5 和 add10 引用,就会占用内存空间

##### 注意二:闭包遇上 for 循环

- 闭包只能取得包含函数中任何变量的最后一个值,这是因为闭包所保存的是整个变量对象,而不是某个特殊的变量

```

  // for 循环使用 var 
  function test(){
    var arr = []
    // 函数 test() 的作用域
    for(var i=0; i<10; i++){    // 函数 test() 的作用域
      // 函数 test() 的作用域
      arr[i] = function(){    // 函数 arr[i] 的作用域
        // 函数 arr[i] 的作用域
        return i
      }
    }
    // 函数 test() 作用域
    console.log(i)    // => 10
    for(var a=0; a<10; a++){
      console.log(arr[a]())
    }
  }
  test()    // => 连续打印 10 个 10
  解析:
    console.log(i) 执行到这里的时候,i 的值是 10,既然这里是 10,那么在函数 arr[i] 作用域中访问 i 也是 10,因为函数 arr[i] 作用域中没有,向函数 test() 作用域中去找,同一作用域中同一变量名的变量值肯定是相同的(未修改的情况下)
  

  // for 循环使用 let
  function test(){
    var arr = []
    // 块 1 作用域
    for(let i=0; i<10; i++){    // 块 2 作用域
      // 块 2 作用域
      console.log(i)    // => 0 1 2 3 4 5 6 7 8 9 
      arr[i] = function(){    // 块 3 作用域
        // 块 3 作用域
        return i
      }
    }
    for(var a=0; a<10; a++){
      console.log(arr[a]())
    }
  }
  test()    // => 0 1 2 3 4 5 6 7 8 9
  解析:
    当使用 let 的时候,读取 i 值的时候,在当前作用域块 3 中没有找到,向上一个作用域块 2 寻找,在块 2 作用域中发现 i,于是拿到值

```

#### 闭包的缺点

- 由于闭包会使得函数中的变量都被保存在内存中,内存消耗很大,所以不能滥用闭包,否则会造成网页的性能问题,在 IE 中可能导致内存泄露
- 闭包会在父函数外部,改变父函数内部变量的值,所以,如果把父函数当做对象(object)使用,把闭包当做它的公用方法,把内部变量当作它的私有属性

```

  function Animal(){
    // 私有变量
    var series = "哺乳动物"
    function run(){
      console.log("Run!!!")
    }
    // 特权方法
    this.getSeries = function(){
      return series
    }
  }

```

```

  // 闭包函数
  function fun(n,o){
    console.log(o);
    return {
      fun: function(m){
        return fun(m,n);
      }
    };
  }
  var a = fun(0);  // => undefined
  a.fun(1);        // => 0
  a.fun(2);        // => 0
  a.fun(3);        // => 0
  var b = fun(0).fun(1).fun(2).fun(3);  // => undefined 0 1 2 
  var c = fun(0).fun(1);  // => undefined 0
  c.fun(2);        // 1
  c.fun(3);        // 1

```

## 前端面试合集

- 浏览器页面有哪三层构成,分别是什么,作用是什么
  - 构成:结构层,表示层,行为层
  - 分别是: HTML, CSS, JavaScript
  - 作用: HTML 实现页面结构, CSS 完成页面的表现与风格, JavaScript 实现一些客户端的功能与业务
- HTML5 的优点与缺点
  - 优点:
    - 网络标准统一, HTML5 本身是由 W3C 推荐出来的
    - 多设备,跨平台
    - 即时更新
    - 提高可用性和改进用户的友好体验
    - 有几个新标签,这将有助于开发人员定义重要的内容
    - 可以给站点带来更多的多媒体元素(视频和音频)
    - 可以很好地替代 Flash 和 Silverlight
    - 涉及到网站的抓取和索引的时候,对于 SEO 很友好
    - 被大量应用于移动应用程序和游戏
  - 缺点:
    - 安全:像之前 Firefox4 的 web scoket 和透明代理的实现存在严重的安全问题,同时 web storage, web socket 这样的功能很容易被黑客利用,来盗取用户的信息和资料
    - 完善性:许多特性各浏览器的支持程度也不一样
    - 技术门槛: HTML5 简化开发者工作的同时代表了有许多新的属性和 API 需要开发者学习,像 web worker, web scoket, web storage 等新特性,后台甚至浏览器原理的知识,机遇的同时也是巨大的挑战
    - 性能:某些平台上的引擎问题导致 HTML5 性能低下
    - 浏览器兼容性:最大缺点, IE9 以下浏览器几乎全军覆没
- DOCTYPE 作用,严格模式与混杂模式如何区分,它们有何意义
  - DOCTYPE 声明指出阅读程序应该用声明规则集来解释文档中的标记,在 Web 文档的情况下,"阅读程序"通常是浏览器或者校验器这样的一个程序,"规则"则是 W3C 所发布的一个文档类型定义(DTD)中包含的规则
  - DOCTYPE 的意义:
    - 声明位于文档中的最前面的位置,处于标签之前,此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范,该标签可声明三种 DTD 类型,分别表示严格版本,过渡版本以及基于框架的 HTML 文档
    - 所谓的标准模式只指,浏览器按 W3C 标准解析执行代码;怪异模式则是使用浏览器自己的方式解析执行代码,因为不同浏览器解析执行的方式不一样,所以称之为怪异模式;严格模式是浏览器根据 web 标准去解析页面,是一种要求严格的 DTD,不允许使用任何表现层的语法;如,严格模式的排版和 JS 运作模式是以该浏览器支持点的最高标准运行混杂模式则是一种向后兼容的解析方法,可以实现 IE5.5 以下版本浏览器的渲染模式
    - 浏览器解析时使用标准模式还是怪异模式,与网页中的 DTD 声明直接相关, DTD 声明定义了标准文档的类型(标准模式解析)文档类型,会使浏览器使用相应的方式加载网页并显示,忽略 DTD 声明,将使网页进入怪异模式
- HTML5 有哪些新特性,移除了哪些元素
  - HTML5 新增了27 个元素,废弃了 16 个元素,根据现有的规范标准,把 HTML5 的元素按优先级定义为结构性属性,级块性元素,行内语义性元素和交互性元素 4 大类
    - 结构性元素主要负责 web 上下文结构的定义:
      - section:在 web 页面应用中,该元素也可以用于区域的章节描述
      - header:页面主体上的头部,header 元素往往在一对 body 元素中
      - footer:页面的底部(页脚),通常会标出网站的相关信息
      - nav:专门用于菜单导航,链接导航的元素,是 navigator 的缩写
      - article:用于表现一篇文章的主体内容,一般为文字集中显示的区域
    - 级块性元素主要完成 web 页面区域的划分,确保内容的有效分割:
      - aside:用于表达注记,贴士,侧栏,摘要,插入的引用等作为补充主体的内容
      - figure:是对多个元素进行组合并展示的元素,通常与 ficaption 联合使用
      - code:表示一段代码块
      - dialog:用于表达人与人之前的对话,该元素包含 dt 和 dd 两个组合元素, dt 用于表示说话者,而 dd 用于表示说话内容
    - 行内语义性元素主要完成 web 页面具体内容的引用和描述,是丰富内容展示的基础:
      - meter:表示特定范围内的数值,可用于工资,数量,百分比等
      - time:表示时间值
      - progress:用来表示进度条,可通过对其 max, min, step 等属性进行控制,完成对进度的表示和监视
      - video:视频元素,用于支持和实现视频文件的直接播放,支持缓冲预载和多种视频媒体格式
      - audio:音频元素,用于支持和实现音频文件的直接播放,支持缓冲预载和多种音频媒体格式
    - 交互性元素主要用于功能性的内容表达,会有一定的内容和数据的关联,是各种事件的基础
      - details:用来表示一段具体的内容,但是内容默认可能不显示,通过某种手段(如单击)与 legend 交互才会显示出来
      - datagrid:用来控制客户端数据与显示,可以由动态脚本及时更新
      - menu:主要用于交互菜单(曾被废弃又被重新启动的元素)
      - command:用来处理命令按钮
- 浏览器的内核分别是什么
  - IE: trident 内核
  - Firefox: gecko 内核
  - Safari: webkit 内核
  - Opera: 以前是 presto 内核,现已改用 Google Chrome 的 Blink 内核
  - Chrome: Blink(基于 webkit, Google 和 Opera Software 共同开发)
- 每个 HTML 文件里开头都有个很重要的东西, DOCTYPE 它的作用
  - 声明位于文档中的最前面的位置,处于标签之前,此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范
- 说说对 HTML5 的认识
  - HTML5 指的是包括 HTML, CSS 和 JavaScript 在内的一套技术组合,它希望能够减少页面浏览器对于需要插件的丰富性网络应用服务(Plug-in-Based Rich Internet Application, RIA),例如: AdobeFlash, Microsoft Silverlight 与 Oracle JavaFX 的需求,并且提供更多能有效加强网络应用的标准集; HTML5 是 HTML 最新版本, 2014 年 10 月由万维网联盟(W3C)完成标准制定,目标是替换 1999 年所制定的 HTML4.01 和 XHTML1.0 标准,以期能在互联网应用迅速发展的时候,使网络标准达到匹配当代的网络需求
  - HTML4 陈旧不能满足日益发展的互联网需要,特别是移动互联网,为了增强浏览器功能 Flash 被广泛使用,但安全与稳定堪忧,不适合在移动端使用(耗电,触摸,不开放)
  - HTML5 增强了浏览器的原生功能,符合 HTML5 规范的浏览器功能将更加强大,减少了 Web 应用对插件的依赖,让用户体验更好,让开发更加方便,另外 W3C 从推出 HTML4.0 到 5.0 之间共经历了 17 年, HTML 的变化很小,这并不符合一个好产品的演进规则
- 对 web 标准以及 W3C 的理解与认识
  - 标签闭合,标签小写,不乱嵌套,提高搜索机器人搜索几率,使用外链 css 和 js 脚本,结构行为表现的分离,文件下载与页面速度更快,内容能被更多的用户所访问,内容能被更广泛的设备所访问,更少的代码和组件,容易维护,改版方便,不需要变动页面内容,提供打印版本而不需要复制内容,提高网站易用性
- HTML5 行内元素有哪些,块级元素有哪些,空元素有哪些
  - 行内元素:
    - a:锚点
    - abbr:缩写
    - acronym:首字
    - b:粗体(不推荐)
    - bdo:元素可覆盖默认的文本方向
    - big:大字体
    - br:换行
    - cite:引用
    - code:计算机代码(在引用源码的时候需要)
    - dfn:定义字段
    - em:强调
    - font:字体设定(不推荐)
    - i:斜体
    - img:图片
    - input:输入框
    - kbd:定义键盘文本
    - label:表格标签
    - q:短引用
    - s:中划线(不推荐)
    - samp:定义范例计算机代码
    - select:项目选择
    - small:小字体文本
    - span:常用内联容器,定义文本内区块
    - strike:中划线
    - strong:粗体强调
    - sub:下标 
    - sup:上标 
    - textarea:多行文本输入框 
    - tt:电传文本 
    - u:下划线 
    - var:定义变量
  - 块元素(block element)
    - address:地址 
    - blockquote:块引用 
    - center:居中对齐块 
    - dir:目录列表
    - div:常用块级容易,也是 css layout 的主要标签
    - dl:定义列表
    - fieldset: form 控制组
    - form:交互表单
    - h1:大标题
    - h2:副标题
    - h3: 3 级标题
    - h4: 4 级标题
    - h5: 5 级标题
    - h6: 6 级标题
    - hr:水平分隔线
    - isindex:使浏览器显示一个对话框,提示用户输入单行文本(不建议使用)
    - menu:菜单列表
    - noframes: frames 可选内容,对于不支持 frame 的浏览器显示此区块内容
    - noscript:可选脚本内容,对于不支持 script 的浏览器显示此内容
    - ol:排序表单
    - p:段落
    - pre:格式化文本
    - table:表格
    - ul:非排序列表
  - 可变元素为根据上下文语境决定该元素为块元素或者内联元素
    - applet:定义嵌入的 applet
    - button:按钮
    - del:删除文本
    - iframe:创建包含另外一个文档的内联框架(即行内框架)
    - ins:插入的文本
    - map:图片区块
    - object: object 对象
    - script:客户端脚本
  - 空元素(在 HTML 元素中,没有内容的 HTML 元素被称为空元素)
    - br:换行
    - hr:分隔线
    - input:文本框等
    - img:图片
    - link:定义文档与外部资源的关系
    - meta:提供有关页面的元信息
- 什么是 WebGL,它有什么优点
  - WebGL(全写 Web Graphics Library)是一种 3D 绘图标准,这种绘图技术标准允许把 JavaScript 和 OpenGL ES2.0 结合在一起,通过增加 OpenGL ES2.0 的一个 JavaScript 绑定, WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染,这样 Web 开发人员就可以借助系统显卡来在浏览器更流畅地展示 3D 场景和模型,还能创建复杂的导航和数据视觉化;显然, WebGL 技术标准免去了开发网页专用渲染插件的麻烦,可被用于创建具有复杂 3D 结构的网站页面,甚至可以用来设计 3D 网页游戏等等
  - WebGL 完美的解决了现有的 Web 交互式三维动画的两个问题:
    - 它通过 HTML 脚本本身实现 Web 交互式三维动画的制作,无需任何浏览器插件支持
    - 它利用底层的图形硬件加速功能进行的图片渲染,是通过统一的,标准的,跨平台的 OpenGL 接口实现的
  - 通俗说: WebGL 中 canvas 绘图中的 3D 版本,因为原生的 WebGL 很复杂,经常会使用一些第三方的库,如 three.js 等,这些库多数用于 HTML5 游戏开发
- link 和 @import 的区别
  - 两者都是外部引用 CSS 的样式,但是存在一定的区别:
    - link 是 XHTML 标签,除了加载 CSS 外,还可以定义 RSS 等其他事务; @import 属于 CSS 范畴,只能加载 CSS
    - link 引用 CSS 时,在页面载入时同时加载; @import 需要页面网页完全载入以后加载
    - link 是 XHTML 标签,无兼容问题; @import 是在 CSS2.1 提出的,低版本的浏览器不支持
    - link 是支持使用 JavaScript 控制 DOM 去改变样式;而 @import 不支持
- 说说对 SVG 的理解
  - SVG 可缩放矢量图形(Scalable Vector Graphics)是基于可扩展标记语言(XML),用于描述二维矢量图形的一种图形格式; SVG 是 W3C("World Web ConSortium"即"国际互联网标准组织")在 2000 年 8 月制定的一种新的二维矢量图形格式,也是规范中的网络矢量图形标准; SVG 严格遵从 XML 语法,并用文本格式的描述性语言来描述图像内容,因此是一种和图像分辨率无关的矢量图形格式; SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准
  - 特点:
    - 任意缩放:用户可以任意缩放图像显示,而不会破坏图像的清晰度,细节等
    - 文本独立: SVG 图像中的文字独立于图像,文字保留可编辑和可搜寻的状态;也不会再有字体的限制,用户系统即使没有安装某一字体,也会看到和他们制作时完全相同的画面
    - 较小文件:总体来说, SVG 文件比那些 GIF 和 JPEG 格式的文件要小很多,而且下载也快
    - 超强显示效果: SVG 图像在屏幕上总是边缘清晰,它的清晰度适合任何屏幕分辨率和打印分辨率
    - 超级颜色控制: SVG 图像提供一个 1600 万种颜色的调色板,支持 ICC 颜色描述文件标准, RGB, 线 X 填充,渐变和蒙版
    - 交互 X 和智能化
  - SVG 面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题,另一个问题就是 SVG 的本地运行环境下的厂家支持程度;浏览器支持:
    - IE9 
    - 火狐
    - 谷歌 Chrome
    - Opera
    - Safari
    - IE8和早前版本都需要一个插件,如 Adobe SVG 浏览器,这是免费提供的
- HTML 全局属性(global attribute)有哪些
  - accesskey:设置快捷键,提供快速访问元素,如 aaa 在 windows 下的 firefox 中按 alt + shift + a 可激活元素 
  - class:为元素设置类标识,多个类名用空格分开, CSS 和 JavaScript 可通过 class 属性获取元素
  - contenteditable:指定元素内容是否可编辑 
  - contextmenu:自定义鼠标右键弹出菜单内容
  - data-*:为元素增加自定义属性
  - dir:设置元素文本方向
  - draggable:设置元素是否可拖拽
  - dropzone:设置元素拖放类型: copy(拖动数据会产生被拖动数据的副本), move(拖动数据会导致被拖动数据被移动到新的位置), link(拖动数据会产生指向原始数据的链接)
  - hidden:样式上会导致元素不显示,但是不能用这个属性实现样式效果
  - id:元素 id,文档内唯一
  - lang:元素内容的语言
  - spellcheck:是否启动拼写和语法检查
  - style:行内 css 样式
  - tabindex:设置元素可以获得焦点,通过 tab 可以导航
  - title:元素相关的建议信息
  - translate:元素和子孙节点内容是否需要本地化
- 说说超链接 target 属性的取值和作用
  - target 这个属性指定所链接的页面在浏览器窗口中的打开方式
  - target 属性的参数值:
    - _blank:在新浏览器窗口中打开链接文件
    - _parent:在链接的文件载入含有该链接框架的父框架或父窗口中,如果含有该链接的框架不是嵌套的,则在浏览器全屏窗口中载入链接的文件,就像 _self 参数一样
    - _self:在同一框架或窗口中打开所链接的文档,此参数为默认值,通常不用指定
    - _top:在当前的整个浏览器窗口中打开所链接的文档,因而会删除所有框架
- ``` data- ``` 属性的作用是什么
  - ``` data- ``` 为 H5 新增的为前端开发者提供自定义的属性,这些属性集可以通过对象的 ``` dataset ``` 属性获取,不支持该属性的浏览器可以通过 ``` getAttribute ``` 方法获取
  - 需要注意的是: ``` data- ``` 之后的以连字符分割的多个单词组成的属性,获取的时候使用驼峰风格,所有主流浏览器都支持 ``` data- ``` 属性;即:当没有合适的属性和元素时,自定义的 data 属性是能够存储页面或 App 的私有的自定义数据
- 介绍一下对浏览器内核的理解
  - 浏览器内核主要分成两部分:
    - 渲染引擎(layout engineer 或 Rendering Engine):负责取得网页的内容(HTML, XML,图像等等),整理讯息(例如加入 CSS 等),以及计算网页的显示方式,然后会输出至显示器或打印机;浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同;所有网页浏览器,电子邮件客户端以及其他需要编辑,显示网络内容的应用程序都需要内核
    - JS 引擎:解析和执行 JavaScript 来实现网页的动态效果
  - 最开始渲染引擎和 JS 引擎并没有区分的很明确,后来 JS 引擎越来越独立,内核就倾向于只指渲染引擎
- iframe 有哪些缺点
  - iframe 的缺点
    - iframe 会阻塞主页面的 Onload 事件,;搜索引擎的检索程序无法解读这个页面,不利于 SEO
    - iframe 和主页面共享连接池,而浏览器对相同域的链接有限制,所以会影响页面的并行加载
  - 使用 iframe 之前需要考虑这两个缺点,如果需要使用 iframe,最好是通过 javascript 动态给 iframe 添加 src 属性值,这样可以绕过以上两个问题
- label 的作用是什么,是怎么用的
  - label 标签来定义表单控制间的关系,当用户选择该标签时,浏览器会自动将焦点转到和标签相关的表单控件上
  - 注意: label 的 for 属性值要与后面对应的 input 标签 id 属性值相同
- 如何实现浏览器内多个标签页之间的通信
  - WebSocket 和 SharedWorker
  - 也可以调用 localStorage, cookies 等本地存储方式
  - localStorage 另一个浏览上下文里被添加,修改或删除,它都会触发一个事件,通过监听事件,控制它的值来进行页面信息通信
  - 注意: Safari 在无痕模式下设置 localStorage 值时会抛出 QuotaExceededError 的异常
- 如果在页面上实现一个圆形的可点击区域
  - map + area 或者 svg
  - border-radius
  - 纯 js 实现,需要求一个点不在圆上简单算法,获取鼠标坐标等等
- title 与 h3 的区别, b 与 strong 的区别, i 与 em 的区别
  - title 与 h3 的区别:
    - title 属性没有明确意义只表示是个标题, h3 则表示层次明确的标题,对页面信息的抓取也有很大的影响
  - b 与 strong 的区别:
    - strong 是标明重点内容,有语气加强的含义,使用阅读设备阅读网络时: strong 会重读,而 b 是展示强调内容
  - i 与 em 的区别:
    - i 内容展示为斜体, em 表示强调的文本
  - 自然样式标签(Physical Style Elements)
    - b, i, u, s, pre
  - 语义样式标签(Semantic Style Elements)
    - strong, em, ins, del, code
  - 应该准确使用语义样式标签,但不能乱用,如果不能确定时首选使用自然样式标签
- 实现不使用 border 画出 1px 高的线,在不同浏览器的标准模式与怪异模式下都能保持一致的效果

  ```

    <div style="width: 100%; height: 1px; background-color: black"></div>

  ```

- HTML5 标签的作用
  - 使 Web 页面的内容更加有序和规范
  - 使搜索引擎更加容易按照 HTML5 规则识别出有效的内容
  - 使 Web 页面更接近于一种数据字段和表
- 简述一下 src 和 href 的区别
  - src 用于替换当前元素, href 用于在当前文档和引用资源之间确立联系
  - src 是 source 的缩写,指向外部资源的位置,指向的内容将会嵌入到文档中当前标签所在位置;在请求 src 资源时会将其指向的资源下载并应用到文档内,例如 js 脚本, img 图片和 iframe 等元素;当浏览器解析到该元素的时候,会暂停其他资源的下载和处理,直到将该资源加载,编译,执行完毕,图片和框架等元素也如此,类似于将所指向资源嵌入当前标签内,这也是为什么将 js 脚本放在底部而不是头部
  - href 是 Hypertext Reference 的缩写,指向网络资源所在位置,建立和当前元素(锚点)或当前文档(链接)之间的链接,如果在文档中添加 ``` <link href="common.css"> ```,那么浏览器会识别该文档为 css 文件,就会执行并行下载资源并且不会停止对当前文档的处理,这也是为什么建议使用 link 方式来加载 CSS,而不是使用 @import 方式
- 谈谈对 canvas 的理解
  - canvas 是 HTML5 中新增一个 HTML5 标签与操作 canvas 的 javascript API,它可以实现在网页中完成动态的 2D 与 3D 图像技术;标记和 SVG 以及 VML 之间的一个重要的不同点是,一个基于 JavaScript 的绘图 API,而 SVG 和 VML 使用一个 XML 文档来描述绘图; SVG 绘图很容易编辑与生成,但功能明显要弱一点; canvas 可以完成动画,游戏,图表,图像处理等原来需要 Flash 完成的一些功能
- WebSocket 与消息推送
  - B/S 架构的系统多使用 HTTP 协议, HTTP 协议的特点:
    - 无状态协议
    - 用于通过 Internet 发送请求消息和响应消息
    - 使用端口接收和发送消息,默认为 80 端口,底部通信还是使用 Socket 完成
    <img src="./image/WebSocket.png">
  - HTTP 协议决定了服务器与客户端之间的连接方式,无法直接实现消息推送(F5 已坏),一些变相的解决方法:
    - 双向通信与消息推送
      - 轮询:客户端定时向服务器发送 Ajax 请求,服务器接到请求后马上返回响应信息并关闭连接
      - 优点:后端程序编写比较容易
      - 缺点:请求中有大半是无用,浪费带宽和服务器资源
      - 实例:适用于小型应用
    - 长轮询:客户端向服务器发送 Ajax 请求,服务器接到请求后 hold 住连接,直到有新消息才返回响应信息并关闭连接,客户端处理完响应信息后再向服务器发送新的请求
      - 优点:在无消息的情况下不会频繁的请求,耗费资小
      - 缺点:服务器 hold 连接会消耗资源,返回数据顺序无保证,难于管理维护; Comet 异步的 ashx
      - 实例: WebQQ, Hi 网页版, Facebook IM
    - 长连接:在页面里嵌入一个隐藏 iframe,将这个隐藏 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求,服务器端就能源源不断地往客户端输入数据
      - 优点:消息即时到达,不发无用请求;管理起来也相对方便
      - 缺点:服务器维护一个长连接会增加开销
      - 实例: Gmail 聊天
    - Flash Socket:在页面中内嵌入一个使用了 Socket 类的 Flash 程序, JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信, JavaScript 在收到服务器端传送的信息后控制页面的显示
      - 优点:实现真正的即时通信,而不是伪即时
      - 缺点:客户端必须安装 Flash 插件;非 HTTP 协议,无法自动穿越防火墙
      - 实例:网络互动游戏
    - WebSocket:是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术;依靠这种技术可以实现客户端和服务器端的长连接,双向实时通信
      - 特点:
        - 事件驱动
        - 异步
        - 使用 ws 或者 wss 协议的客户端 socket
        - 能够实现真正意义上的推送功能
      - 缺点:少部分浏览器不支持,浏览器支持的程度与方式有区别
- img 的 title 和 alt 有什么区别
  - alt 用于图片无法加载时显示,title 为该属性提供信息,通常当鼠标滑动到元素上的时候显示
- 表单的基本组成部分有哪些,表单的主要用途是什么
  - 表单的基本组成部分:表单标签,表单域,表单按钮
    - 表单标签:这里面包含了处理表单数据所用 CGI 程序的 URL,以及数据提交到服务器的方法
    - 表单域:包含了文本框,密码框,隐藏域,多行文本框,复选框,单选框,下拉选择框和文件上传框等
    - 表单按钮:包括提交按钮,复位按钮和一般按钮;用于将数据传送到服务器上的 CGI 脚本或者取消输入,还可以用表单按钮来控制其他定义了处理脚本的处理工作
  - 表单的主要用途:表单在网页上主要负责数据采集的功能,和向服务器传送数据
- 表单提交中 Get 和 Post 方式的区别
  - get 是从服务器上获取数据, post 是向服务器传送数据
  - get 是把参数数据队列加到提交表单的 action 属性所指的 url 中,值和表单内各个字段一一对应,在 url 中可以看到; post 是通过 HTTP post 机制,将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 action 属性所指的地址,用户看不到这个过程
  - 对于 get 方式,服务器端用 Request.QueryString 获取变量的值;对于 post 方式,服务器端用 Request.Form 获取提交的数据
  - get 传送的数据量较小,不能大于 2KB; post 传送的数据量较大,一般被默认为不受限制,但理论上, IIS4 中最大量为 80KB, IIS5 中为 100KB
  - get 安全性低, post 安全性较高